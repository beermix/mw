commit da883d2c3b2fcf4977f2bbac11012da804655919
Author: Kirill Bobyrev <kbobyrev@google.com>
Date:   Thu Feb 13 14:17:30 2020 +0100

    [clangd] Expose Code Completion score to the client
    
    Summary:
    Make it possible for the client to adjust the ranking by using the score Clangd
    calculates for the completion items.
    
    Reviewers: sammccall
    
    Subscribers: ilya-biryukov, MaskRay, jkorous, arphaman, kadircet, usaxena95, cfe-commits
    
    Tags: #clang
    
    Differential Revision: https://reviews.llvm.org/D74547
    
    (cherry picked from commit ff7b5bac04fa4946935ea45214e29f267d6c1d7b)

diff --git a/clang-tools-extra/clangd/CodeComplete.cpp b/clang-tools-extra/clangd/CodeComplete.cpp
index 045b78d0779..86268b6c25e 100644
--- a/clang-tools-extra/clangd/CodeComplete.cpp
+++ b/clang-tools-extra/clangd/CodeComplete.cpp
@@ -1842,6 +1842,8 @@ CompletionItem CodeCompletion::render(const CodeCompleteOptions &Opts) const {
   if (InsertInclude && InsertInclude->Insertion)
     LSP.additionalTextEdits.push_back(*InsertInclude->Insertion);
 
+  LSP.score = Score.ExcludingName;
+
   return LSP;
 }
 
diff --git a/clang-tools-extra/clangd/Protocol.cpp b/clang-tools-extra/clangd/Protocol.cpp
index 29ceb1da545..7aca377cebe 100644
--- a/clang-tools-extra/clangd/Protocol.cpp
+++ b/clang-tools-extra/clangd/Protocol.cpp
@@ -826,6 +826,7 @@ llvm::json::Value toJSON(const CompletionItem &CI) {
     Result["additionalTextEdits"] = llvm::json::Array(CI.additionalTextEdits);
   if (CI.deprecated)
     Result["deprecated"] = CI.deprecated;
+  Result["score"] = CI.score;
   return std::move(Result);
 }
 
diff --git a/clang-tools-extra/clangd/Protocol.h b/clang-tools-extra/clangd/Protocol.h
index 1b999f1131d..3b86935017c 100644
--- a/clang-tools-extra/clangd/Protocol.h
+++ b/clang-tools-extra/clangd/Protocol.h
@@ -995,6 +995,13 @@ struct CompletionItem {
   /// Indicates if this item is deprecated.
   bool deprecated = false;
 
+  /// This is Clangd extension.
+  /// The score that Clangd calculates to rank completion items. This score can
+  /// be used to adjust the ranking on the client side.
+  /// NOTE: This excludes fuzzy matching score which is typically calculated on
+  /// the client side.
+  float score = 0.f;
+
   // TODO(krasimir): The following optional fields defined by the language
   // server protocol are unsupported:
   //
diff --git a/clang-tools-extra/clangd/test/completion-auto-trigger.test b/clang-tools-extra/clangd/test/completion-auto-trigger.test
index 46871b9d3e3..cf7261e9043 100644
--- a/clang-tools-extra/clangd/test/completion-auto-trigger.test
+++ b/clang-tools-extra/clangd/test/completion-auto-trigger.test
@@ -24,6 +24,7 @@
 # CHECK-NEXT:        "insertTextFormat": 1,
 # CHECK-NEXT:        "kind": 5,
 # CHECK-NEXT:        "label": " size",
+# CHECK-NEXT:        "score": {{[0-9]+.[0-9]+}},
 # CHECK-NEXT:        "sortText": "{{.*}}size",
 # CHECK-NEXT:        "textEdit": {
 # CHECK-NEXT:          "newText": "size",
@@ -46,6 +47,7 @@
 # CHECK-NEXT:         "insertTextFormat": 1,
 # CHECK-NEXT:         "kind": 10,
 # CHECK-NEXT:         "label": " default_capacity",
+# CHECK-NEXT:         "score": {{[0-9]+.[0-9]+}},
 # CHECK-NEXT:         "sortText": "{{.*}}default_capacity",
 # CHECK-NEXT:         "textEdit": {
 # CHECK-NEXT:           "newText": "default_capacity",
@@ -86,6 +88,7 @@
 # CHECK-NEXT:        "insertTextFormat": 1,
 # CHECK-NEXT:        "kind": 6,
 # CHECK-NEXT:        "label": " ns_member",
+# CHECK-NEXT:        "score": {{[0-9]+.[0-9]+}},
 # CHECK-NEXT:        "sortText": "{{.*}}ns_member",
 # CHECK-NEXT:        "textEdit": {
 # CHECK-NEXT:          "newText": "ns_member",
diff --git a/clang-tools-extra/clangd/test/completion-snippets.test b/clang-tools-extra/clangd/test/completion-snippets.test
index 22cd0821b22..7dc98094385 100644
--- a/clang-tools-extra/clangd/test/completion-snippets.test
+++ b/clang-tools-extra/clangd/test/completion-snippets.test
@@ -33,6 +33,7 @@
 # CHECK-NEXT:      "insertTextFormat": 2,
 # CHECK-NEXT:      "kind": 3,
 # CHECK-NEXT:      "label": " func_with_args(int a, int b)",
+# CHECK-NEXT:      "score": {{[0-9]+.[0-9]+}},
 # CHECK-NEXT:      "sortText": "{{.*}}func_with_args"
 # CHECK-NEXT:      "textEdit": {
 # CHECK-NEXT:        "newText": "func_with_args(${1:int a}, ${2:int b})",
diff --git a/clang-tools-extra/clangd/test/completion.test b/clang-tools-extra/clangd/test/completion.test
index 0094d4740b2..d6376b3bfe5 100644
--- a/clang-tools-extra/clangd/test/completion.test
+++ b/clang-tools-extra/clangd/test/completion.test
@@ -17,6 +17,7 @@
 # CHECK-NEXT:      "insertTextFormat": 1,
 # CHECK-NEXT:      "kind": 5,
 # CHECK-NEXT:      "label": " a",
+# CHECK-NEXT:      "score": {{[0-9]+.[0-9]+}},
 # CHECK-NEXT:      "sortText": "{{.*}}a"
 # CHECK-NEXT:      "textEdit": {
 # CHECK-NEXT:        "newText": "a",
@@ -50,6 +51,7 @@
 # CHECK-NEXT:      "insertTextFormat": 1,
 # CHECK-NEXT:      "kind": 5,
 # CHECK-NEXT:      "label": " b",
+# CHECK-NEXT:      "score": {{[0-9]+.[0-9]+}},
 # CHECK-NEXT:      "sortText": "{{.*}}b"
 # CHECK-NEXT:      "textEdit": {
 # CHECK-NEXT:        "newText": "b",
diff --git a/clang-tools-extra/clangd/test/protocol.test b/clang-tools-extra/clangd/test/protocol.test
index 3e16c9ec9b3..5e852d1d9de 100644
--- a/clang-tools-extra/clangd/test/protocol.test
+++ b/clang-tools-extra/clangd/test/protocol.test
@@ -39,6 +39,7 @@ Content-Length: 146
 # CHECK-NEXT:        "insertTextFormat": 1,
 # CHECK-NEXT:        "kind": 5,
 # CHECK-NEXT:        "label": " a",
+# CHECK-NEXT:        "score": {{[0-9]+.[0-9]+}},
 # CHECK-NEXT:        "sortText": "{{.*}}"
 #      CHECK:    ]
 # CHECK-NEXT:  }
@@ -68,6 +69,7 @@ Content-Length: 146
 # CHECK-NEXT:        "insertTextFormat": 1,
 # CHECK-NEXT:        "kind": 5,
 # CHECK-NEXT:        "label": " a",
+# CHECK-NEXT:        "score": {{[0-9]+.[0-9]+}},
 # CHECK-NEXT:        "sortText": "{{.*}}"
 #      CHECK:    ]
 # CHECK-NEXT:  }
@@ -97,6 +99,7 @@ Content-Length: 146
 # CHECK-NEXT:        "insertTextFormat": 1,
 # CHECK-NEXT:        "kind": 5,
 # CHECK-NEXT:        "label": " a",
+# CHECK-NEXT:        "score": {{[0-9]+.[0-9]+}},
 # CHECK-NEXT:        "sortText": "{{.*}}"
 #      CHECK:    ]
 # CHECK-NEXT:  }
diff --git a/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp b/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp
index 8017fc98b8e..3e9b97dc3b3 100644
--- a/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp
+++ b/clang-tools-extra/clangd/unittests/CodeCompleteTests.cpp
@@ -1643,6 +1643,7 @@ TEST(CompletionTest, Render) {
   Include.Header = "\"foo.h\"";
   C.Kind = CompletionItemKind::Method;
   C.Score.Total = 1.0;
+  C.Score.ExcludingName = .5;
   C.Origin = SymbolOrigin::AST | SymbolOrigin::Static;
 
   CodeCompleteOptions Opts;
@@ -1660,6 +1661,7 @@ TEST(CompletionTest, Render) {
   EXPECT_THAT(R.additionalTextEdits, IsEmpty());
   EXPECT_EQ(R.sortText, sortText(1.0, "x"));
   EXPECT_FALSE(R.deprecated);
+  EXPECT_EQ(R.score, .5f);
 
   Opts.EnableSnippets = true;
   R = C.render(Opts);

commit 0cffa939a7d8af8a3b62ec790bf02066b4568e53
Author: Nathan James <n.james93@hotmail.co.uk>
Date:   Thu Feb 13 20:20:37 2020 +0000

    Fix crash in InfinteLoopCheck
    
    (cherry picked from commit 8c4cf23dee1ac3f259c4795b275cc9bb1234aa29)

diff --git a/clang-tools-extra/clang-tidy/bugprone/InfiniteLoopCheck.cpp b/clang-tools-extra/clang-tidy/bugprone/InfiniteLoopCheck.cpp
index 5e5651fc256..bcdb445948d 100644
--- a/clang-tools-extra/clang-tidy/bugprone/InfiniteLoopCheck.cpp
+++ b/clang-tools-extra/clang-tidy/bugprone/InfiniteLoopCheck.cpp
@@ -153,6 +153,8 @@ static std::string getCondVarNames(const Stmt *Cond) {
 }
 
 static bool isKnownFalse(const Expr &Cond, const ASTContext &Ctx) {
+  if (Cond.isValueDependent())
+    return false;
   bool Result = false;
   if (Cond.EvaluateAsBooleanCondition(Result, Ctx))
     return !Result;

commit 4f53867ec27bde33479c7891c256225f2075945a
Author: Aaron Puchert <aaronpuchert@alice-dsl.net>
Date:   Mon Feb 17 23:47:28 2020 +0100

    Drop git version suffix
    
    Summary: Also fix the version for libcxxabi, which was stuck in the past.
    
    Reviewers: hans, mclow.lists
    
    Reviewed By: hans
    
    Subscribers: mgorny, christof, libcxx-commits, llvm-commits, ldionne
    
    Tags: #libc, #llvm
    
    Differential Revision: https://reviews.llvm.org/D74586

diff --git a/libcxx/CMakeLists.txt b/libcxx/CMakeLists.txt
index 443097c090e..1d6ab58166e 100644
--- a/libcxx/CMakeLists.txt
+++ b/libcxx/CMakeLists.txt
@@ -27,7 +27,7 @@ if (CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR OR LIBCXX_STANDALONE_BUIL
   project(libcxx CXX C)
 
   set(PACKAGE_NAME libcxx)
-  set(PACKAGE_VERSION 10.0.0git)
+  set(PACKAGE_VERSION 10.0.0)
   set(PACKAGE_STRING "${PACKAGE_NAME} ${PACKAGE_VERSION}")
   set(PACKAGE_BUGREPORT "llvm-bugs@lists.llvm.org")
 
diff --git a/libcxxabi/CMakeLists.txt b/libcxxabi/CMakeLists.txt
index f3698e9c46e..59d99971a76 100644
--- a/libcxxabi/CMakeLists.txt
+++ b/libcxxabi/CMakeLists.txt
@@ -21,7 +21,7 @@ if (CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR OR LIBCXXABI_STANDALONE_B
   project(libcxxabi CXX C)
 
   set(PACKAGE_NAME libcxxabi)
-  set(PACKAGE_VERSION 9.0.0svn)
+  set(PACKAGE_VERSION 10.0.0)
   set(PACKAGE_STRING "${PACKAGE_NAME} ${PACKAGE_VERSION}")
   set(PACKAGE_BUGREPORT "llvm-bugs@lists.llvm.org")
 
diff --git a/libunwind/CMakeLists.txt b/libunwind/CMakeLists.txt
index 6dd0a15405b..7726511b6e1 100644
--- a/libunwind/CMakeLists.txt
+++ b/libunwind/CMakeLists.txt
@@ -83,7 +83,7 @@ if (CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR OR LIBUNWIND_STANDALONE_B
   endif()
 
   set(PACKAGE_NAME libunwind)
-  set(PACKAGE_VERSION 10.0.0git)
+  set(PACKAGE_VERSION 10.0.0)
   set(PACKAGE_STRING "${PACKAGE_NAME} ${PACKAGE_VERSION}")
   set(PACKAGE_BUGREPORT "llvm-bugs@lists.llvm.org")
 
diff --git a/llvm/CMakeLists.txt b/llvm/CMakeLists.txt
index 9bbcba069c1..567396870a5 100644
--- a/llvm/CMakeLists.txt
+++ b/llvm/CMakeLists.txt
@@ -25,7 +25,7 @@ if(NOT DEFINED LLVM_VERSION_PATCH)
   set(LLVM_VERSION_PATCH 0)
 endif()
 if(NOT DEFINED LLVM_VERSION_SUFFIX)
-  set(LLVM_VERSION_SUFFIX git)
+  set(LLVM_VERSION_SUFFIX "")
 endif()
 
 if (NOT PACKAGE_VERSION)

commit f87a0929c6bd59750e424d06581507cdfd439a56
Author: John Brawn <john.brawn@arm.com>
Date:   Fri Jan 24 15:47:51 2020 +0000

    Add lowering of STRICT_FSETCC and STRICT_FSETCCS
    
    These become STRICT_FCMP and STRICT_FCMPE, which then get selected to the
    corresponding FCMP and FCMPE instructions, though the handling from there on
    isn't fully correct as we don't model reads and writes to FPCR and FPSR.
    
    Differential Revision: https://reviews.llvm.org/D73368
    
    (cherry picked from commit 2224407ef5baf6100fa22420feb4d25af1a9493f)

diff --git a/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp b/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
index d45a8005756..e579159daed 100644
--- a/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
+++ b/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
@@ -211,6 +211,12 @@ AArch64TargetLowering::AArch64TargetLowering(const TargetMachine &TM,
   setOperationAction(ISD::SETCC, MVT::f16, Custom);
   setOperationAction(ISD::SETCC, MVT::f32, Custom);
   setOperationAction(ISD::SETCC, MVT::f64, Custom);
+  setOperationAction(ISD::STRICT_FSETCC, MVT::f16, Custom);
+  setOperationAction(ISD::STRICT_FSETCC, MVT::f32, Custom);
+  setOperationAction(ISD::STRICT_FSETCC, MVT::f64, Custom);
+  setOperationAction(ISD::STRICT_FSETCCS, MVT::f16, Custom);
+  setOperationAction(ISD::STRICT_FSETCCS, MVT::f32, Custom);
+  setOperationAction(ISD::STRICT_FSETCCS, MVT::f64, Custom);
   setOperationAction(ISD::BITREVERSE, MVT::i32, Legal);
   setOperationAction(ISD::BITREVERSE, MVT::i64, Legal);
   setOperationAction(ISD::BRCOND, MVT::Other, Expand);
@@ -1235,6 +1241,8 @@ const char *AArch64TargetLowering::getTargetNodeName(unsigned Opcode) const {
   case AArch64ISD::CCMN:              return "AArch64ISD::CCMN";
   case AArch64ISD::FCCMP:             return "AArch64ISD::FCCMP";
   case AArch64ISD::FCMP:              return "AArch64ISD::FCMP";
+  case AArch64ISD::STRICT_FCMP:       return "AArch64ISD::STRICT_FCMP";
+  case AArch64ISD::STRICT_FCMPE:      return "AArch64ISD::STRICT_FCMPE";
   case AArch64ISD::DUP:               return "AArch64ISD::DUP";
   case AArch64ISD::DUPLANE8:          return "AArch64ISD::DUPLANE8";
   case AArch64ISD::DUPLANE16:         return "AArch64ISD::DUPLANE16";
@@ -1668,6 +1676,17 @@ static bool isCMN(SDValue Op, ISD::CondCode CC) {
          (CC == ISD::SETEQ || CC == ISD::SETNE);
 }
 
+static SDValue emitStrictFPComparison(SDValue LHS, SDValue RHS, const SDLoc &dl,
+                                      SelectionDAG &DAG, SDValue Chain,
+                                      bool IsSignaling) {
+  EVT VT = LHS.getValueType();
+  assert(VT != MVT::f128);
+  assert(VT != MVT::f16 && "Lowering of strict fp16 not yet implemented");
+  unsigned Opcode =
+      IsSignaling ? AArch64ISD::STRICT_FCMPE : AArch64ISD::STRICT_FCMP;
+  return DAG.getNode(Opcode, dl, {VT, MVT::Other}, {Chain, LHS, RHS});
+}
+
 static SDValue emitComparison(SDValue LHS, SDValue RHS, ISD::CondCode CC,
                               const SDLoc &dl, SelectionDAG &DAG) {
   EVT VT = LHS.getValueType();
@@ -3104,6 +3123,8 @@ SDValue AArch64TargetLowering::LowerOperation(SDValue Op,
   case ISD::GlobalTLSAddress:
     return LowerGlobalTLSAddress(Op, DAG);
   case ISD::SETCC:
+  case ISD::STRICT_FSETCC:
+  case ISD::STRICT_FSETCCS:
     return LowerSETCC(Op, DAG);
   case ISD::BR_CC:
     return LowerBR_CC(Op, DAG);
@@ -5154,9 +5175,15 @@ SDValue AArch64TargetLowering::LowerSETCC(SDValue Op, SelectionDAG &DAG) const {
   if (Op.getValueType().isVector())
     return LowerVSETCC(Op, DAG);
 
-  SDValue LHS = Op.getOperand(0);
-  SDValue RHS = Op.getOperand(1);
-  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(2))->get();
+  bool IsStrict = Op->isStrictFPOpcode();
+  bool IsSignaling = Op.getOpcode() == ISD::STRICT_FSETCCS;
+  unsigned OpNo = IsStrict ? 1 : 0;
+  SDValue Chain;
+  if (IsStrict)
+    Chain = Op.getOperand(0);
+  SDValue LHS = Op.getOperand(OpNo + 0);
+  SDValue RHS = Op.getOperand(OpNo + 1);
+  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(OpNo + 2))->get();
   SDLoc dl(Op);
 
   // We chose ZeroOrOneBooleanContents, so use zero and one.
@@ -5167,17 +5194,19 @@ SDValue AArch64TargetLowering::LowerSETCC(SDValue Op, SelectionDAG &DAG) const {
   // Handle f128 first, since one possible outcome is a normal integer
   // comparison which gets picked up by the next if statement.
   if (LHS.getValueType() == MVT::f128) {
-    softenSetCCOperands(DAG, MVT::f128, LHS, RHS, CC, dl, LHS, RHS);
+    softenSetCCOperands(DAG, MVT::f128, LHS, RHS, CC, dl, LHS, RHS, Chain,
+                        IsSignaling);
 
     // If softenSetCCOperands returned a scalar, use it.
     if (!RHS.getNode()) {
       assert(LHS.getValueType() == Op.getValueType() &&
              "Unexpected setcc expansion!");
-      return LHS;
+      return IsStrict ? DAG.getMergeValues({LHS, Chain}, dl) : LHS;
     }
   }
 
   if (LHS.getValueType().isInteger()) {
+    assert(!IsStrict && "Unexpected integer in strict fp comparison!");
     SDValue CCVal;
     SDValue Cmp = getAArch64Cmp(
         LHS, RHS, ISD::getSetCCInverse(CC, LHS.getValueType()), CCVal, DAG, dl);
@@ -5194,10 +5223,15 @@ SDValue AArch64TargetLowering::LowerSETCC(SDValue Op, SelectionDAG &DAG) const {
 
   // If that fails, we'll need to perform an FCMP + CSEL sequence.  Go ahead
   // and do the comparison.
-  SDValue Cmp = emitComparison(LHS, RHS, CC, dl, DAG);
+  SDValue Cmp;
+  if (IsStrict)
+    Cmp = emitStrictFPComparison(LHS, RHS, dl, DAG, Chain, IsSignaling);
+  else
+    Cmp = emitComparison(LHS, RHS, CC, dl, DAG);
 
   AArch64CC::CondCode CC1, CC2;
   changeFPCCToAArch64CC(CC, CC1, CC2);
+  SDValue Res;
   if (CC2 == AArch64CC::AL) {
     changeFPCCToAArch64CC(ISD::getSetCCInverse(CC, LHS.getValueType()), CC1,
                           CC2);
@@ -5206,7 +5240,7 @@ SDValue AArch64TargetLowering::LowerSETCC(SDValue Op, SelectionDAG &DAG) const {
     // Note that we inverted the condition above, so we reverse the order of
     // the true and false operands here.  This will allow the setcc to be
     // matched to a single CSINC instruction.
-    return DAG.getNode(AArch64ISD::CSEL, dl, VT, FVal, TVal, CC1Val, Cmp);
+    Res = DAG.getNode(AArch64ISD::CSEL, dl, VT, FVal, TVal, CC1Val, Cmp);
   } else {
     // Unfortunately, the mapping of LLVM FP CC's onto AArch64 CC's isn't
     // totally clean.  Some of them require two CSELs to implement.  As is in
@@ -5219,8 +5253,9 @@ SDValue AArch64TargetLowering::LowerSETCC(SDValue Op, SelectionDAG &DAG) const {
         DAG.getNode(AArch64ISD::CSEL, dl, VT, TVal, FVal, CC1Val, Cmp);
 
     SDValue CC2Val = DAG.getConstant(CC2, dl, MVT::i32);
-    return DAG.getNode(AArch64ISD::CSEL, dl, VT, TVal, CS1, CC2Val, Cmp);
+    Res = DAG.getNode(AArch64ISD::CSEL, dl, VT, TVal, CS1, CC2Val, Cmp);
   }
+  return IsStrict ? DAG.getMergeValues({Res, Cmp.getValue(1)}, dl) : Res;
 }
 
 SDValue AArch64TargetLowering::LowerSELECT_CC(ISD::CondCode CC, SDValue LHS,
diff --git a/llvm/lib/Target/AArch64/AArch64ISelLowering.h b/llvm/lib/Target/AArch64/AArch64ISelLowering.h
index 672dfc4fcbc..5ec453e274d 100644
--- a/llvm/lib/Target/AArch64/AArch64ISelLowering.h
+++ b/llvm/lib/Target/AArch64/AArch64ISelLowering.h
@@ -241,6 +241,10 @@ enum NodeType : unsigned {
   SST1_SXTW_SCALED,
   SST1_IMM,
 
+  // Strict (exception-raising) floating point comparison
+  STRICT_FCMP = ISD::FIRST_TARGET_STRICTFP_OPCODE,
+  STRICT_FCMPE,
+
   // NEON Load/Store with post-increment base updates
   LD2post = ISD::FIRST_TARGET_MEMORY_OPCODE,
   LD3post,
diff --git a/llvm/lib/Target/AArch64/AArch64InstrInfo.td b/llvm/lib/Target/AArch64/AArch64InstrInfo.td
index d590d4d913f..1cb23a51713 100644
--- a/llvm/lib/Target/AArch64/AArch64InstrInfo.td
+++ b/llvm/lib/Target/AArch64/AArch64InstrInfo.td
@@ -419,7 +419,14 @@ def AArch64fccmp     : SDNode<"AArch64ISD::FCCMP", SDT_AArch64FCCMP>;
 
 def AArch64threadpointer : SDNode<"AArch64ISD::THREAD_POINTER", SDTPtrLeaf>;
 
-def AArch64fcmp      : SDNode<"AArch64ISD::FCMP", SDT_AArch64FCmp>;
+def AArch64fcmp         : SDNode<"AArch64ISD::FCMP", SDT_AArch64FCmp>;
+def AArch64strict_fcmp  : SDNode<"AArch64ISD::STRICT_FCMP", SDT_AArch64FCmp,
+                                 [SDNPHasChain]>;
+def AArch64strict_fcmpe : SDNode<"AArch64ISD::STRICT_FCMPE", SDT_AArch64FCmp,
+                                 [SDNPHasChain]>;
+def AArch64any_fcmp     : PatFrags<(ops node:$lhs, node:$rhs),
+                                   [(AArch64strict_fcmp node:$lhs, node:$rhs),
+                                    (AArch64fcmp node:$lhs, node:$rhs)]>;
 
 def AArch64dup       : SDNode<"AArch64ISD::DUP", SDT_AArch64Dup>;
 def AArch64duplane8  : SDNode<"AArch64ISD::DUPLANE8", SDT_AArch64DupLane>;
@@ -3541,8 +3548,8 @@ def : Pat<(f64 (fma FPR64:$Rn, (fneg FPR64:$Rm), (fneg FPR64:$Ra))),
 // Floating point comparison instructions.
 //===----------------------------------------------------------------------===//
 
-defm FCMPE : FPComparison<1, "fcmpe">;
-defm FCMP  : FPComparison<0, "fcmp", AArch64fcmp>;
+defm FCMPE : FPComparison<1, "fcmpe", AArch64strict_fcmpe>;
+defm FCMP  : FPComparison<0, "fcmp", AArch64any_fcmp>;
 
 //===----------------------------------------------------------------------===//
 // Floating point conditional comparison instructions.
diff --git a/llvm/test/CodeGen/AArch64/fp-intrinsics.ll b/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
new file mode 100644
index 00000000000..93a3c716c20
--- /dev/null
+++ b/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
@@ -0,0 +1,974 @@
+; RUN: llc -mtriple=aarch64-none-eabi %s -o - | FileCheck %s
+
+; Check that constrained fp intrinsics are correctly lowered.
+
+; FIXME: We're not generating the right instructions for some of these
+; operations (see further FIXMEs down below).
+
+; Single-precision intrinsics
+
+; CHECK-LABEL: add_f32:
+; CHECK: fadd s0, s0, s1
+define float @add_f32(float %x, float %y) #0 {
+  %val = call float @llvm.experimental.constrained.fadd.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: sub_f32:
+; CHECK: fsub s0, s0, s1
+define float @sub_f32(float %x, float %y) #0 {
+  %val = call float @llvm.experimental.constrained.fsub.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: mul_f32:
+; CHECK: fmul s0, s0, s1
+define float @mul_f32(float %x, float %y) #0 {
+  %val = call float @llvm.experimental.constrained.fmul.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: div_f32:
+; CHECK: fdiv s0, s0, s1
+define float @div_f32(float %x, float %y) #0 {
+  %val = call float @llvm.experimental.constrained.fdiv.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: frem_f32:
+; CHECK: bl fmodf
+define float @frem_f32(float %x, float %y) #0 {
+  %val = call float @llvm.experimental.constrained.frem.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: fma_f32:
+; CHECK: fmadd s0, s0, s1, s2
+define float @fma_f32(float %x, float %y, float %z) #0 {
+  %val = call float @llvm.experimental.constrained.fma.f32(float %x, float %y, float %z, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: fptosi_i32_f32:
+; CHECK: fcvtzs w0, s0
+define i32 @fptosi_i32_f32(float %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.fptosi.i32.f32(float %x, metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: fptoui_i32_f32:
+; FIXME-CHECK: fcvtzu w0, s0
+define i32 @fptoui_i32_f32(float %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.fptoui.i32.f32(float %x, metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: fptosi_i64_f32:
+; CHECK: fcvtzs x0, s0
+define i64 @fptosi_i64_f32(float %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.fptosi.i64.f32(float %x, metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: fptoui_i64_f32:
+; FIXME-CHECK: fcvtzu x0, s0
+define i64 @fptoui_i64_f32(float %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.fptoui.i64.f32(float %x, metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; TODO: sitofp_f32_i32 (missing STRICT_FP_ROUND handling)
+
+; TODO: uitofp_f32_i32 (missing STRICT_FP_ROUND handling)
+
+; TODO: sitofp_f32_i64 (missing STRICT_SINT_TO_FP handling)
+
+; TODO: uitofp_f32_i64 (missing STRICT_SINT_TO_FP handling)
+
+; CHECK-LABEL: sqrt_f32:
+; CHECK: fsqrt s0, s0
+define float @sqrt_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.sqrt.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: powi_f32:
+; CHECK: bl __powisf2
+define float @powi_f32(float %x, i32 %y) #0 {
+  %val = call float @llvm.experimental.constrained.powi.f32(float %x, i32 %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: sin_f32:
+; CHECK: bl sinf
+define float @sin_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.sin.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: cos_f32:
+; CHECK: bl cosf
+define float @cos_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.cos.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: pow_f32:
+; CHECK: bl powf
+define float @pow_f32(float %x, float %y) #0 {
+  %val = call float @llvm.experimental.constrained.pow.f32(float %x, float %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: log_f32:
+; CHECK: bl logf
+define float @log_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.log.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: log10_f32:
+; CHECK: bl log10f
+define float @log10_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.log10.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: log2_f32:
+; CHECK: bl log2f
+define float @log2_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.log2.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: exp_f32:
+; CHECK: bl expf
+define float @exp_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.exp.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: exp2_f32:
+; CHECK: bl exp2f
+define float @exp2_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.exp2.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: rint_f32:
+; CHECK: frintx s0, s0
+define float @rint_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.rint.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: nearbyint_f32:
+; CHECK: frinti s0, s0
+define float @nearbyint_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.nearbyint.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: lrint_f32:
+; CHECK: frintx [[REG:s[0-9]+]], s0
+; CHECK: fcvtzs w0, [[REG]]
+define i32 @lrint_f32(float %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.lrint.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: llrint_f32:
+; CHECK: frintx [[REG:s[0-9]+]], s0
+; CHECK: fcvtzs x0, [[REG]]
+define i64 @llrint_f32(float %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.llrint.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: maxnum_f32:
+; CHECK: fmaxnm s0, s0, s1
+define float @maxnum_f32(float %x, float %y) #0 {
+  %val = call float @llvm.experimental.constrained.maxnum.f32(float %x, float %y, metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: minnum_f32:
+; CHECK: fminnm s0, s0, s1
+define float @minnum_f32(float %x, float %y) #0 {
+  %val = call float @llvm.experimental.constrained.minnum.f32(float %x, float %y, metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: ceil_f32:
+; CHECK: frintp s0, s0
+define float @ceil_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.ceil.f32(float %x, metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: floor_f32:
+; CHECK: frintm s0, s0
+define float @floor_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.floor.f32(float %x, metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: lround_f32:
+; CHECK: fcvtas w0, s0
+define i32 @lround_f32(float %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.lround.f32(float %x, metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: llround_f32:
+; CHECK: fcvtas x0, s0
+define i64 @llround_f32(float %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.llround.f32(float %x, metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: round_f32:
+; CHECK: frinta s0, s0
+define float @round_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.round.f32(float %x, metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: trunc_f32:
+; CHECK: frintz s0, s0
+define float @trunc_f32(float %x) #0 {
+  %val = call float @llvm.experimental.constrained.trunc.f32(float %x, metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: fcmp_olt_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_olt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"olt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ole_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_ole_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ole", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ogt_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_ogt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ogt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_oge_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_oge_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"oge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_oeq_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_oeq_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"oeq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_one_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_one_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"one", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ult_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_ult_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ult", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ule_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_ule_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ule", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ugt_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_ugt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ugt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_uge_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_uge_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"uge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ueq_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_ueq_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ueq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_une_f32:
+; CHECK: fcmp s0, s1
+define i32 @fcmp_une_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"une", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_olt_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_olt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"olt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ole_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_ole_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ole", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ogt_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_ogt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ogt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_oge_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_oge_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"oge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_oeq_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_oeq_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"oeq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_one_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_one_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"one", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ult_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_ult_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ult", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ule_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_ule_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ule", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ugt_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_ugt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ugt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_uge_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_uge_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"uge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ueq_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_ueq_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ueq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_une_f32:
+; CHECK: fcmpe s0, s1
+define i32 @fcmps_une_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"une", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+
+; Double-precision intrinsics
+
+; CHECK-LABEL: add_f64:
+; CHECK: fadd d0, d0, d1
+define double @add_f64(double %x, double %y) #0 {
+  %val = call double @llvm.experimental.constrained.fadd.f64(double %x, double %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: sub_f64:
+; CHECK: fsub d0, d0, d1
+define double @sub_f64(double %x, double %y) #0 {
+  %val = call double @llvm.experimental.constrained.fsub.f64(double %x, double %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: mul_f64:
+; CHECK: fmul d0, d0, d1
+define double @mul_f64(double %x, double %y) #0 {
+  %val = call double @llvm.experimental.constrained.fmul.f64(double %x, double %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: div_f64:
+; CHECK: fdiv d0, d0, d1
+define double @div_f64(double %x, double %y) #0 {
+  %val = call double @llvm.experimental.constrained.fdiv.f64(double %x, double %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: frem_f64:
+; CHECK: bl fmod
+define double @frem_f64(double %x, double %y) #0 {
+  %val = call double @llvm.experimental.constrained.frem.f64(double %x, double %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: fma_f64:
+; CHECK: fmadd d0, d0, d1, d2
+define double @fma_f64(double %x, double %y, double %z) #0 {
+  %val = call double @llvm.experimental.constrained.fma.f64(double %x, double %y, double %z, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: fptosi_i32_f64:
+; CHECK: fcvtzs w0, d0
+define i32 @fptosi_i32_f64(double %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.fptosi.i32.f64(double %x, metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: fptoui_i32_f64:
+; FIXME-CHECK: fcvtzu w0, d0
+define i32 @fptoui_i32_f64(double %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.fptoui.i32.f64(double %x, metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: fptosi_i64_f64:
+; CHECK: fcvtzs x0, d0
+define i64 @fptosi_i64_f64(double %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.fptosi.i64.f64(double %x, metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: fptoui_i64_f64:
+; FIXME-CHECK: fcvtzu x0, d0
+define i64 @fptoui_i64_f64(double %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.fptoui.i64.f64(double %x, metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: sitofp_f64_i32:
+; FIXME-CHECK: scvtf d0, w0
+define double @sitofp_f64_i32(i32 %x) #0 {
+  %val = call double @llvm.experimental.constrained.sitofp.f64.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: uitofp_f64_i32:
+; FIXME-CHECK: ucvtf d0, w0
+define double @uitofp_f64_i32(i32 %x) #0 {
+  %val = call double @llvm.experimental.constrained.uitofp.f64.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; TODO sitofp_f64_i64 (missing STRICT_SINT_TO_FP handling)
+
+; CHECK-LABEL: uitofp_f64_i64:
+; FIXME-CHECK: ucvtf d0, x0
+define double @uitofp_f64_i64(i64 %x) #0 {
+  %val = call double @llvm.experimental.constrained.uitofp.f64.i64(i64 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: sqrt_f64:
+; CHECK: fsqrt d0, d0
+define double @sqrt_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.sqrt.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: powi_f64:
+; CHECK: bl __powidf2
+define double @powi_f64(double %x, i32 %y) #0 {
+  %val = call double @llvm.experimental.constrained.powi.f64(double %x, i32 %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: sin_f64:
+; CHECK: bl sin
+define double @sin_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.sin.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: cos_f64:
+; CHECK: bl cos
+define double @cos_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.cos.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: pow_f64:
+; CHECK: bl pow
+define double @pow_f64(double %x, double %y) #0 {
+  %val = call double @llvm.experimental.constrained.pow.f64(double %x, double %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: log_f64:
+; CHECK: bl log
+define double @log_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.log.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: log10_f64:
+; CHECK: bl log10
+define double @log10_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.log10.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: log2_f64:
+; CHECK: bl log2
+define double @log2_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.log2.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: exp_f64:
+; CHECK: bl exp
+define double @exp_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.exp.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: exp2_f64:
+; CHECK: bl exp2
+define double @exp2_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.exp2.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: rint_f64:
+; CHECK: frintx d0, d0
+define double @rint_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.rint.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: nearbyint_f64:
+; CHECK: frinti d0, d0
+define double @nearbyint_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.nearbyint.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: lrint_f64:
+; CHECK: frintx [[REG:d[0-9]+]], d0
+; CHECK: fcvtzs w0, [[REG]]
+define i32 @lrint_f64(double %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.lrint.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: llrint_f64:
+; CHECK: frintx [[REG:d[0-9]+]], d0
+; CHECK: fcvtzs x0, [[REG]]
+define i64 @llrint_f64(double %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.llrint.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: maxnum_f64:
+; CHECK: fmaxnm d0, d0, d1
+define double @maxnum_f64(double %x, double %y) #0 {
+  %val = call double @llvm.experimental.constrained.maxnum.f64(double %x, double %y, metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: minnum_f64:
+; CHECK: fminnm d0, d0, d1
+define double @minnum_f64(double %x, double %y) #0 {
+  %val = call double @llvm.experimental.constrained.minnum.f64(double %x, double %y, metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: ceil_f64:
+; CHECK: frintp d0, d0
+define double @ceil_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.ceil.f64(double %x, metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: floor_f64:
+; CHECK: frintm d0, d0
+define double @floor_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.floor.f64(double %x, metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: lround_f64:
+; CHECK: fcvtas w0, d0
+define i32 @lround_f64(double %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.lround.f64(double %x, metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: llround_f64:
+; CHECK: fcvtas x0, d0
+define i64 @llround_f64(double %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.llround.f64(double %x, metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: round_f64:
+; CHECK: frinta d0, d0
+define double @round_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.round.f64(double %x, metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: trunc_f64:
+; CHECK: frintz d0, d0
+define double @trunc_f64(double %x) #0 {
+  %val = call double @llvm.experimental.constrained.trunc.f64(double %x, metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: fcmp_olt_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_olt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"olt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ole_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_ole_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ole", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ogt_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_ogt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ogt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_oge_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_oge_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"oge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_oeq_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_oeq_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"oeq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_one_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_one_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"one", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ult_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_ult_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ult", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ule_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_ule_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ule", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ugt_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_ugt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ugt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_uge_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_uge_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"uge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ueq_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_ueq_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ueq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_une_f64:
+; CHECK: fcmp d0, d1
+define i32 @fcmp_une_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"une", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_olt_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_olt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"olt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ole_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_ole_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ole", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ogt_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_ogt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ogt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_oge_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_oge_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"oge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_oeq_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_oeq_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"oeq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_one_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_one_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"one", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ult_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_ult_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ult", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ule_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_ule_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ule", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ugt_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_ugt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ugt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_uge_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_uge_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"uge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ueq_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_ueq_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ueq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_une_f64:
+; CHECK: fcmpe d0, d1
+define i32 @fcmps_une_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"une", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+
+; Single/Double conversion intrinsics
+
+; TODO: fptrunc_f32 (missing STRICT_FP_ROUND handling)
+
+; CHECK-LABEL: fpext_f32:
+; CHECK: fcvt d0, s0
+define double @fpext_f32(float %x) #0 {
+  %val = call double @llvm.experimental.constrained.fpext.f64.f32(float %x, metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+
+attributes #0 = { strictfp }
+
+declare float @llvm.experimental.constrained.fadd.f32(float, float, metadata, metadata)
+declare float @llvm.experimental.constrained.fsub.f32(float, float, metadata, metadata)
+declare float @llvm.experimental.constrained.fmul.f32(float, float, metadata, metadata)
+declare float @llvm.experimental.constrained.fdiv.f32(float, float, metadata, metadata)
+declare float @llvm.experimental.constrained.frem.f32(float, float, metadata, metadata)
+declare float @llvm.experimental.constrained.fma.f32(float, float, float, metadata, metadata)
+declare i32 @llvm.experimental.constrained.fptosi.i32.f32(float, metadata)
+declare i32 @llvm.experimental.constrained.fptoui.i32.f32(float, metadata)
+declare i64 @llvm.experimental.constrained.fptosi.i64.f32(float, metadata)
+declare i64 @llvm.experimental.constrained.fptoui.i64.f32(float, metadata)
+declare float @llvm.experimental.constrained.sitofp.f32.i32(i32, metadata, metadata)
+declare float @llvm.experimental.constrained.uitofp.f32.i32(i32, metadata, metadata)
+declare float @llvm.experimental.constrained.sitofp.f32.i64(i64, metadata, metadata)
+declare float @llvm.experimental.constrained.uitofp.f32.i64(i64, metadata, metadata)
+declare float @llvm.experimental.constrained.sqrt.f32(float, metadata, metadata)
+declare float @llvm.experimental.constrained.powi.f32(float, i32, metadata, metadata)
+declare float @llvm.experimental.constrained.sin.f32(float, metadata, metadata)
+declare float @llvm.experimental.constrained.cos.f32(float, metadata, metadata)
+declare float @llvm.experimental.constrained.pow.f32(float, float, metadata, metadata)
+declare float @llvm.experimental.constrained.log.f32(float, metadata, metadata)
+declare float @llvm.experimental.constrained.log10.f32(float, metadata, metadata)
+declare float @llvm.experimental.constrained.log2.f32(float, metadata, metadata)
+declare float @llvm.experimental.constrained.exp.f32(float, metadata, metadata)
+declare float @llvm.experimental.constrained.exp2.f32(float, metadata, metadata)
+declare float @llvm.experimental.constrained.rint.f32(float, metadata, metadata)
+declare float @llvm.experimental.constrained.nearbyint.f32(float, metadata, metadata)
+declare i32 @llvm.experimental.constrained.lrint.f32(float, metadata, metadata)
+declare i64 @llvm.experimental.constrained.llrint.f32(float, metadata, metadata)
+declare float @llvm.experimental.constrained.maxnum.f32(float, float, metadata)
+declare float @llvm.experimental.constrained.minnum.f32(float, float, metadata)
+declare float @llvm.experimental.constrained.ceil.f32(float, metadata)
+declare float @llvm.experimental.constrained.floor.f32(float, metadata)
+declare i32 @llvm.experimental.constrained.lround.f32(float, metadata)
+declare i64 @llvm.experimental.constrained.llround.f32(float, metadata)
+declare float @llvm.experimental.constrained.round.f32(float, metadata)
+declare float @llvm.experimental.constrained.trunc.f32(float, metadata)
+declare i1 @llvm.experimental.constrained.fcmps.f32(float, float, metadata, metadata)
+declare i1 @llvm.experimental.constrained.fcmp.f32(float, float, metadata, metadata)
+
+declare double @llvm.experimental.constrained.fadd.f64(double, double, metadata, metadata)
+declare double @llvm.experimental.constrained.fsub.f64(double, double, metadata, metadata)
+declare double @llvm.experimental.constrained.fmul.f64(double, double, metadata, metadata)
+declare double @llvm.experimental.constrained.fdiv.f64(double, double, metadata, metadata)
+declare double @llvm.experimental.constrained.frem.f64(double, double, metadata, metadata)
+declare double @llvm.experimental.constrained.fma.f64(double, double, double, metadata, metadata)
+declare i32 @llvm.experimental.constrained.fptosi.i32.f64(double, metadata)
+declare i32 @llvm.experimental.constrained.fptoui.i32.f64(double, metadata)
+declare i64 @llvm.experimental.constrained.fptosi.i64.f64(double, metadata)
+declare i64 @llvm.experimental.constrained.fptoui.i64.f64(double, metadata)
+declare double @llvm.experimental.constrained.sitofp.f64.i32(i32, metadata, metadata)
+declare double @llvm.experimental.constrained.uitofp.f64.i32(i32, metadata, metadata)
+declare double @llvm.experimental.constrained.sitofp.f64.i64(i64, metadata, metadata)
+declare double @llvm.experimental.constrained.uitofp.f64.i64(i64, metadata, metadata)
+declare double @llvm.experimental.constrained.sqrt.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.powi.f64(double, i32, metadata, metadata)
+declare double @llvm.experimental.constrained.sin.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.cos.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.pow.f64(double, double, metadata, metadata)
+declare double @llvm.experimental.constrained.log.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.log10.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.log2.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.exp.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.exp2.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.rint.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.nearbyint.f64(double, metadata, metadata)
+declare i32 @llvm.experimental.constrained.lrint.f64(double, metadata, metadata)
+declare i64 @llvm.experimental.constrained.llrint.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.maxnum.f64(double, double, metadata)
+declare double @llvm.experimental.constrained.minnum.f64(double, double, metadata)
+declare double @llvm.experimental.constrained.ceil.f64(double, metadata)
+declare double @llvm.experimental.constrained.floor.f64(double, metadata)
+declare i32 @llvm.experimental.constrained.lround.f64(double, metadata)
+declare i64 @llvm.experimental.constrained.llround.f64(double, metadata)
+declare double @llvm.experimental.constrained.round.f64(double, metadata)
+declare double @llvm.experimental.constrained.trunc.f64(double, metadata)
+declare i1 @llvm.experimental.constrained.fcmps.f64(double, double, metadata, metadata)
+declare i1 @llvm.experimental.constrained.fcmp.f64(double, double, metadata, metadata)
+
+declare float @llvm.experimental.constrained.fptrunc.f32.f64(double, metadata, metadata)
+declare double @llvm.experimental.constrained.fpext.f64.f32(float, metadata)

commit a97c77ad17502cc634473dc5ad433905f5d80b2f
Author: John Brawn <john.brawn@arm.com>
Date:   Tue Jan 21 17:18:18 2020 +0000

    [FPEnv][AArch64] Add lowering and instruction selection for STRICT_FP_ROUND
    
    This gets selected to the appropriate fcvt instruction. Handling from there on
    isn't fully correct yet, as we need to model fcvt reading and writing to fpsr
    and fpcr.
    
    Differential Revision: https://reviews.llvm.org/D73201
    
    (cherry picked from commit 258d8dd76afd88a12539b182a53ff21dcba16a2d)

diff --git a/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp b/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
index e579159daed..5eae60d1979 100644
--- a/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
+++ b/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
@@ -293,6 +293,8 @@ AArch64TargetLowering::AArch64TargetLowering(const TargetMachine &TM,
   setOperationAction(ISD::UINT_TO_FP, MVT::i128, Custom);
   setOperationAction(ISD::FP_ROUND, MVT::f32, Custom);
   setOperationAction(ISD::FP_ROUND, MVT::f64, Custom);
+  setOperationAction(ISD::STRICT_FP_ROUND, MVT::f32, Custom);
+  setOperationAction(ISD::STRICT_FP_ROUND, MVT::f64, Custom);
 
   // Variable arguments.
   setOperationAction(ISD::VASTART, MVT::Other, Custom);
@@ -2502,21 +2504,26 @@ SDValue AArch64TargetLowering::LowerFP_EXTEND(SDValue Op,
 
 SDValue AArch64TargetLowering::LowerFP_ROUND(SDValue Op,
                                              SelectionDAG &DAG) const {
-  if (Op.getOperand(0).getValueType() != MVT::f128) {
+  bool IsStrict = Op->isStrictFPOpcode();
+  SDValue SrcVal = Op.getOperand(IsStrict ? 1 : 0);
+  if (SrcVal.getValueType() != MVT::f128) {
     // It's legal except when f128 is involved
     return Op;
   }
 
   RTLIB::Libcall LC;
-  LC = RTLIB::getFPROUND(Op.getOperand(0).getValueType(), Op.getValueType());
+  LC = RTLIB::getFPROUND(SrcVal.getValueType(), Op.getValueType());
 
   // FP_ROUND node has a second operand indicating whether it is known to be
   // precise. That doesn't take part in the LibCall so we can't directly use
   // LowerF128Call.
-  SDValue SrcVal = Op.getOperand(0);
   MakeLibCallOptions CallOptions;
-  return makeLibCall(DAG, LC, Op.getValueType(), SrcVal, CallOptions,
-                     SDLoc(Op)).first;
+  SDValue Chain = IsStrict ? Op.getOperand(0) : SDValue();
+  SDValue Result;
+  SDLoc dl(Op);
+  std::tie(Result, Chain) = makeLibCall(DAG, LC, Op.getValueType(), SrcVal,
+                                        CallOptions, dl, Chain);
+  return IsStrict ? DAG.getMergeValues({Result, Chain}, dl) : Result;
 }
 
 SDValue AArch64TargetLowering::LowerVectorFP_TO_INT(SDValue Op,
@@ -3167,6 +3174,7 @@ SDValue AArch64TargetLowering::LowerOperation(SDValue Op,
   case ISD::FDIV:
     return LowerF128Call(Op, DAG, RTLIB::DIV_F128);
   case ISD::FP_ROUND:
+  case ISD::STRICT_FP_ROUND:
     return LowerFP_ROUND(Op, DAG);
   case ISD::FP_EXTEND:
     return LowerFP_EXTEND(Op, DAG);
diff --git a/llvm/lib/Target/AArch64/AArch64InstrFormats.td b/llvm/lib/Target/AArch64/AArch64InstrFormats.td
index c3efe03a098..11ba6987884 100644
--- a/llvm/lib/Target/AArch64/AArch64InstrFormats.td
+++ b/llvm/lib/Target/AArch64/AArch64InstrFormats.td
@@ -4702,11 +4702,11 @@ class BaseFPConversion<bits<2> type, bits<2> opcode, RegisterClass dstType,
 multiclass FPConversion<string asm> {
   // Double-precision to Half-precision
   def HDr : BaseFPConversion<0b01, 0b11, FPR16, FPR64, asm,
-                             [(set FPR16:$Rd, (fpround FPR64:$Rn))]>;
+                             [(set FPR16:$Rd, (any_fpround FPR64:$Rn))]>;
 
   // Double-precision to Single-precision
   def SDr : BaseFPConversion<0b01, 0b00, FPR32, FPR64, asm,
-                             [(set FPR32:$Rd, (fpround FPR64:$Rn))]>;
+                             [(set FPR32:$Rd, (any_fpround FPR64:$Rn))]>;
 
   // Half-precision to Double-precision
   def DHr : BaseFPConversion<0b11, 0b01, FPR64, FPR16, asm,
@@ -4722,7 +4722,7 @@ multiclass FPConversion<string asm> {
 
   // Single-precision to Half-precision
   def HSr : BaseFPConversion<0b00, 0b11, FPR16, FPR32, asm,
-                             [(set FPR16:$Rd, (fpround FPR32:$Rn))]>;
+                             [(set FPR16:$Rd, (any_fpround FPR32:$Rn))]>;
 }
 
 //---
diff --git a/llvm/test/CodeGen/AArch64/fp-intrinsics.ll b/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
index 93a3c716c20..88cb78841c1 100644
--- a/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
+++ b/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
@@ -77,9 +77,19 @@ define i64 @fptoui_i64_f32(float %x) #0 {
   ret i64 %val
 }
 
-; TODO: sitofp_f32_i32 (missing STRICT_FP_ROUND handling)
+; CHECK-LABEL: sitofp_f32_i32:
+; FIXME-CHECK: scvtf s0, w0
+define float @sitofp_f32_i32(i32 %x) #0 {
+  %val = call float @llvm.experimental.constrained.sitofp.f32.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
 
-; TODO: uitofp_f32_i32 (missing STRICT_FP_ROUND handling)
+; CHECK-LABEL: uitofp_f32_i32:
+; FIXME-CHECK: ucvtf s0, w0
+define float @uitofp_f32_i32(i32 %x) #0 {
+  %val = call float @llvm.experimental.constrained.uitofp.f32.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
 
 ; TODO: sitofp_f32_i64 (missing STRICT_SINT_TO_FP handling)
 
@@ -880,7 +890,12 @@ define i32 @fcmps_une_f64(double %a, double %b) #0 {
 
 ; Single/Double conversion intrinsics
 
-; TODO: fptrunc_f32 (missing STRICT_FP_ROUND handling)
+; CHECK-LABEL: fptrunc_f32:
+; CHECK: fcvt s0, d0
+define float @fptrunc_f32(double %x) #0 {
+  %val = call float @llvm.experimental.constrained.fptrunc.f32.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
 
 ; CHECK-LABEL: fpext_f32:
 ; CHECK: fcvt d0, s0

commit fca6c5e5dbf283b9e96b4a6ba8d343ff5dd91328
Author: John Brawn <john.brawn@arm.com>
Date:   Mon Jan 27 15:51:06 2020 +0000

    [FPEnv][AArch64] Add lowering and instruction selection for strict conversions
    
    Strict fp-to-int and int-to-fp conversions can be handled in the same way that
    the non-strict versions are (by using the appropriate instruction or converting
    to a function call when we have no instruction).
    
    Differential Revision: https://reviews.llvm.org/D73625
    
    (cherry picked from commit 0bb9a27c9895c0fbc3f55f56ad7f1e1927398fce)

diff --git a/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp b/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
index 5eae60d1979..94b6d1ac763 100644
--- a/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
+++ b/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
@@ -282,15 +282,27 @@ AArch64TargetLowering::AArch64TargetLowering(const TargetMachine &TM,
   setOperationAction(ISD::FP_TO_SINT, MVT::i32, Custom);
   setOperationAction(ISD::FP_TO_SINT, MVT::i64, Custom);
   setOperationAction(ISD::FP_TO_SINT, MVT::i128, Custom);
+  setOperationAction(ISD::STRICT_FP_TO_SINT, MVT::i32, Custom);
+  setOperationAction(ISD::STRICT_FP_TO_SINT, MVT::i64, Custom);
+  setOperationAction(ISD::STRICT_FP_TO_SINT, MVT::i128, Custom);
   setOperationAction(ISD::FP_TO_UINT, MVT::i32, Custom);
   setOperationAction(ISD::FP_TO_UINT, MVT::i64, Custom);
   setOperationAction(ISD::FP_TO_UINT, MVT::i128, Custom);
+  setOperationAction(ISD::STRICT_FP_TO_UINT, MVT::i32, Custom);
+  setOperationAction(ISD::STRICT_FP_TO_UINT, MVT::i64, Custom);
+  setOperationAction(ISD::STRICT_FP_TO_UINT, MVT::i128, Custom);
   setOperationAction(ISD::SINT_TO_FP, MVT::i32, Custom);
   setOperationAction(ISD::SINT_TO_FP, MVT::i64, Custom);
   setOperationAction(ISD::SINT_TO_FP, MVT::i128, Custom);
+  setOperationAction(ISD::STRICT_SINT_TO_FP, MVT::i32, Custom);
+  setOperationAction(ISD::STRICT_SINT_TO_FP, MVT::i64, Custom);
+  setOperationAction(ISD::STRICT_SINT_TO_FP, MVT::i128, Custom);
   setOperationAction(ISD::UINT_TO_FP, MVT::i32, Custom);
   setOperationAction(ISD::UINT_TO_FP, MVT::i64, Custom);
   setOperationAction(ISD::UINT_TO_FP, MVT::i128, Custom);
+  setOperationAction(ISD::STRICT_UINT_TO_FP, MVT::i32, Custom);
+  setOperationAction(ISD::STRICT_UINT_TO_FP, MVT::i64, Custom);
+  setOperationAction(ISD::STRICT_UINT_TO_FP, MVT::i128, Custom);
   setOperationAction(ISD::FP_ROUND, MVT::f32, Custom);
   setOperationAction(ISD::FP_ROUND, MVT::f64, Custom);
   setOperationAction(ISD::STRICT_FP_ROUND, MVT::f32, Custom);
@@ -2305,9 +2317,16 @@ getAArch64XALUOOp(AArch64CC::CondCode &CC, SDValue Op, SelectionDAG &DAG) {
 
 SDValue AArch64TargetLowering::LowerF128Call(SDValue Op, SelectionDAG &DAG,
                                              RTLIB::Libcall Call) const {
-  SmallVector<SDValue, 2> Ops(Op->op_begin(), Op->op_end());
+  bool IsStrict = Op->isStrictFPOpcode();
+  unsigned Offset = IsStrict ? 1 : 0;
+  SDValue Chain = IsStrict ? Op.getOperand(0) : SDValue();
+  SmallVector<SDValue, 2> Ops(Op->op_begin() + Offset, Op->op_end());
   MakeLibCallOptions CallOptions;
-  return makeLibCall(DAG, Call, MVT::f128, Ops, CallOptions, SDLoc(Op)).first;
+  SDValue Result;
+  SDLoc dl(Op);
+  std::tie(Result, Chain) = makeLibCall(DAG, Call, Op.getValueType(), Ops,
+                                        CallOptions, dl, Chain);
+  return IsStrict ? DAG.getMergeValues({Result, Chain}, dl) : Result;
 }
 
 // Returns true if the given Op is the overflow flag result of an overflow
@@ -2568,32 +2587,34 @@ SDValue AArch64TargetLowering::LowerVectorFP_TO_INT(SDValue Op,
 
 SDValue AArch64TargetLowering::LowerFP_TO_INT(SDValue Op,
                                               SelectionDAG &DAG) const {
-  if (Op.getOperand(0).getValueType().isVector())
+  bool IsStrict = Op->isStrictFPOpcode();
+  SDValue SrcVal = Op.getOperand(IsStrict ? 1 : 0);
+
+  if (SrcVal.getValueType().isVector())
     return LowerVectorFP_TO_INT(Op, DAG);
 
   // f16 conversions are promoted to f32 when full fp16 is not supported.
-  if (Op.getOperand(0).getValueType() == MVT::f16 &&
-      !Subtarget->hasFullFP16()) {
+  if (SrcVal.getValueType() == MVT::f16 && !Subtarget->hasFullFP16()) {
+    assert(!IsStrict && "Lowering of strict fp16 not yet implemented");
     SDLoc dl(Op);
     return DAG.getNode(
         Op.getOpcode(), dl, Op.getValueType(),
-        DAG.getNode(ISD::FP_EXTEND, dl, MVT::f32, Op.getOperand(0)));
+        DAG.getNode(ISD::FP_EXTEND, dl, MVT::f32, SrcVal));
   }
 
-  if (Op.getOperand(0).getValueType() != MVT::f128) {
+  if (SrcVal.getValueType() != MVT::f128) {
     // It's legal except when f128 is involved
     return Op;
   }
 
   RTLIB::Libcall LC;
-  if (Op.getOpcode() == ISD::FP_TO_SINT)
-    LC = RTLIB::getFPTOSINT(Op.getOperand(0).getValueType(), Op.getValueType());
+  if (Op.getOpcode() == ISD::FP_TO_SINT ||
+      Op.getOpcode() == ISD::STRICT_FP_TO_SINT)
+    LC = RTLIB::getFPTOSINT(SrcVal.getValueType(), Op.getValueType());
   else
-    LC = RTLIB::getFPTOUINT(Op.getOperand(0).getValueType(), Op.getValueType());
+    LC = RTLIB::getFPTOUINT(SrcVal.getValueType(), Op.getValueType());
 
-  SmallVector<SDValue, 2> Ops(Op->op_begin(), Op->op_end());
-  MakeLibCallOptions CallOptions;
-  return makeLibCall(DAG, LC, Op.getValueType(), Ops, CallOptions, SDLoc(Op)).first;
+  return LowerF128Call(Op, DAG, LC);
 }
 
 static SDValue LowerVectorINT_TO_FP(SDValue Op, SelectionDAG &DAG) {
@@ -2629,18 +2650,22 @@ SDValue AArch64TargetLowering::LowerINT_TO_FP(SDValue Op,
   if (Op.getValueType().isVector())
     return LowerVectorINT_TO_FP(Op, DAG);
 
+  bool IsStrict = Op->isStrictFPOpcode();
+  SDValue SrcVal = Op.getOperand(IsStrict ? 1 : 0);
+
   // f16 conversions are promoted to f32 when full fp16 is not supported.
   if (Op.getValueType() == MVT::f16 &&
       !Subtarget->hasFullFP16()) {
+    assert(!IsStrict && "Lowering of strict fp16 not yet implemented");
     SDLoc dl(Op);
     return DAG.getNode(
         ISD::FP_ROUND, dl, MVT::f16,
-        DAG.getNode(Op.getOpcode(), dl, MVT::f32, Op.getOperand(0)),
+        DAG.getNode(Op.getOpcode(), dl, MVT::f32, SrcVal),
         DAG.getIntPtrConstant(0, dl));
   }
 
   // i128 conversions are libcalls.
-  if (Op.getOperand(0).getValueType() == MVT::i128)
+  if (SrcVal.getValueType() == MVT::i128)
     return SDValue();
 
   // Other conversions are legal, unless it's to the completely software-based
@@ -2649,10 +2674,11 @@ SDValue AArch64TargetLowering::LowerINT_TO_FP(SDValue Op,
     return Op;
 
   RTLIB::Libcall LC;
-  if (Op.getOpcode() == ISD::SINT_TO_FP)
-    LC = RTLIB::getSINTTOFP(Op.getOperand(0).getValueType(), Op.getValueType());
+  if (Op.getOpcode() == ISD::SINT_TO_FP ||
+      Op.getOpcode() == ISD::STRICT_SINT_TO_FP)
+    LC = RTLIB::getSINTTOFP(SrcVal.getValueType(), Op.getValueType());
   else
-    LC = RTLIB::getUINTTOFP(Op.getOperand(0).getValueType(), Op.getValueType());
+    LC = RTLIB::getUINTTOFP(SrcVal.getValueType(), Op.getValueType());
 
   return LowerF128Call(Op, DAG, LC);
 }
@@ -3219,9 +3245,13 @@ SDValue AArch64TargetLowering::LowerOperation(SDValue Op,
     return LowerPREFETCH(Op, DAG);
   case ISD::SINT_TO_FP:
   case ISD::UINT_TO_FP:
+  case ISD::STRICT_SINT_TO_FP:
+  case ISD::STRICT_UINT_TO_FP:
     return LowerINT_TO_FP(Op, DAG);
   case ISD::FP_TO_SINT:
   case ISD::FP_TO_UINT:
+  case ISD::STRICT_FP_TO_SINT:
+  case ISD::STRICT_FP_TO_UINT:
     return LowerFP_TO_INT(Op, DAG);
   case ISD::FSINCOS:
     return LowerFSINCOS(Op, DAG);
diff --git a/llvm/lib/Target/AArch64/AArch64InstrInfo.td b/llvm/lib/Target/AArch64/AArch64InstrInfo.td
index 1cb23a51713..1e3bf299b26 100644
--- a/llvm/lib/Target/AArch64/AArch64InstrInfo.td
+++ b/llvm/lib/Target/AArch64/AArch64InstrInfo.td
@@ -3307,10 +3307,10 @@ defm FCVTNS : FPToIntegerUnscaled<0b00, 0b000, "fcvtns", int_aarch64_neon_fcvtns
 defm FCVTNU : FPToIntegerUnscaled<0b00, 0b001, "fcvtnu", int_aarch64_neon_fcvtnu>;
 defm FCVTPS : FPToIntegerUnscaled<0b01, 0b000, "fcvtps", int_aarch64_neon_fcvtps>;
 defm FCVTPU : FPToIntegerUnscaled<0b01, 0b001, "fcvtpu", int_aarch64_neon_fcvtpu>;
-defm FCVTZS : FPToIntegerUnscaled<0b11, 0b000, "fcvtzs", fp_to_sint>;
-defm FCVTZU : FPToIntegerUnscaled<0b11, 0b001, "fcvtzu", fp_to_uint>;
-defm FCVTZS : FPToIntegerScaled<0b11, 0b000, "fcvtzs", fp_to_sint>;
-defm FCVTZU : FPToIntegerScaled<0b11, 0b001, "fcvtzu", fp_to_uint>;
+defm FCVTZS : FPToIntegerUnscaled<0b11, 0b000, "fcvtzs", any_fp_to_sint>;
+defm FCVTZU : FPToIntegerUnscaled<0b11, 0b001, "fcvtzu", any_fp_to_uint>;
+defm FCVTZS : FPToIntegerScaled<0b11, 0b000, "fcvtzs", any_fp_to_sint>;
+defm FCVTZU : FPToIntegerScaled<0b11, 0b001, "fcvtzu", any_fp_to_uint>;
 
 multiclass FPToIntegerIntPats<Intrinsic round, string INST> {
   def : Pat<(i32 (round f16:$Rn)), (!cast<Instruction>(INST # UWHr) $Rn)>;
@@ -3382,8 +3382,8 @@ def : Pat<(i64 (llround f64:$Rn)),
 // Scaled integer to floating point conversion instructions.
 //===----------------------------------------------------------------------===//
 
-defm SCVTF : IntegerToFP<0, "scvtf", sint_to_fp>;
-defm UCVTF : IntegerToFP<1, "ucvtf", uint_to_fp>;
+defm SCVTF : IntegerToFP<0, "scvtf", any_sint_to_fp>;
+defm UCVTF : IntegerToFP<1, "ucvtf", any_uint_to_fp>;
 
 //===----------------------------------------------------------------------===//
 // Unscaled integer to floating point conversion instruction.
diff --git a/llvm/test/CodeGen/AArch64/fp-intrinsics.ll b/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
index 88cb78841c1..d3e17dcf5ff 100644
--- a/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
+++ b/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
@@ -2,8 +2,6 @@
 
 ; Check that constrained fp intrinsics are correctly lowered.
 
-; FIXME: We're not generating the right instructions for some of these
-; operations (see further FIXMEs down below).
 
 ; Single-precision intrinsics
 
@@ -57,7 +55,7 @@ define i32 @fptosi_i32_f32(float %x) #0 {
 }
 
 ; CHECK-LABEL: fptoui_i32_f32:
-; FIXME-CHECK: fcvtzu w0, s0
+; CHECK: fcvtzu w0, s0
 define i32 @fptoui_i32_f32(float %x) #0 {
   %val = call i32 @llvm.experimental.constrained.fptoui.i32.f32(float %x, metadata !"fpexcept.strict") #0
   ret i32 %val
@@ -71,29 +69,53 @@ define i64 @fptosi_i64_f32(float %x) #0 {
 }
 
 ; CHECK-LABEL: fptoui_i64_f32:
-; FIXME-CHECK: fcvtzu x0, s0
+; CHECK: fcvtzu x0, s0
 define i64 @fptoui_i64_f32(float %x) #0 {
   %val = call i64 @llvm.experimental.constrained.fptoui.i64.f32(float %x, metadata !"fpexcept.strict") #0
   ret i64 %val
 }
 
 ; CHECK-LABEL: sitofp_f32_i32:
-; FIXME-CHECK: scvtf s0, w0
+; CHECK: scvtf s0, w0
 define float @sitofp_f32_i32(i32 %x) #0 {
   %val = call float @llvm.experimental.constrained.sitofp.f32.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret float %val
 }
 
 ; CHECK-LABEL: uitofp_f32_i32:
-; FIXME-CHECK: ucvtf s0, w0
+; CHECK: ucvtf s0, w0
 define float @uitofp_f32_i32(i32 %x) #0 {
   %val = call float @llvm.experimental.constrained.uitofp.f32.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret float %val
 }
 
-; TODO: sitofp_f32_i64 (missing STRICT_SINT_TO_FP handling)
+; CHECK-LABEL: sitofp_f32_i64:
+; CHECK: scvtf s0, x0
+define float @sitofp_f32_i64(i64 %x) #0 {
+  %val = call float @llvm.experimental.constrained.sitofp.f32.i64(i64 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: uitofp_f32_i64:
+; CHECK: ucvtf s0, x0
+define float @uitofp_f32_i64(i64 %x) #0 {
+  %val = call float @llvm.experimental.constrained.uitofp.f32.i64(i64 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
 
-; TODO: uitofp_f32_i64 (missing STRICT_SINT_TO_FP handling)
+; CHECK-LABEL: sitofp_f32_i128:
+; CHECK: bl __floattisf
+define float @sitofp_f32_i128(i128 %x) #0 {
+  %val = call float @llvm.experimental.constrained.sitofp.f32.i128(i128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: uitofp_f32_i128:
+; CHECK: bl __floatuntisf
+define float @uitofp_f32_i128(i128 %x) #0 {
+  %val = call float @llvm.experimental.constrained.uitofp.f32.i128(i128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
 
 ; CHECK-LABEL: sqrt_f32:
 ; CHECK: fsqrt s0, s0
@@ -496,7 +518,7 @@ define i32 @fptosi_i32_f64(double %x) #0 {
 }
 
 ; CHECK-LABEL: fptoui_i32_f64:
-; FIXME-CHECK: fcvtzu w0, d0
+; CHECK: fcvtzu w0, d0
 define i32 @fptoui_i32_f64(double %x) #0 {
   %val = call i32 @llvm.experimental.constrained.fptoui.i32.f64(double %x, metadata !"fpexcept.strict") #0
   ret i32 %val
@@ -510,35 +532,54 @@ define i64 @fptosi_i64_f64(double %x) #0 {
 }
 
 ; CHECK-LABEL: fptoui_i64_f64:
-; FIXME-CHECK: fcvtzu x0, d0
+; CHECK: fcvtzu x0, d0
 define i64 @fptoui_i64_f64(double %x) #0 {
   %val = call i64 @llvm.experimental.constrained.fptoui.i64.f64(double %x, metadata !"fpexcept.strict") #0
   ret i64 %val
 }
 
 ; CHECK-LABEL: sitofp_f64_i32:
-; FIXME-CHECK: scvtf d0, w0
+; CHECK: scvtf d0, w0
 define double @sitofp_f64_i32(i32 %x) #0 {
   %val = call double @llvm.experimental.constrained.sitofp.f64.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret double %val
 }
 
 ; CHECK-LABEL: uitofp_f64_i32:
-; FIXME-CHECK: ucvtf d0, w0
+; CHECK: ucvtf d0, w0
 define double @uitofp_f64_i32(i32 %x) #0 {
   %val = call double @llvm.experimental.constrained.uitofp.f64.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret double %val
 }
 
-; TODO sitofp_f64_i64 (missing STRICT_SINT_TO_FP handling)
+; CHECK-LABEL: sitofp_f64_i64:
+; CHECK: scvtf d0, x0
+define double @sitofp_f64_i64(i64 %x) #0 {
+  %val = call double @llvm.experimental.constrained.sitofp.f64.i64(i64 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
 
 ; CHECK-LABEL: uitofp_f64_i64:
-; FIXME-CHECK: ucvtf d0, x0
+; CHECK: ucvtf d0, x0
 define double @uitofp_f64_i64(i64 %x) #0 {
   %val = call double @llvm.experimental.constrained.uitofp.f64.i64(i64 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret double %val
 }
 
+; CHECK-LABEL: sitofp_f64_i128:
+; CHECK: bl __floattidf
+define double @sitofp_f64_i128(i128 %x) #0 {
+  %val = call double @llvm.experimental.constrained.sitofp.f64.i128(i128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: uitofp_f64_i128:
+; CHECK: bl __floatuntidf
+define double @uitofp_f64_i128(i128 %x) #0 {
+  %val = call double @llvm.experimental.constrained.uitofp.f64.i128(i128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
 ; CHECK-LABEL: sqrt_f64:
 ; CHECK: fsqrt d0, d0
 define double @sqrt_f64(double %x) #0 {
@@ -888,22 +929,321 @@ define i32 @fcmps_une_f64(double %a, double %b) #0 {
 }
 
 
-; Single/Double conversion intrinsics
+; Long-double-precision intrinsics
+
+; CHECK-LABEL: add_f128:
+; CHECK: bl __addtf3
+define fp128 @add_f128(fp128 %x, fp128 %y) #0 {
+  %val = call fp128 @llvm.experimental.constrained.fadd.f128(fp128 %x, fp128 %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: sub_f128:
+; CHECK: bl __subtf3
+define fp128 @sub_f128(fp128 %x, fp128 %y) #0 {
+  %val = call fp128 @llvm.experimental.constrained.fsub.f128(fp128 %x, fp128 %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: mul_f128:
+; CHECK: bl __multf3
+define fp128 @mul_f128(fp128 %x, fp128 %y) #0 {
+  %val = call fp128 @llvm.experimental.constrained.fmul.f128(fp128 %x, fp128 %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: div_f128:
+; CHECK: bl __divtf3
+define fp128 @div_f128(fp128 %x, fp128 %y) #0 {
+  %val = call fp128 @llvm.experimental.constrained.fdiv.f128(fp128 %x, fp128 %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: frem_f128:
+; CHECK: bl fmodl
+define fp128 @frem_f128(fp128 %x, fp128 %y) #0 {
+  %val = call fp128 @llvm.experimental.constrained.frem.f128(fp128 %x, fp128 %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: fma_f128:
+; CHECK: fmal
+define fp128 @fma_f128(fp128 %x, fp128 %y, fp128 %z) #0 {
+  %val = call fp128 @llvm.experimental.constrained.fma.f128(fp128 %x, fp128 %y, fp128 %z, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: fptosi_i32_f128:
+; CHECK: bl __fixtfsi
+define i32 @fptosi_i32_f128(fp128 %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.fptosi.i32.f128(fp128 %x, metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: fptoui_i32_f128:
+; CHECK: bl __fixunstfsi
+define i32 @fptoui_i32_f128(fp128 %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.fptoui.i32.f128(fp128 %x, metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: fptosi_i64_f128:
+; CHECK: bl __fixtfdi
+define i64 @fptosi_i64_f128(fp128 %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.fptosi.i64.f128(fp128 %x, metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: fptoui_i64_f128:
+; CHECK: bl __fixunstfdi
+define i64 @fptoui_i64_f128(fp128 %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.fptoui.i64.f128(fp128 %x, metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: sitofp_f128_i32:
+; CHECK: bl __floatsitf
+define fp128 @sitofp_f128_i32(i32 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.sitofp.f128.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: uitofp_f128_i32:
+; CHECK: bl __floatunsitf
+define fp128 @uitofp_f128_i32(i32 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.uitofp.f128.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: sitofp_f128_i64:
+; CHECK: bl __floatditf
+define fp128 @sitofp_f128_i64(i64 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.sitofp.f128.i64(i64 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: uitofp_f128_i64:
+; CHECK: bl __floatunditf
+define fp128 @uitofp_f128_i64(i64 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.uitofp.f128.i64(i64 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: sitofp_f128_i128:
+; CHECK: bl __floattitf
+define fp128 @sitofp_f128_i128(i128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.sitofp.f128.i128(i128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: uitofp_f128_i128:
+; CHECK: bl __floatuntitf
+define fp128 @uitofp_f128_i128(i128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.uitofp.f128.i128(i128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: sqrt_f128:
+; CHECK: bl sqrtl
+define fp128 @sqrt_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.sqrt.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: powi_f128:
+; CHECK: bl __powitf2
+define fp128 @powi_f128(fp128 %x, i32 %y) #0 {
+  %val = call fp128 @llvm.experimental.constrained.powi.f128(fp128 %x, i32 %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: sin_f128:
+; CHECK: bl sinl
+define fp128 @sin_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.sin.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: cos_f128:
+; CHECK: bl cosl
+define fp128 @cos_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.cos.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: pow_f128:
+; CHECK: bl powl
+define fp128 @pow_f128(fp128 %x, fp128 %y) #0 {
+  %val = call fp128 @llvm.experimental.constrained.pow.f128(fp128 %x, fp128 %y, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: log_f128:
+; CHECK: bl logl
+define fp128 @log_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.log.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: log10_f128:
+; CHECK: bl log10l
+define fp128 @log10_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.log10.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: log2_f128:
+; CHECK: bl log2l
+define fp128 @log2_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.log2.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: exp_f128:
+; CHECK: bl expl
+define fp128 @exp_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.exp.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: exp2_f128:
+; CHECK: bl exp2l
+define fp128 @exp2_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.exp2.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: rint_f128:
+; CHECK: bl rintl
+define fp128 @rint_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.rint.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: nearbyint_f128:
+; CHECK: bl nearbyintl
+define fp128 @nearbyint_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.nearbyint.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: lrint_f128:
+; CHECK: bl lrintl
+define i32 @lrint_f128(fp128 %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.lrint.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: llrint_f128:
+; CHECK: bl llrintl
+define i64 @llrint_f128(fp128 %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.llrint.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: maxnum_f128:
+; CHECK: bl fmaxl
+define fp128 @maxnum_f128(fp128 %x, fp128 %y) #0 {
+  %val = call fp128 @llvm.experimental.constrained.maxnum.f128(fp128 %x, fp128 %y, metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: minnum_f128:
+; CHECK: bl fminl
+define fp128 @minnum_f128(fp128 %x, fp128 %y) #0 {
+  %val = call fp128 @llvm.experimental.constrained.minnum.f128(fp128 %x, fp128 %y, metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: ceil_f128:
+; CHECK: bl ceill
+define fp128 @ceil_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.ceil.f128(fp128 %x, metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: floor_f128:
+; CHECK: bl floorl
+define fp128 @floor_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.floor.f128(fp128 %x, metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: lround_f128:
+; CHECK: bl lroundl
+define i32 @lround_f128(fp128 %x) #0 {
+  %val = call i32 @llvm.experimental.constrained.lround.f128(fp128 %x, metadata !"fpexcept.strict") #0
+  ret i32 %val
+}
+
+; CHECK-LABEL: llround_f128:
+; CHECK: bl llroundl
+define i64 @llround_f128(fp128 %x) #0 {
+  %val = call i64 @llvm.experimental.constrained.llround.f128(fp128 %x, metadata !"fpexcept.strict") #0
+  ret i64 %val
+}
+
+; CHECK-LABEL: round_f128:
+; CHECK: bl roundl
+define fp128 @round_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.round.f128(fp128 %x, metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: trunc_f128:
+; CHECK: bl truncl
+define fp128 @trunc_f128(fp128 %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.trunc.f128(fp128 %x, metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
 
-; CHECK-LABEL: fptrunc_f32:
+; TODO: fcmp (missing STRICT_FSETCC handling)
+
+
+; Intrinsics to convert between floating-point types
+
+; CHECK-LABEL: fptrunc_f32_f64:
 ; CHECK: fcvt s0, d0
-define float @fptrunc_f32(double %x) #0 {
+define float @fptrunc_f32_f64(double %x) #0 {
   %val = call float @llvm.experimental.constrained.fptrunc.f32.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret float %val
 }
 
-; CHECK-LABEL: fpext_f32:
+; CHECK-LABEL: fptrunc_f32_f128:
+; CHECK: bl __trunctfsf2
+define float @fptrunc_f32_f128(fp128 %x) #0 {
+  %val = call float @llvm.experimental.constrained.fptrunc.f32.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret float %val
+}
+
+; CHECK-LABEL: fptrunc_f64_f128:
+; CHECK: bl __trunctfdf2
+define double @fptrunc_f64_f128(fp128 %x) #0 {
+  %val = call double @llvm.experimental.constrained.fptrunc.f64.f128(fp128 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
+  ret double %val
+}
+
+; CHECK-LABEL: fpext_f64_f32:
 ; CHECK: fcvt d0, s0
-define double @fpext_f32(float %x) #0 {
+define double @fpext_f64_f32(float %x) #0 {
   %val = call double @llvm.experimental.constrained.fpext.f64.f32(float %x, metadata !"fpexcept.strict") #0
   ret double %val
 }
 
+; CHECK-LABEL: fpext_f128_f32:
+; CHECK: bl __extendsftf2
+define fp128 @fpext_f128_f32(float %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.fpext.f128.f32(float %x, metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
+; CHECK-LABEL: fpext_f128_f64:
+; CHECK: bl __extenddftf2
+define fp128 @fpext_f128_f64(double %x) #0 {
+  %val = call fp128 @llvm.experimental.constrained.fpext.f128.f64(double %x, metadata !"fpexcept.strict") #0
+  ret fp128 %val
+}
+
 
 attributes #0 = { strictfp }
 
@@ -921,6 +1261,8 @@ declare float @llvm.experimental.constrained.sitofp.f32.i32(i32, metadata, metad
 declare float @llvm.experimental.constrained.uitofp.f32.i32(i32, metadata, metadata)
 declare float @llvm.experimental.constrained.sitofp.f32.i64(i64, metadata, metadata)
 declare float @llvm.experimental.constrained.uitofp.f32.i64(i64, metadata, metadata)
+declare float @llvm.experimental.constrained.sitofp.f32.i128(i128, metadata, metadata)
+declare float @llvm.experimental.constrained.uitofp.f32.i128(i128, metadata, metadata)
 declare float @llvm.experimental.constrained.sqrt.f32(float, metadata, metadata)
 declare float @llvm.experimental.constrained.powi.f32(float, i32, metadata, metadata)
 declare float @llvm.experimental.constrained.sin.f32(float, metadata, metadata)
@@ -960,6 +1302,8 @@ declare double @llvm.experimental.constrained.sitofp.f64.i32(i32, metadata, meta
 declare double @llvm.experimental.constrained.uitofp.f64.i32(i32, metadata, metadata)
 declare double @llvm.experimental.constrained.sitofp.f64.i64(i64, metadata, metadata)
 declare double @llvm.experimental.constrained.uitofp.f64.i64(i64, metadata, metadata)
+declare double @llvm.experimental.constrained.sitofp.f64.i128(i128, metadata, metadata)
+declare double @llvm.experimental.constrained.uitofp.f64.i128(i128, metadata, metadata)
 declare double @llvm.experimental.constrained.sqrt.f64(double, metadata, metadata)
 declare double @llvm.experimental.constrained.powi.f64(double, i32, metadata, metadata)
 declare double @llvm.experimental.constrained.sin.f64(double, metadata, metadata)
@@ -985,5 +1329,50 @@ declare double @llvm.experimental.constrained.trunc.f64(double, metadata)
 declare i1 @llvm.experimental.constrained.fcmps.f64(double, double, metadata, metadata)
 declare i1 @llvm.experimental.constrained.fcmp.f64(double, double, metadata, metadata)
 
+declare fp128 @llvm.experimental.constrained.fadd.f128(fp128, fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.fsub.f128(fp128, fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.fmul.f128(fp128, fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.fdiv.f128(fp128, fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.frem.f128(fp128, fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.fma.f128(fp128, fp128, fp128, metadata, metadata)
+declare i32 @llvm.experimental.constrained.fptosi.i32.f128(fp128, metadata)
+declare i32 @llvm.experimental.constrained.fptoui.i32.f128(fp128, metadata)
+declare i64 @llvm.experimental.constrained.fptosi.i64.f128(fp128, metadata)
+declare i64 @llvm.experimental.constrained.fptoui.i64.f128(fp128, metadata)
+declare fp128 @llvm.experimental.constrained.sitofp.f128.i32(i32, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.uitofp.f128.i32(i32, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.sitofp.f128.i64(i64, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.uitofp.f128.i64(i64, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.sitofp.f128.i128(i128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.uitofp.f128.i128(i128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.sqrt.f128(fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.powi.f128(fp128, i32, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.sin.f128(fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.cos.f128(fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.pow.f128(fp128, fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.log.f128(fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.log10.f128(fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.log2.f128(fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.exp.f128(fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.exp2.f128(fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.rint.f128(fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.nearbyint.f128(fp128, metadata, metadata)
+declare i32 @llvm.experimental.constrained.lrint.f128(fp128, metadata, metadata)
+declare i64 @llvm.experimental.constrained.llrint.f128(fp128, metadata, metadata)
+declare fp128 @llvm.experimental.constrained.maxnum.f128(fp128, fp128, metadata)
+declare fp128 @llvm.experimental.constrained.minnum.f128(fp128, fp128, metadata)
+declare fp128 @llvm.experimental.constrained.ceil.f128(fp128, metadata)
+declare fp128 @llvm.experimental.constrained.floor.f128(fp128, metadata)
+declare i32 @llvm.experimental.constrained.lround.f128(fp128, metadata)
+declare i64 @llvm.experimental.constrained.llround.f128(fp128, metadata)
+declare fp128 @llvm.experimental.constrained.round.f128(fp128, metadata)
+declare fp128 @llvm.experimental.constrained.trunc.f128(fp128, metadata)
+declare i1 @llvm.experimental.constrained.fcmps.f128(fp128, fp128, metadata, metadata)
+declare i1 @llvm.experimental.constrained.fcmp.f128(fp128, fp128, metadata, metadata)
+
 declare float @llvm.experimental.constrained.fptrunc.f32.f64(double, metadata, metadata)
+declare float @llvm.experimental.constrained.fptrunc.f32.f128(fp128, metadata, metadata)
+declare double @llvm.experimental.constrained.fptrunc.f64.f128(fp128, metadata, metadata)
 declare double @llvm.experimental.constrained.fpext.f64.f32(float, metadata)
+declare fp128 @llvm.experimental.constrained.fpext.f128.f32(float, metadata)
+declare fp128 @llvm.experimental.constrained.fpext.f128.f64(double, metadata)
diff --git a/llvm/test/CodeGen/AArch64/fpconv-vector-op-scalarize-strict.ll b/llvm/test/CodeGen/AArch64/fpconv-vector-op-scalarize-strict.ll
index 30ab3bd1077..eba7fa88dc5 100644
--- a/llvm/test/CodeGen/AArch64/fpconv-vector-op-scalarize-strict.ll
+++ b/llvm/test/CodeGen/AArch64/fpconv-vector-op-scalarize-strict.ll
@@ -8,18 +8,8 @@
 define <1 x double> @test_sitofp(<1 x i1> %in) #0 {
 ; CHECK-LABEL: test_sitofp:
 ; CHECK:       ; %bb.0: ; %entry
-; CHECK-NEXT:    sub sp, sp, #16 ; =16
-; CHECK-NEXT:    .cfi_def_cfa_offset 16
 ; CHECK-NEXT:    sbfx w8, w0, #0, #1
-; CHECK-NEXT:    mov w9, #1127219200
-; CHECK-NEXT:    eor w8, w8, #0x80000000
-; CHECK-NEXT:    stp w8, w9, [sp, #8]
-; CHECK-NEXT:    ldr d0, [sp, #8]
-; CHECK-NEXT:    mov x8, #2147483648
-; CHECK-NEXT:    movk x8, #17200, lsl #48
-; CHECK-NEXT:    fmov d1, x8
-; CHECK-NEXT:    fsub d0, d0, d1
-; CHECK-NEXT:    add sp, sp, #16 ; =16
+; CHECK-NEXT:    scvtf d0, w8
 ; CHECK-NEXT:    ret
 entry:
   %0 = call <1 x double> @llvm.experimental.constrained.sitofp.v1f64.v1i1(<1 x i1> %in, metadata !"round.dynamic", metadata !"fpexcept.strict") #0
@@ -29,16 +19,8 @@ entry:
 define <1 x double> @test_uitofp(<1 x i1> %in) #0 {
 ; CHECK-LABEL: test_uitofp:
 ; CHECK:       ; %bb.0: ; %entry
-; CHECK-NEXT:    sub sp, sp, #16 ; =16
-; CHECK-NEXT:    .cfi_def_cfa_offset 16
 ; CHECK-NEXT:    and w8, w0, #0x1
-; CHECK-NEXT:    mov w9, #1127219200
-; CHECK-NEXT:    stp w8, w9, [sp, #8]
-; CHECK-NEXT:    ldr d0, [sp, #8]
-; CHECK-NEXT:    mov x8, #4841369599423283200
-; CHECK-NEXT:    fmov d1, x8
-; CHECK-NEXT:    fsub d0, d0, d1
-; CHECK-NEXT:    add sp, sp, #16 ; =16
+; CHECK-NEXT:    ucvtf d0, w8
 ; CHECK-NEXT:    ret
 entry:
   %0 = call <1 x double> @llvm.experimental.constrained.uitofp.v1f64.v1i1(<1 x i1> %in, metadata !"round.dynamic", metadata !"fpexcept.strict") #0

commit 19f4aa2d0ad68b99155582f28f0dfe2406c8fe32
Author: John Brawn <john.brawn@arm.com>
Date:   Wed Jan 22 14:04:12 2020 +0000

    [FPEnv][ARM] Add lowering of STRICT_FSETCC and STRICT_FSETCCS
    
    These can be lowered to code sequences using CMPFP and CMPFPE which then get
    selected to VCMP and VCMPE. The implementation isn't fully correct, as the chain
    operand isn't handled correctly, but resolving that looks like it would involve
    changes around FPSCR-handling instructions and how the FPSCR is modelled.
    
    The fp-intrinsics test was already testing some of this but as the entire test
    was being XFAILed it wasn't noticed. Un-XFAIL the test and instead leave the
    cases where we aren't generating the right instruction sequences as FIXME.
    
    Differential Revision: https://reviews.llvm.org/D73194
    
    (cherry picked from commit b37d59353f699e99f139a9227a6a69964ef4b132)

diff --git a/llvm/lib/Target/ARM/ARMISelLowering.cpp b/llvm/lib/Target/ARM/ARMISelLowering.cpp
index 1e6f7d88920..8e4bb91d53b 100644
--- a/llvm/lib/Target/ARM/ARMISelLowering.cpp
+++ b/llvm/lib/Target/ARM/ARMISelLowering.cpp
@@ -1354,6 +1354,14 @@ ARMTargetLowering::ARMTargetLowering(const TargetMachine &TM,
       setOperationAction(ISD::FP16_TO_FP, MVT::f32, Expand);
       setOperationAction(ISD::FP_TO_FP16, MVT::f32, Expand);
     }
+
+    // Strict floating-point comparisons need custom lowering.
+    setOperationAction(ISD::STRICT_FSETCC,  MVT::f16, Custom);
+    setOperationAction(ISD::STRICT_FSETCCS, MVT::f16, Custom);
+    setOperationAction(ISD::STRICT_FSETCC,  MVT::f32, Custom);
+    setOperationAction(ISD::STRICT_FSETCCS, MVT::f32, Custom);
+    setOperationAction(ISD::STRICT_FSETCC,  MVT::f64, Custom);
+    setOperationAction(ISD::STRICT_FSETCCS, MVT::f64, Custom);
   }
 
   // Use __sincos_stret if available.
@@ -1552,7 +1560,9 @@ const char *ARMTargetLowering::getTargetNodeName(unsigned Opcode) const {
   case ARMISD::CMN:           return "ARMISD::CMN";
   case ARMISD::CMPZ:          return "ARMISD::CMPZ";
   case ARMISD::CMPFP:         return "ARMISD::CMPFP";
+  case ARMISD::CMPFPE:        return "ARMISD::CMPFPE";
   case ARMISD::CMPFPw0:       return "ARMISD::CMPFPw0";
+  case ARMISD::CMPFPEw0:      return "ARMISD::CMPFPEw0";
   case ARMISD::BCC_i64:       return "ARMISD::BCC_i64";
   case ARMISD::FMSTAT:        return "ARMISD::FMSTAT";
 
@@ -4344,13 +4354,16 @@ SDValue ARMTargetLowering::getARMCmp(SDValue LHS, SDValue RHS, ISD::CondCode CC,
 
 /// Returns a appropriate VFP CMP (fcmp{s|d}+fmstat) for the given operands.
 SDValue ARMTargetLowering::getVFPCmp(SDValue LHS, SDValue RHS,
-                                     SelectionDAG &DAG, const SDLoc &dl) const {
+                                     SelectionDAG &DAG, const SDLoc &dl,
+                                     bool Signaling) const {
   assert(Subtarget->hasFP64() || RHS.getValueType() != MVT::f64);
   SDValue Cmp;
   if (!isFloatingPointZero(RHS))
-    Cmp = DAG.getNode(ARMISD::CMPFP, dl, MVT::Glue, LHS, RHS);
+    Cmp = DAG.getNode(Signaling ? ARMISD::CMPFPE : ARMISD::CMPFP,
+                      dl, MVT::Glue, LHS, RHS);
   else
-    Cmp = DAG.getNode(ARMISD::CMPFPw0, dl, MVT::Glue, LHS);
+    Cmp = DAG.getNode(Signaling ? ARMISD::CMPFPEw0 : ARMISD::CMPFPw0,
+                      dl, MVT::Glue, LHS);
   return DAG.getNode(ARMISD::FMSTAT, dl, MVT::Glue, Cmp);
 }
 
@@ -9222,6 +9235,51 @@ static void ReplaceCMP_SWAP_64Results(SDNode *N,
   Results.push_back(SDValue(CmpSwap, 2));
 }
 
+SDValue ARMTargetLowering::LowerFSETCC(SDValue Op, SelectionDAG &DAG) const {
+  SDLoc dl(Op);
+  EVT VT = Op.getValueType();
+  SDValue Chain = Op.getOperand(0);
+  SDValue LHS = Op.getOperand(1);
+  SDValue RHS = Op.getOperand(2);
+  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(3))->get();
+  bool IsSignaling = Op.getOpcode() == ISD::STRICT_FSETCCS;
+
+  // If we don't have instructions of this float type then soften to a libcall
+  // and use SETCC instead.
+  if (isUnsupportedFloatingType(LHS.getValueType())) {
+    DAG.getTargetLoweringInfo().softenSetCCOperands(
+      DAG, LHS.getValueType(), LHS, RHS, CC, dl, LHS, RHS, Chain, IsSignaling);
+    if (!RHS.getNode()) {
+      RHS = DAG.getConstant(0, dl, LHS.getValueType());
+      CC = ISD::SETNE;
+    }
+    SDValue Result = DAG.getNode(ISD::SETCC, dl, VT, LHS, RHS,
+                                 DAG.getCondCode(CC));
+    return DAG.getMergeValues({Result, Chain}, dl);
+  }
+
+  ARMCC::CondCodes CondCode, CondCode2;
+  FPCCToARMCC(CC, CondCode, CondCode2);
+
+  // FIXME: Chain is not handled correctly here. Currently the FPSCR is implicit
+  // in CMPFP and CMPFPE, but instead it should be made explicit by these
+  // instructions using a chain instead of glue. This would also fix the problem
+  // here (and also in LowerSELECT_CC) where we generate two comparisons when
+  // CondCode2 != AL.
+  SDValue True = DAG.getConstant(1, dl, VT);
+  SDValue False =  DAG.getConstant(0, dl, VT);
+  SDValue ARMcc = DAG.getConstant(CondCode, dl, MVT::i32);
+  SDValue CCR = DAG.getRegister(ARM::CPSR, MVT::i32);
+  SDValue Cmp = getVFPCmp(LHS, RHS, DAG, dl, IsSignaling);
+  SDValue Result = getCMOV(dl, VT, False, True, ARMcc, CCR, Cmp, DAG);
+  if (CondCode2 != ARMCC::AL) {
+    ARMcc = DAG.getConstant(CondCode2, dl, MVT::i32);
+    Cmp = getVFPCmp(LHS, RHS, DAG, dl, IsSignaling);
+    Result = getCMOV(dl, VT, Result, True, ARMcc, CCR, Cmp, DAG);
+  }
+  return DAG.getMergeValues({Result, Chain}, dl);
+}
+
 SDValue ARMTargetLowering::LowerOperation(SDValue Op, SelectionDAG &DAG) const {
   LLVM_DEBUG(dbgs() << "Lowering node: "; Op.dump());
   switch (Op.getOpcode()) {
@@ -9315,6 +9373,8 @@ SDValue ARMTargetLowering::LowerOperation(SDValue Op, SelectionDAG &DAG) const {
   case ISD::FP_ROUND: return LowerFP_ROUND(Op, DAG);
   case ISD::STRICT_FP_EXTEND:
   case ISD::FP_EXTEND: return LowerFP_EXTEND(Op, DAG);
+  case ISD::STRICT_FSETCC:
+  case ISD::STRICT_FSETCCS: return LowerFSETCC(Op, DAG);
   case ARMISD::WIN__DBZCHK: return SDValue();
   }
 }
diff --git a/llvm/lib/Target/ARM/ARMISelLowering.h b/llvm/lib/Target/ARM/ARMISelLowering.h
index cc74e5d875d..6061a65d3b8 100644
--- a/llvm/lib/Target/ARM/ARMISelLowering.h
+++ b/llvm/lib/Target/ARM/ARMISelLowering.h
@@ -84,7 +84,9 @@ class VectorType;
       CMN,          // ARM CMN instructions.
       CMPZ,         // ARM compare that sets only Z flag.
       CMPFP,        // ARM VFP compare instruction, sets FPSCR.
+      CMPFPE,       // ARM VFP signalling compare instruction, sets FPSCR.
       CMPFPw0,      // ARM VFP compare against zero instruction, sets FPSCR.
+      CMPFPEw0,     // ARM VFP signalling compare against zero instruction, sets FPSCR.
       FMSTAT,       // ARM fmstat instruction.
 
       CMOV,         // ARM conditional move instructions.
@@ -729,6 +731,7 @@ class VectorType;
     SDValue LowerFP_EXTEND(SDValue Op, SelectionDAG &DAG) const;
     SDValue LowerFP_TO_INT(SDValue Op, SelectionDAG &DAG) const;
     SDValue LowerINT_TO_FP(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerFSETCC(SDValue Op, SelectionDAG &DAG) const;
     void lowerABS(SDNode *N, SmallVectorImpl<SDValue> &Results,
                   SelectionDAG &DAG) const;
 
@@ -817,7 +820,7 @@ class VectorType;
     SDValue getARMCmp(SDValue LHS, SDValue RHS, ISD::CondCode CC,
                       SDValue &ARMcc, SelectionDAG &DAG, const SDLoc &dl) const;
     SDValue getVFPCmp(SDValue LHS, SDValue RHS, SelectionDAG &DAG,
-                      const SDLoc &dl) const;
+                      const SDLoc &dl, bool Signaling = false) const;
     SDValue duplicateCmp(SDValue Cmp, SelectionDAG &DAG) const;
 
     SDValue OptimizeVFPBrcond(SDValue Op, SelectionDAG &DAG) const;
diff --git a/llvm/lib/Target/ARM/ARMInstrVFP.td b/llvm/lib/Target/ARM/ARMInstrVFP.td
index a41a483d1a4..f1d1d8a8916 100644
--- a/llvm/lib/Target/ARM/ARMInstrVFP.td
+++ b/llvm/lib/Target/ARM/ARMInstrVFP.td
@@ -21,6 +21,8 @@ def SDT_VMOVSR : SDTypeProfile<1, 1, [SDTCisVT<0, f32>, SDTCisVT<1, i32>]>;
 def arm_fmstat : SDNode<"ARMISD::FMSTAT",  SDTNone, [SDNPInGlue, SDNPOutGlue]>;
 def arm_cmpfp  : SDNode<"ARMISD::CMPFP",   SDT_ARMCmp, [SDNPOutGlue]>;
 def arm_cmpfp0 : SDNode<"ARMISD::CMPFPw0", SDT_CMPFP0, [SDNPOutGlue]>;
+def arm_cmpfpe : SDNode<"ARMISD::CMPFPE",  SDT_ARMCmp, [SDNPOutGlue]>;
+def arm_cmpfpe0: SDNode<"ARMISD::CMPFPEw0",SDT_CMPFP0, [SDNPOutGlue]>;
 def arm_fmdrr  : SDNode<"ARMISD::VMOVDRR", SDT_VMOVDRR>;
 def arm_fmrrd  : SDNode<"ARMISD::VMOVRRD", SDT_VMOVRRD>;
 def arm_vmovsr  : SDNode<"ARMISD::VMOVSR", SDT_VMOVSR>;
@@ -548,12 +550,12 @@ let Defs = [FPSCR_NZCV] in {
 def VCMPED : ADuI<0b11101, 0b11, 0b0100, 0b11, 0,
                   (outs), (ins DPR:$Dd, DPR:$Dm),
                   IIC_fpCMP64, "vcmpe", ".f64\t$Dd, $Dm",
-                  [/* For disassembly only; pattern left blank */]>;
+                  [(arm_cmpfpe DPR:$Dd, (f64 DPR:$Dm))]>;
 
 def VCMPES : ASuI<0b11101, 0b11, 0b0100, 0b11, 0,
                   (outs), (ins SPR:$Sd, SPR:$Sm),
                   IIC_fpCMP32, "vcmpe", ".f32\t$Sd, $Sm",
-                  [/* For disassembly only; pattern left blank */]> {
+                  [(arm_cmpfpe SPR:$Sd, SPR:$Sm)]> {
   // Some single precision VFP instructions may be executed on both NEON and
   // VFP pipelines on A8.
   let D = VFPNeonA8Domain;
@@ -562,7 +564,7 @@ def VCMPES : ASuI<0b11101, 0b11, 0b0100, 0b11, 0,
 def VCMPEH : AHuI<0b11101, 0b11, 0b0100, 0b11, 0,
                   (outs), (ins HPR:$Sd, HPR:$Sm),
                   IIC_fpCMP16, "vcmpe", ".f16\t$Sd, $Sm",
-                  [/* For disassembly only; pattern left blank */]>;
+                  [(arm_cmpfpe HPR:$Sd, HPR:$Sm)]>;
 
 def VCMPD  : ADuI<0b11101, 0b11, 0b0100, 0b01, 0,
                   (outs), (ins DPR:$Dd, DPR:$Dm),
@@ -611,7 +613,7 @@ let Defs = [FPSCR_NZCV] in {
 def VCMPEZD : ADuI<0b11101, 0b11, 0b0101, 0b11, 0,
                    (outs), (ins DPR:$Dd),
                    IIC_fpCMP64, "vcmpe", ".f64\t$Dd, #0",
-                   [/* For disassembly only; pattern left blank */]> {
+                   [(arm_cmpfpe0 (f64 DPR:$Dd))]> {
   let Inst{3-0} = 0b0000;
   let Inst{5}   = 0;
 }
@@ -619,7 +621,7 @@ def VCMPEZD : ADuI<0b11101, 0b11, 0b0101, 0b11, 0,
 def VCMPEZS : ASuI<0b11101, 0b11, 0b0101, 0b11, 0,
                    (outs), (ins SPR:$Sd),
                    IIC_fpCMP32, "vcmpe", ".f32\t$Sd, #0",
-                   [/* For disassembly only; pattern left blank */]> {
+                   [(arm_cmpfpe0 SPR:$Sd)]> {
   let Inst{3-0} = 0b0000;
   let Inst{5}   = 0;
 
@@ -631,7 +633,7 @@ def VCMPEZS : ASuI<0b11101, 0b11, 0b0101, 0b11, 0,
 def VCMPEZH : AHuI<0b11101, 0b11, 0b0101, 0b11, 0,
                    (outs), (ins HPR:$Sd),
                    IIC_fpCMP16, "vcmpe", ".f16\t$Sd, #0",
-                   [/* For disassembly only; pattern left blank */]> {
+                   [(arm_cmpfpe0 HPR:$Sd)]> {
   let Inst{3-0} = 0b0000;
   let Inst{5}   = 0;
 }
diff --git a/llvm/test/CodeGen/ARM/fp-intrinsics.ll b/llvm/test/CodeGen/ARM/fp-intrinsics.ll
index 9a15a626e28..4352548ef3c 100644
--- a/llvm/test/CodeGen/ARM/fp-intrinsics.ll
+++ b/llvm/test/CodeGen/ARM/fp-intrinsics.ll
@@ -8,9 +8,8 @@
 ; hardware being present or absent work as expected (i.e. we get an instruction
 ; when one is available, otherwise a libcall).
 
-; FIXME: Tests fails as various things in CodeGen and Target/ARM need fixing.
-; XFAIL: *
-
+; FIXME: We're not generating the right instructions for some of these
+; operations (see further FIXMEs down below).
 
 ; Single-precision intrinsics
 
@@ -71,7 +70,7 @@ define i32 @fptosi_f32(float %x) #0 {
 
 ; CHECK-LABEL: fptoui_f32:
 ; CHECK-NOSP: bl __aeabi_f2uiz
-; CHECK-SP: vcvt.u32.f32
+; FIXME-CHECK-SP: vcvt.u32.f32
 define i32 @fptoui_f32(float %x) #0 {
   %val = call i32 @llvm.experimental.constrained.fptoui.f32(float %x, metadata !"fpexcept.strict") #0
   ret i32 %val
@@ -240,6 +239,226 @@ define float @trunc_f32(float %x) #0 {
   ret float %val
 }
 
+; CHECK-LABEL: fcmp_olt_f32:
+; CHECK-NOSP: bl __aeabi_fcmplt
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_olt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"olt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ole_f32:
+; CHECK-NOSP: bl __aeabi_fcmple
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_ole_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ole", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ogt_f32:
+; CHECK-NOSP: bl __aeabi_fcmpgt
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_ogt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ogt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_oge_f32:
+; CHECK-NOSP: bl __aeabi_fcmpge
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_oge_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"oge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_oeq_f32:
+; CHECK-NOSP: bl __aeabi_fcmpeq
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_oeq_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"oeq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_one_f32:
+; CHECK-NOSP: bl __aeabi_fcmpeq
+; CHECK-NOSP: bl __aeabi_fcmpun
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_one_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"one", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ult_f32:
+; CHECK-NOSP: bl __aeabi_fcmpge
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_ult_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ult", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ule_f32:
+; CHECK-NOSP: bl __aeabi_fcmpgt
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_ule_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ule", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ugt_f32:
+; CHECK-NOSP: bl __aeabi_fcmple
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_ugt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ugt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_uge_f32:
+; CHECK-NOSP: bl __aeabi_fcmplt
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_uge_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"uge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ueq_f32:
+; CHECK-NOSP: bl __aeabi_fcmpeq
+; CHECK-NOSP: bl __aeabi_fcmpun
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_ueq_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"ueq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_une_f32:
+; CHECK-NOSP: bl __aeabi_fcmpeq
+; CHECK-SP: vcmp.f32
+define i32 @fcmp_une_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %a, float %b, metadata !"une", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_olt_f32:
+; CHECK-NOSP: bl __aeabi_fcmplt
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_olt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"olt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ole_f32:
+; CHECK-NOSP: bl __aeabi_fcmple
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_ole_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ole", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ogt_f32:
+; CHECK-NOSP: bl __aeabi_fcmpgt
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_ogt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ogt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_oge_f32:
+; CHECK-NOSP: bl __aeabi_fcmpge
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_oge_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"oge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_oeq_f32:
+; CHECK-NOSP: bl __aeabi_fcmpeq
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_oeq_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"oeq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_one_f32:
+; CHECK-NOSP: bl __aeabi_fcmpeq
+; CHECK-NOSP: bl __aeabi_fcmpun
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_one_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"one", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ult_f32:
+; CHECK-NOSP: bl __aeabi_fcmpge
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_ult_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ult", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ule_f32:
+; CHECK-NOSP: bl __aeabi_fcmpgt
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_ule_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ule", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ugt_f32:
+; CHECK-NOSP: bl __aeabi_fcmple
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_ugt_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ugt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_uge_f32:
+; CHECK-NOSP: bl __aeabi_fcmplt
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_uge_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"uge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ueq_f32:
+; CHECK-NOSP: bl __aeabi_fcmpeq
+; CHECK-NOSP: bl __aeabi_fcmpun
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_ueq_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"ueq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_une_f32:
+; CHECK-NOSP: bl __aeabi_fcmpeq
+; CHECK-SP: vcmpe.f32
+define i32 @fcmps_une_f32(float %a, float %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f32(float %a, float %b, metadata !"une", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
 
 ; Double-precision intrinsics
 
@@ -300,7 +519,7 @@ define i32 @fptosi_f64(double %x) #0 {
 
 ; CHECK-LABEL: fptoui_f64:
 ; CHECK-NODP: bl __aeabi_d2uiz
-; CHECK-DP: vcvt.u32.f64
+; FIXME-CHECK-DP: vcvt.u32.f64
 define i32 @fptoui_f64(double %x) #0 {
   %val = call i32 @llvm.experimental.constrained.fptoui.f64(double %x, metadata !"fpexcept.strict") #0
   ret i32 %val
@@ -469,6 +688,226 @@ define double @trunc_f64(double %x) #0 {
   ret double %val
 }
 
+; CHECK-LABEL: fcmp_olt_f64:
+; CHECK-NODP: bl __aeabi_dcmplt
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_olt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"olt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ole_f64:
+; CHECK-NODP: bl __aeabi_dcmple
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_ole_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ole", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ogt_f64:
+; CHECK-NODP: bl __aeabi_dcmpgt
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_ogt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ogt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_oge_f64:
+; CHECK-NODP: bl __aeabi_dcmpge
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_oge_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"oge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_oeq_f64:
+; CHECK-NODP: bl __aeabi_dcmpeq
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_oeq_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"oeq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_one_f64:
+; CHECK-NODP-DAG: bl __aeabi_dcmpeq
+; CHECK-NODP-DAG: bl __aeabi_dcmpun
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_one_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"one", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ult_f64:
+; CHECK-NODP: bl __aeabi_dcmpge
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_ult_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ult", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ule_f64:
+; CHECK-NODP: bl __aeabi_dcmpgt
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_ule_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ule", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ugt_f64:
+; CHECK-NODP: bl __aeabi_dcmple
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_ugt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ugt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_uge_f64:
+; CHECK-NODP: bl __aeabi_dcmplt
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_uge_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"uge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ueq_f64:
+; CHECK-NODP-DAG: bl __aeabi_dcmpeq
+; CHECK-NODP-DAG: bl __aeabi_dcmpun
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_ueq_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"ueq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_une_f64:
+; CHECK-NODP: bl __aeabi_dcmpeq
+; CHECK-DP: vcmp.f64
+define i32 @fcmp_une_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f64(double %a, double %b, metadata !"une", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_olt_f64:
+; CHECK-NODP: bl __aeabi_dcmplt
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_olt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"olt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ole_f64:
+; CHECK-NODP: bl __aeabi_dcmple
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_ole_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ole", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ogt_f64:
+; CHECK-NODP: bl __aeabi_dcmpgt
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_ogt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ogt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_oge_f64:
+; CHECK-NODP: bl __aeabi_dcmpge
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_oge_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"oge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_oeq_f64:
+; CHECK-NODP: bl __aeabi_dcmpeq
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_oeq_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"oeq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_one_f64:
+; CHECK-NODP-DAG: bl __aeabi_dcmpeq
+; CHECK-NODP-DAG: bl __aeabi_dcmpun
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_one_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"one", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ult_f64:
+; CHECK-NODP: bl __aeabi_dcmpge
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_ult_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ult", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ule_f64:
+; CHECK-NODP: bl __aeabi_dcmpgt
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_ule_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ule", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ugt_f64:
+; CHECK-NODP: bl __aeabi_dcmple
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_ugt_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ugt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_uge_f64:
+; CHECK-NODP: bl __aeabi_dcmplt
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_uge_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"uge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ueq_f64:
+; CHECK-NODP-DAG: bl __aeabi_dcmpeq
+; CHECK-NODP-DAG: bl __aeabi_dcmpun
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_ueq_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"ueq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_une_f64:
+; CHECK-NODP: bl __aeabi_dcmpeq
+; CHECK-DP: vcmpe.f64
+define i32 @fcmps_une_f64(double %a, double %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f64(double %a, double %b, metadata !"une", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
 
 ; Single/Double conversion intrinsics
 
@@ -490,15 +929,15 @@ define double @fpext_f32(float %x) #0 {
 
 ; CHECK-LABEL: sitofp_f32_i32:
 ; CHECK-NOSP: bl __aeabi_i2f
-; CHECK-SP: vcvt.f32.s32
+; FIXME-CHECK-SP: vcvt.f32.s32
 define float @sitofp_f32_i32(i32 %x) #0 {
   %val = call float @llvm.experimental.constrained.sitofp.f32.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret float %val
 }
 
 ; CHECK-LABEL: sitofp_f64_i32:
-; CHECK-NODP: bl __aeabi_i2d
-; CHECK-DP: vcvt.f64.s32
+; FIXME-CHECK-NODP: bl __aeabi_i2d
+; FIXME-CHECK-DP: vcvt.f64.s32
 define double @sitofp_f64_i32(i32 %x) #0 {
   %val = call double @llvm.experimental.constrained.sitofp.f64.i32(i32 %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret double %val
@@ -537,6 +976,8 @@ declare i32 @llvm.experimental.constrained.lround.f32(float, metadata)
 declare i32 @llvm.experimental.constrained.llround.f32(float, metadata)
 declare float @llvm.experimental.constrained.round.f32(float, metadata)
 declare float @llvm.experimental.constrained.trunc.f32(float, metadata)
+declare i1 @llvm.experimental.constrained.fcmps.f32(float, float, metadata, metadata)
+declare i1 @llvm.experimental.constrained.fcmp.f32(float, float, metadata, metadata)
 
 declare double @llvm.experimental.constrained.fadd.f64(double, double, metadata, metadata)
 declare double @llvm.experimental.constrained.fsub.f64(double, double, metadata, metadata)
@@ -568,6 +1009,8 @@ declare i32 @llvm.experimental.constrained.lround.f64(double, metadata)
 declare i32 @llvm.experimental.constrained.llround.f64(double, metadata)
 declare double @llvm.experimental.constrained.round.f64(double, metadata)
 declare double @llvm.experimental.constrained.trunc.f64(double, metadata)
+declare i1 @llvm.experimental.constrained.fcmps.f64(double, double, metadata, metadata)
+declare i1 @llvm.experimental.constrained.fcmp.f64(double, double, metadata, metadata)
 
 declare float @llvm.experimental.constrained.fptrunc.f32.f64(double, metadata, metadata)
 declare double @llvm.experimental.constrained.fpext.f64.f32(float, metadata)

commit cff417cffd61d2c4607eb142e272ec10ebec2c21
Author: John Brawn <john.brawn@arm.com>
Date:   Tue Jan 28 14:04:09 2020 +0000

    [FPEnv][AArch64] Add lowering of f128 STRICT_FSETCC
    
    These get lowered to function calls, like the non-strict versions.
    
    Differential Revision: https://reviews.llvm.org/D73784
    
    (cherry picked from commit 68cf574857c81f711f498a479855a17e7bea40f7)

diff --git a/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp b/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
index 94b6d1ac763..23f05eaad94 100644
--- a/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
+++ b/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp
@@ -272,6 +272,8 @@ AArch64TargetLowering::AArch64TargetLowering(const TargetMachine &TM,
   setOperationAction(ISD::FSUB, MVT::f128, Custom);
   setOperationAction(ISD::FTRUNC, MVT::f128, Expand);
   setOperationAction(ISD::SETCC, MVT::f128, Custom);
+  setOperationAction(ISD::STRICT_FSETCC, MVT::f128, Custom);
+  setOperationAction(ISD::STRICT_FSETCCS, MVT::f128, Custom);
   setOperationAction(ISD::BR_CC, MVT::f128, Custom);
   setOperationAction(ISD::SELECT, MVT::f128, Custom);
   setOperationAction(ISD::SELECT_CC, MVT::f128, Custom);
@@ -5244,7 +5246,6 @@ SDValue AArch64TargetLowering::LowerSETCC(SDValue Op, SelectionDAG &DAG) const {
   }
 
   if (LHS.getValueType().isInteger()) {
-    assert(!IsStrict && "Unexpected integer in strict fp comparison!");
     SDValue CCVal;
     SDValue Cmp = getAArch64Cmp(
         LHS, RHS, ISD::getSetCCInverse(CC, LHS.getValueType()), CCVal, DAG, dl);
@@ -5252,7 +5253,8 @@ SDValue AArch64TargetLowering::LowerSETCC(SDValue Op, SelectionDAG &DAG) const {
     // Note that we inverted the condition above, so we reverse the order of
     // the true and false operands here.  This will allow the setcc to be
     // matched to a single CSINC instruction.
-    return DAG.getNode(AArch64ISD::CSEL, dl, VT, FVal, TVal, CCVal, Cmp);
+    SDValue Res = DAG.getNode(AArch64ISD::CSEL, dl, VT, FVal, TVal, CCVal, Cmp);
+    return IsStrict ? DAG.getMergeValues({Res, Chain}, dl) : Res;
   }
 
   // Now we know we're dealing with FP values.
diff --git a/llvm/test/CodeGen/AArch64/fp-intrinsics.ll b/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
index d3e17dcf5ff..3c412a5f7e0 100644
--- a/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
+++ b/llvm/test/CodeGen/AArch64/fp-intrinsics.ll
@@ -1197,7 +1197,197 @@ define fp128 @trunc_f128(fp128 %x) #0 {
   ret fp128 %val
 }
 
-; TODO: fcmp (missing STRICT_FSETCC handling)
+; CHECK-LABEL: fcmp_olt_f128:
+; CHECK: bl __lttf2
+define i32 @fcmp_olt_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"olt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ole_f128:
+; CHECK: bl __letf2
+define i32 @fcmp_ole_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"ole", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ogt_f128:
+; CHECK: bl __gttf2
+define i32 @fcmp_ogt_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"ogt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_oge_f128:
+; CHECK: bl __getf2
+define i32 @fcmp_oge_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"oge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_oeq_f128:
+; CHECK: bl __eqtf2
+define i32 @fcmp_oeq_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"oeq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_one_f128:
+; CHECK: bl __eqtf2
+define i32 @fcmp_one_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"one", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ult_f128:
+; CHECK: bl __getf2
+define i32 @fcmp_ult_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"ult", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ule_f128:
+; CHECK: bl __gttf2
+define i32 @fcmp_ule_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"ule", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ugt_f128:
+; CHECK: bl __letf2
+define i32 @fcmp_ugt_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"ugt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_uge_f128:
+; CHECK: bl __lttf2
+define i32 @fcmp_uge_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"uge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_ueq_f128:
+; CHECK: bl __eqtf2
+define i32 @fcmp_ueq_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"ueq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmp_une_f128:
+; CHECK: bl __netf2
+define i32 @fcmp_une_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f128(fp128 %a, fp128 %b, metadata !"une", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_olt_f128:
+; CHECK: bl __lttf2
+define i32 @fcmps_olt_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"olt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ole_f128:
+; CHECK: bl __letf2
+define i32 @fcmps_ole_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"ole", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ogt_f128:
+; CHECK: bl __gttf2
+define i32 @fcmps_ogt_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"ogt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_oge_f128:
+; CHECK: bl __getf2
+define i32 @fcmps_oge_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"oge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_oeq_f128:
+; CHECK: bl __eqtf2
+define i32 @fcmps_oeq_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"oeq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_one_f128:
+; CHECK: bl __eqtf2
+define i32 @fcmps_one_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"one", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ult_f128:
+; CHECK: bl __getf2
+define i32 @fcmps_ult_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"ult", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ule_f128:
+; CHECK: bl __gttf2
+define i32 @fcmps_ule_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"ule", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ugt_f128:
+; CHECK: bl __letf2
+define i32 @fcmps_ugt_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"ugt", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_uge_f128:
+; CHECK: bl __lttf2
+define i32 @fcmps_uge_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"uge", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_ueq_f128:
+; CHECK: bl __eqtf2
+define i32 @fcmps_ueq_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"ueq", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
+
+; CHECK-LABEL: fcmps_une_f128:
+; CHECK: bl __netf2
+define i32 @fcmps_une_f128(fp128 %a, fp128 %b) #0 {
+  %cmp = call i1 @llvm.experimental.constrained.fcmps.f128(fp128 %a, fp128 %b, metadata !"une", metadata !"fpexcept.strict") #0
+  %conv = zext i1 %cmp to i32
+  ret i32 %conv
+}
 
 
 ; Intrinsics to convert between floating-point types

commit cbac41966b8f9356a3e69c050b60770108550d1e
Author: John Brawn <john.brawn@arm.com>
Date:   Thu Feb 13 14:52:33 2020 +0000

    [ARM] Fix infinite loop when lowering STRICT_FP_EXTEND
    
    If the target has FP64 but not FP16 then we have custom lowering for FP_EXTEND
    and STRICT_FP_EXTEND with type f64. However if the extend is from f32 to f64 the
    current implementation will cause in infinite loop for STRICT_FP_EXTEND due to
    emitting a merge_values of the original node which after replacement becomes a
    merge_values of itself.
    
    Fix this by not doing anything for f32 to f64 extend when we have FP64, though
    for STRICT_FP_EXTEND we have to do the strict-to-nonstrict mutation as that
    doesn't happen automatically for opcodes with custom lowering.
    
    Differential Revision: https://reviews.llvm.org/D74559
    
    (cherry picked from commit 0ec57972967dfb43fc022c2e3788be041d1db730)

diff --git a/llvm/lib/Target/ARM/ARMISelLowering.cpp b/llvm/lib/Target/ARM/ARMISelLowering.cpp
index 8e4bb91d53b..559a4e8435c 100644
--- a/llvm/lib/Target/ARM/ARMISelLowering.cpp
+++ b/llvm/lib/Target/ARM/ARMISelLowering.cpp
@@ -16380,6 +16380,15 @@ SDValue ARMTargetLowering::LowerFP_EXTEND(SDValue Op, SelectionDAG &DAG) const {
   assert(!(DstSz == 32 && Subtarget->hasFP16()) &&
          "With FP16, 16 to 32 conversion is legal!");
 
+  // Converting from 32 -> 64 is valid if we have FP64.
+  if (SrcSz == 32 && DstSz == 64 && Subtarget->hasFP64()) {
+    // FIXME: Remove this when we have strict fp instruction selection patterns
+    if (IsStrict) {
+      DAG.mutateStrictFPToFP(Op.getNode());
+    }
+    return Op;
+  }
+
   // Either we are converting from 16 -> 64, without FP16 and/or
   // FP.double-precision or without Armv8-fp. So we must do it in two
   // steps.
diff --git a/llvm/test/CodeGen/ARM/fp-intrinsics.ll b/llvm/test/CodeGen/ARM/fp-intrinsics.ll
index 4352548ef3c..c5746ef7b30 100644
--- a/llvm/test/CodeGen/ARM/fp-intrinsics.ll
+++ b/llvm/test/CodeGen/ARM/fp-intrinsics.ll
@@ -1,7 +1,11 @@
-; RUN: llc -mtriple=armv8a-none-eabi %s -o - | FileCheck %s --check-prefixes=CHECK,CHECK-SP,CHECK-DP
+; RUN: llc -mtriple=armv8a-none-eabi %s -o - | FileCheck %s --check-prefixes=CHECK,CHECK-SP,CHECK-DP,CHECK-SP-V8,CHECK-DP-V8
 ; RUN: llc -mtriple=thumbv8m.main-none-eabi %s -o - | FileCheck %s --check-prefixes=CHECK,CHECK-NOSP,CHECK-NODP
-; RUN: llc -mtriple=thumbv8m.main-none-eabi %s -o - -mattr=fp-armv8 | FileCheck %s --check-prefixes=CHECK,CHECK-SP,CHECK-DP
-; RUN: llc -mtriple=thumbv8m.main-none-eabi %s -o - -mattr=fp-armv8sp | FileCheck %s --check-prefixes=CHECK,CHECK-SP,CHECK-NODP
+; RUN: llc -mtriple=thumbv8m.main-none-eabi %s -o - -mattr=fp-armv8 | FileCheck %s --check-prefixes=CHECK,CHECK-SP,CHECK-DP,CHECK-SP-V8,CHECK-DP-V8
+; RUN: llc -mtriple=thumbv8m.main-none-eabi %s -o - -mattr=fp-armv8sp | FileCheck %s --check-prefixes=CHECK,CHECK-SP,CHECK-NODP,CHECK-SP-V8
+; RUN: llc -mtriple=armv7a-none-eabi %s -o - -mattr=vfp4 | FileCheck %s --check-prefixes=CHECK,CHECK-SP,CHECK-DP,CHECK-SP-NOV8,CHECK-DP-NOV8
+; RUN: llc -mtriple=thumbv7m-none-eabi %s -o - | FileCheck %s --check-prefixes=CHECK,CHECK-NOSP,CHECK-NODP
+; RUN: llc -mtriple=thumbv7m-none-eabi %s -o - -mattr=vfp4 | FileCheck %s --check-prefixes=CHECK,CHECK-SP,CHECK-DP,CHECK-SP-NOV8,CHECK-DP-NOV8
+; RUN: llc -mtriple=thumbv7m-none-eabi %s -o - -mattr=vfp4sp | FileCheck %s --check-prefixes=CHECK,CHECK-SP,CHECK-NODP,CHECK-SP-NOV8
 
 ; Check that constrained fp intrinsics are correctly lowered. In particular
 ; check that the valid combinations of single-precision and double-precision
@@ -149,7 +153,8 @@ define float @exp2_f32(float %x) #0 {
 
 ; CHECK-LABEL: rint_f32:
 ; CHECK-NOSP: bl rintf
-; CHECK-SP: vrintx.f32
+; CHECK-SP-NOV8: bl rintf
+; CHECK-SP-V8: vrintx.f32
 define float @rint_f32(float %x) #0 {
   %val = call float @llvm.experimental.constrained.rint.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret float %val
@@ -157,7 +162,8 @@ define float @rint_f32(float %x) #0 {
 
 ; CHECK-LABEL: nearbyint_f32:
 ; CHECK-NOSP: bl nearbyintf
-; CHECK-SP: vrintr.f32
+; CHECK-SP-NOV8: bl nearbyintf
+; CHECK-SP-V8: vrintr.f32
 define float @nearbyint_f32(float %x) #0 {
   %val = call float @llvm.experimental.constrained.nearbyint.f32(float %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret float %val
@@ -179,7 +185,8 @@ define i32 @llrint_f32(float %x) #0 {
 
 ; CHECK-LABEL: maxnum_f32:
 ; CHECK-NOSP: bl fmaxf
-; CHECK-SP: vmaxnm.f32
+; CHECK-SP-NOV8: bl fmaxf
+; CHECK-SP-V8: vmaxnm.f32
 define float @maxnum_f32(float %x, float %y) #0 {
   %val = call float @llvm.experimental.constrained.maxnum.f32(float %x, float %y, metadata !"fpexcept.strict") #0
   ret float %val
@@ -187,7 +194,8 @@ define float @maxnum_f32(float %x, float %y) #0 {
 
 ; CHECK-LABEL: minnum_f32:
 ; CHECK-NOSP: bl fminf
-; CHECK-SP: vminnm.f32
+; CHECK-SP-NOV8: bl fminf
+; CHECK-SP-V8: vminnm.f32
 define float @minnum_f32(float %x, float %y) #0 {
   %val = call float @llvm.experimental.constrained.minnum.f32(float %x, float %y, metadata !"fpexcept.strict") #0
   ret float %val
@@ -195,7 +203,8 @@ define float @minnum_f32(float %x, float %y) #0 {
 
 ; CHECK-LABEL: ceil_f32:
 ; CHECK-NOSP: bl ceilf
-; CHECK-SP: vrintp.f32
+; CHECK-SP-NOV8: bl ceilf
+; CHECK-SP-V8: vrintp.f32
 define float @ceil_f32(float %x) #0 {
   %val = call float @llvm.experimental.constrained.ceil.f32(float %x, metadata !"fpexcept.strict") #0
   ret float %val
@@ -203,7 +212,8 @@ define float @ceil_f32(float %x) #0 {
 
 ; CHECK-LABEL: floor_f32:
 ; CHECK-NOSP: bl floorf
-; CHECK-SP: vrintm.f32
+; CHECK-SP-NOV8: bl floorf
+; CHECK-SP-V8: vrintm.f32
 define float @floor_f32(float %x) #0 {
   %val = call float @llvm.experimental.constrained.floor.f32(float %x, metadata !"fpexcept.strict") #0
   ret float %val
@@ -225,7 +235,8 @@ define i32 @llround_f32(float %x) #0 {
 
 ; CHECK-LABEL: round_f32:
 ; CHECK-NOSP: bl roundf
-; CHECK-SP: vrinta.f32
+; CHECK-SP-NOV8: bl roundf
+; CHECK-SP-V8: vrinta.f32
 define float @round_f32(float %x) #0 {
   %val = call float @llvm.experimental.constrained.round.f32(float %x, metadata !"fpexcept.strict") #0
   ret float %val
@@ -233,7 +244,8 @@ define float @round_f32(float %x) #0 {
 
 ; CHECK-LABEL: trunc_f32:
 ; CHECK-NOSP: bl truncf
-; CHECK-SP: vrintz.f32
+; CHECK-SP-NOV8: bl truncf
+; CHECK-SP-V8: vrintz.f32
 define float @trunc_f32(float %x) #0 {
   %val = call float @llvm.experimental.constrained.trunc.f32(float %x, metadata !"fpexcept.strict") #0
   ret float %val
@@ -598,7 +610,8 @@ define double @exp2_f64(double %x) #0 {
 
 ; CHECK-LABEL: rint_f64:
 ; CHECK-NODP: bl rint
-; CHECK-DP: vrintx.f64
+; CHECK-DP-NOV8: bl rint
+; CHECK-DP-V8: vrintx.f64
 define double @rint_f64(double %x) #0 {
   %val = call double @llvm.experimental.constrained.rint.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret double %val
@@ -606,7 +619,8 @@ define double @rint_f64(double %x) #0 {
 
 ; CHECK-LABEL: nearbyint_f64:
 ; CHECK-NODP: bl nearbyint
-; CHECK-DP: vrintr.f64
+; CHECK-DP-NOV8: bl nearbyint
+; CHECK-DP-V8: vrintr.f64
 define double @nearbyint_f64(double %x) #0 {
   %val = call double @llvm.experimental.constrained.nearbyint.f64(double %x, metadata !"round.tonearest", metadata !"fpexcept.strict") #0
   ret double %val
@@ -628,7 +642,8 @@ define i32 @llrint_f64(double %x) #0 {
 
 ; CHECK-LABEL: maxnum_f64:
 ; CHECK-NODP: bl fmax
-; CHECK-DP: vmaxnm.f64
+; CHECK-DP-NOV8: bl fmax
+; CHECK-DP-V8: vmaxnm.f64
 define double @maxnum_f64(double %x, double %y) #0 {
   %val = call double @llvm.experimental.constrained.maxnum.f64(double %x, double %y, metadata !"fpexcept.strict") #0
   ret double %val
@@ -636,7 +651,8 @@ define double @maxnum_f64(double %x, double %y) #0 {
 
 ; CHECK-LABEL: minnum_f64:
 ; CHECK-NODP: bl fmin
-; CHECK-DP: vminnm.f64
+; CHECK-DP-NOV8: bl fmin
+; CHECK-DP-V8: vminnm.f64
 define double @minnum_f64(double %x, double %y) #0 {
   %val = call double @llvm.experimental.constrained.minnum.f64(double %x, double %y, metadata !"fpexcept.strict") #0
   ret double %val
@@ -644,7 +660,8 @@ define double @minnum_f64(double %x, double %y) #0 {
 
 ; CHECK-LABEL: ceil_f64:
 ; CHECK-NODP: bl ceil
-; CHECK-DP: vrintp.f64
+; CHECK-DP-NOV8: bl ceil
+; CHECK-DP-V8: vrintp.f64
 define double @ceil_f64(double %x) #0 {
   %val = call double @llvm.experimental.constrained.ceil.f64(double %x, metadata !"fpexcept.strict") #0
   ret double %val
@@ -652,7 +669,8 @@ define double @ceil_f64(double %x) #0 {
 
 ; CHECK-LABEL: floor_f64:
 ; CHECK-NODP: bl floor
-; CHECK-DP: vrintm.f64
+; CHECK-DP-NOV8: bl floor
+; CHECK-DP-V8: vrintm.f64
 define double @floor_f64(double %x) #0 {
   %val = call double @llvm.experimental.constrained.floor.f64(double %x, metadata !"fpexcept.strict") #0
   ret double %val
@@ -674,7 +692,8 @@ define i32 @llround_f64(double %x) #0 {
 
 ; CHECK-LABEL: round_f64:
 ; CHECK-NODP: bl round
-; CHECK-DP: vrinta.f64
+; CHECK-DP-NOV8: bl round
+; CHECK-DP-V8: vrinta.f64
 define double @round_f64(double %x) #0 {
   %val = call double @llvm.experimental.constrained.round.f64(double %x, metadata !"fpexcept.strict") #0
   ret double %val
@@ -682,7 +701,8 @@ define double @round_f64(double %x) #0 {
 
 ; CHECK-LABEL: trunc_f64:
 ; CHECK-NODP: bl trunc
-; CHECK-DP: vrintz.f64
+; CHECK-DP-NOV8: bl trunc
+; CHECK-DP-V8: vrintz.f64
 define double @trunc_f64(double %x) #0 {
   %val = call double @llvm.experimental.constrained.trunc.f64(double %x, metadata !"fpexcept.strict") #0
   ret double %val

commit b5d9a7e72fafaead89f0cc8994925c90ed3169be
Author: Diogo Sampaio <diogo.sampaio@arm.com>
Date:   Sat Feb 15 05:05:15 2020 +0000

    [AArch64][FPenv] Update chain of int to fp conversion
    
    Summary:
    When using strict fp, it is required to update the
    chain when performing integer type promotion of a
    operand to a integer to floating point conversion.
    
    Reviewers: craig.topper, john.brawn
    
    Reviewed By: craig.topper
    
    Subscribers: kristof.beyls, hiraditya, llvm-commits
    
    Tags: #llvm
    
    Differential Revision: https://reviews.llvm.org/D74597
    
    (cherry picked from commit 8bc790f9e6a6fc6d8fe8f41a7120269366fa0957)

diff --git a/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp b/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp
index 0e46f8d68f8..6aed5796acc 100644
--- a/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp
+++ b/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp
@@ -1233,7 +1233,6 @@ bool DAGTypeLegalizer::PromoteIntegerOperand(SDNode *N, unsigned OpNo) {
   LLVM_DEBUG(dbgs() << "Promote integer operand: "; N->dump(&DAG);
              dbgs() << "\n");
   SDValue Res = SDValue();
-
   if (CustomLowerNode(N, N->getOperand(OpNo).getValueType(), false)) {
     LLVM_DEBUG(dbgs() << "Node has been custom lowered, done\n");
     return false;
@@ -1330,10 +1329,17 @@ bool DAGTypeLegalizer::PromoteIntegerOperand(SDNode *N, unsigned OpNo) {
   if (Res.getNode() == N)
     return true;
 
-  assert(Res.getValueType() == N->getValueType(0) && N->getNumValues() == 1 &&
+  const bool IsStrictFp = N->isStrictFPOpcode();
+  assert(Res.getValueType() == N->getValueType(0) &&
+         N->getNumValues() == (IsStrictFp ? 2 : 1) &&
          "Invalid operand expansion");
+  LLVM_DEBUG(dbgs() << "Replacing: "; N->dump(&DAG); dbgs() << "     with: ";
+             Res.dump());
 
   ReplaceValueWith(SDValue(N, 0), Res);
+  if (IsStrictFp)
+    ReplaceValueWith(SDValue(N, 1), SDValue(Res.getNode(), 1));
+
   return false;
 }
 
diff --git a/llvm/test/CodeGen/AArch64/strict-fp-int-promote.ll b/llvm/test/CodeGen/AArch64/strict-fp-int-promote.ll
new file mode 100644
index 00000000000..296f058d192
--- /dev/null
+++ b/llvm/test/CodeGen/AArch64/strict-fp-int-promote.ll
@@ -0,0 +1,67 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -O0 -o - %s | FileCheck %s
+; RUN: llc -O3 -o - %s | FileCheck %s --check-prefix=SUBOPTIMAL
+target datalayout = "e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128"
+target triple = "aarch64-arm-none-eabi"
+
+declare float @llvm.experimental.constrained.sitofp.f32.i32(i32, metadata, metadata)
+declare float @llvm.experimental.constrained.sitofp.f32.i16(i16, metadata, metadata)
+declare i1 @llvm.experimental.constrained.fcmp.f32(float, float, metadata, metadata)
+declare float @llvm.experimental.constrained.uitofp.f32.i16(i16, metadata, metadata)
+
+define i32 @test() #0 {
+; CHECK-LABEL: test:
+; CHECK:       // %bb.0: // %entry
+; CHECK-NEXT:    mov w8, #1
+; CHECK-NEXT:    scvtf s0, w8
+; CHECK-NEXT:    fcmp s0, s0
+; CHECK-NEXT:    cset w0, eq
+; CHECK-NEXT:    ret
+;
+; SUBOPTIMAL-LABEL: test:
+; SUBOPTIMAL:       // %bb.0: // %entry
+; SUBOPTIMAL-NEXT:    mov w8, #1
+; SUBOPTIMAL-NEXT:    scvtf s0, w8
+; SUBOPTIMAL-NEXT:    mov w8, #1
+; SUBOPTIMAL-NEXT:    scvtf s1, w8
+; SUBOPTIMAL-NEXT:    fcmp s0, s1
+; SUBOPTIMAL-NEXT:    cset w8, eq
+; SUBOPTIMAL-NEXT:    and w0, w8, #0x1
+; SUBOPTIMAL-NEXT:    ret
+entry:
+  %conv = call float @llvm.experimental.constrained.sitofp.f32.i32(i32 1, metadata !"round.tonearest", metadata !"fpexcept.strict")
+  %conv1 = call float @llvm.experimental.constrained.sitofp.f32.i16(i16 1, metadata !"round.tonearest", metadata !"fpexcept.strict")
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %conv, float %conv1, metadata !"oeq", metadata !"fpexcept.strict")
+  %conv2 = zext i1 %cmp to i32
+  ret i32 %conv2
+}
+
+define i32 @test2() #0 {
+; CHECK-LABEL: test2:
+; CHECK:       // %bb.0: // %entry
+; CHECK-NEXT:    mov w8, #1
+; CHECK-NEXT:    scvtf s0, w8
+; CHECK-NEXT:    ucvtf s1, w8
+; CHECK-NEXT:    fcmp s0, s1
+; CHECK-NEXT:    cset w0, eq
+; CHECK-NEXT:    ret
+;
+; SUBOPTIMAL-LABEL: test2:
+; SUBOPTIMAL:       // %bb.0: // %entry
+; SUBOPTIMAL-NEXT:    mov w8, #1
+; SUBOPTIMAL-NEXT:    scvtf s0, w8
+; SUBOPTIMAL-NEXT:    mov w8, #1
+; SUBOPTIMAL-NEXT:    ucvtf s1, w8
+; SUBOPTIMAL-NEXT:    fcmp s0, s1
+; SUBOPTIMAL-NEXT:    cset w8, eq
+; SUBOPTIMAL-NEXT:    and w0, w8, #0x1
+; SUBOPTIMAL-NEXT:    ret
+entry:
+  %conv = call float @llvm.experimental.constrained.sitofp.f32.i32(i32 1, metadata !"round.tonearest", metadata !"fpexcept.strict")
+  %conv1 = call float @llvm.experimental.constrained.uitofp.f32.i16(i16 1, metadata !"round.tonearest", metadata !"fpexcept.strict")
+  %cmp = call i1 @llvm.experimental.constrained.fcmp.f32(float %conv, float %conv1, metadata !"oeq", metadata !"fpexcept.strict")
+  %conv2 = zext i1 %cmp to i32
+  ret i32 %conv2
+}
+
+attributes #0 = { noinline optnone }

commit f636e9feb9f0969e3b563d3140db5a0faa1e30d8
Author: John Brawn <john.brawn@arm.com>
Date:   Mon Feb 17 16:55:32 2020 +0000

    [FPEnv][ARM] Don't call mutateStrictFPToFP when lowering
    
    mutateStrictFPToFP can delete the node and replace it with another with the same
    value which can later cause problems, and returning the result of
    mutateStrictFPToFP doesn't work because SelectionDAGLegalize expects that the
    returned value has the same number of results as the original. Instead handle
    things by doing the mutation manually.
    
    Differential Revision: https://reviews.llvm.org/D74726
    
    (cherry picked from commit 594a89f7270da74c89f2321432bc6a7135773fa5)

diff --git a/llvm/lib/Target/ARM/ARMISelLowering.cpp b/llvm/lib/Target/ARM/ARMISelLowering.cpp
index 559a4e8435c..2f836a60a9e 100644
--- a/llvm/lib/Target/ARM/ARMISelLowering.cpp
+++ b/llvm/lib/Target/ARM/ARMISelLowering.cpp
@@ -5421,7 +5421,12 @@ SDValue ARMTargetLowering::LowerFP_TO_INT(SDValue Op, SelectionDAG &DAG) const {
 
   // FIXME: Remove this when we have strict fp instruction selection patterns
   if (IsStrict) {
-    DAG.mutateStrictFPToFP(Op.getNode());
+    SDLoc Loc(Op);
+    SDValue Result =
+        DAG.getNode(Op.getOpcode() == ISD::STRICT_FP_TO_SINT ? ISD::FP_TO_SINT
+                                                             : ISD::FP_TO_UINT,
+                    Loc, Op.getValueType(), SrcVal);
+    return DAG.getMergeValues({Result, Op.getOperand(0)}, Loc);
   }
 
   return Op;
@@ -16384,7 +16389,10 @@ SDValue ARMTargetLowering::LowerFP_EXTEND(SDValue Op, SelectionDAG &DAG) const {
   if (SrcSz == 32 && DstSz == 64 && Subtarget->hasFP64()) {
     // FIXME: Remove this when we have strict fp instruction selection patterns
     if (IsStrict) {
-      DAG.mutateStrictFPToFP(Op.getNode());
+      SDLoc Loc(Op);
+      SDValue Result = DAG.getNode(ISD::FP_EXTEND,
+                                   Loc, Op.getValueType(), SrcVal);
+      return DAG.getMergeValues({Result, Op.getOperand(0)}, Loc);
     }
     return Op;
   }
diff --git a/llvm/test/CodeGen/ARM/fp-intrinsics.ll b/llvm/test/CodeGen/ARM/fp-intrinsics.ll
index c5746ef7b30..5b81982f652 100644
--- a/llvm/test/CodeGen/ARM/fp-intrinsics.ll
+++ b/llvm/test/CodeGen/ARM/fp-intrinsics.ll
@@ -72,6 +72,21 @@ define i32 @fptosi_f32(float %x) #0 {
   ret i32 %val
 }
 
+; CHECK-LABEL: fptosi_f32_twice:
+; CHECK-NOSP: bl __aeabi_f2iz
+; CHECK-NOSP: bl __aeabi_f2iz
+; CHECK-SP: vcvt.s32.f32
+; FIXME-CHECK-SP: vcvt.s32.f32
+define void @fptosi_f32_twice(float %arg, i32* %ptr) #0 {
+entry:
+  %conv = call i32 @llvm.experimental.constrained.fptosi.f32(float %arg, metadata !"fpexcept.strict") #0
+  store i32 %conv, i32* %ptr, align 4
+  %conv1 = call i32 @llvm.experimental.constrained.fptosi.f32(float %arg, metadata !"fpexcept.strict") #0
+  %idx = getelementptr inbounds i32, i32* %ptr, i32 1
+  store i32 %conv1, i32* %idx, align 4
+  ret void
+}
+
 ; CHECK-LABEL: fptoui_f32:
 ; CHECK-NOSP: bl __aeabi_f2uiz
 ; FIXME-CHECK-SP: vcvt.u32.f32
@@ -80,6 +95,21 @@ define i32 @fptoui_f32(float %x) #0 {
   ret i32 %val
 }
 
+; CHECK-LABEL: fptoui_f32_twice:
+; CHECK-NOSP: bl __aeabi_f2uiz
+; CHECK-NOSP: bl __aeabi_f2uiz
+; FIXME-CHECK-SP: vcvt.u32.f32
+; FIXME-CHECK-SP: vcvt.u32.f32
+define void @fptoui_f32_twice(float %arg, i32* %ptr) #0 {
+entry:
+  %conv = call i32 @llvm.experimental.constrained.fptoui.f32(float %arg, metadata !"fpexcept.strict") #0
+  store i32 %conv, i32* %ptr, align 4
+  %conv1 = call i32 @llvm.experimental.constrained.fptoui.f32(float %arg, metadata !"fpexcept.strict") #0
+  %idx = getelementptr inbounds i32, i32* %ptr, i32 1
+  store i32 %conv1, i32* %idx, align 4
+  ret void
+}
+
 ; CHECK-LABEL: sqrt_f32:
 ; CHECK-NOSP: bl sqrtf
 ; CHECK-SP: vsqrt.f32
@@ -947,6 +977,21 @@ define double @fpext_f32(float %x) #0 {
   ret double %val
 }
 
+; CHECK-LABEL: fpext_f32_twice:
+; CHECK-NODP: bl __aeabi_f2d
+; CHECK-NODP: bl __aeabi_f2d
+; CHECK-DP: vcvt.f64.f32
+; FIXME-CHECK-DP: vcvt.f64.f32
+define void @fpext_f32_twice(float %arg, double* %ptr) #0 {
+entry:
+  %conv1 = call double @llvm.experimental.constrained.fpext.f64.f32(float %arg, metadata !"fpexcept.strict") #0
+  store double %conv1, double* %ptr, align 8
+  %conv2 = call double @llvm.experimental.constrained.fpext.f64.f32(float %arg, metadata !"fpexcept.strict") #0
+  %idx = getelementptr inbounds double, double* %ptr, i32 1
+  store double %conv2, double* %idx, align 8
+  ret void
+}
+
 ; CHECK-LABEL: sitofp_f32_i32:
 ; CHECK-NOSP: bl __aeabi_i2f
 ; FIXME-CHECK-SP: vcvt.f32.s32

commit 8dbe13ff509c60dececd9d93f7ffe86c5c4456a0
Author: Sergej Jaskiewicz <jaskiewiczs@icloud.com>
Date:   Tue Jan 21 19:40:34 2020 +0300

    [libcxx] Support Python 3.8 in the test suite
    
    Summary: `platform.linux_distribution()` has been deprecated in Python 3.5 and removed in Python 3.8.
    
    Reviewers: bcain, bcraig, jroelofs, EricWF, mclow.lists, ldionne
    
    Reviewed By: jroelofs
    
    Subscribers: dexonsmith, christof, ldionne, libcxx-commits
    
    Tags: #libc
    
    Differential Revision: https://reviews.llvm.org/D72501
    
    (cherry picked from commit 7b8dc8c57697e95fd0b1248e4494ecc0f929aba1)

diff --git a/libcxx/utils/libcxx/test/target_info.py b/libcxx/utils/libcxx/test/target_info.py
index d622daa2a87..fa57a2c7485 100644
--- a/libcxx/utils/libcxx/test/target_info.py
+++ b/libcxx/utils/libcxx/test/target_info.py
@@ -207,15 +207,25 @@ class LinuxLocalTI(DefaultTargetInfo):
     def platform(self):
         return 'linux'
 
+    def _distribution(self):
+        try:
+            # linux_distribution is not available since Python 3.8
+            # However, this function is only used to detect SLES 11,
+            # which is quite an old distribution that doesn't have
+            # Python 3.8.
+            return platform.linux_distribution()
+        except AttributeError:
+            return '', '', ''
+
     def platform_name(self):
-        name, _, _ = platform.linux_distribution()
+        name, _, _ = self._distribution()
         # Some distros have spaces, e.g. 'SUSE Linux Enterprise Server'
         # lit features can't have spaces
         name = name.lower().strip().replace(' ', '-')
         return name # Permitted to be None
 
     def platform_ver(self):
-        _, ver, _ = platform.linux_distribution()
+        _, ver, _ = self._distribution()
         ver = ver.lower().strip().replace(' ', '-')
         return ver # Permitted to be None.
 

commit cd5006d09d0e646b3aaab7bf5ad21407574f93c0
Author: Richard Smith <richard@metafoo.co.uk>
Date:   Sat Feb 15 02:15:26 2020 -0800

    PR44890: Inherit explicitly-specified template arguments into base class
    deduction.
    
    (cherry picked from commit 34bd51f4b1d9f489e61becb662bdc72bb56dd277)

diff --git a/clang/include/clang/Sema/TemplateDeduction.h b/clang/include/clang/Sema/TemplateDeduction.h
index f787c2689d8..c0af9f3260b 100644
--- a/clang/include/clang/Sema/TemplateDeduction.h
+++ b/clang/include/clang/Sema/TemplateDeduction.h
@@ -67,6 +67,13 @@ public:
   TemplateDeductionInfo(const TemplateDeductionInfo &) = delete;
   TemplateDeductionInfo &operator=(const TemplateDeductionInfo &) = delete;
 
+  enum ForBaseTag { ForBase };
+  /// Create temporary template deduction info for speculatively deducing
+  /// against a base class of an argument's type.
+  TemplateDeductionInfo(ForBaseTag, const TemplateDeductionInfo &Info)
+      : Deduced(Info.Deduced), Loc(Info.Loc), DeducedDepth(Info.DeducedDepth),
+        ExplicitArgs(Info.ExplicitArgs) {}
+
   /// Returns the location at which template argument is
   /// occurring.
   SourceLocation getLocation() const {
diff --git a/clang/lib/Sema/SemaTemplateDeduction.cpp b/clang/lib/Sema/SemaTemplateDeduction.cpp
index 6b865a601f9..1e321d63791 100644
--- a/clang/lib/Sema/SemaTemplateDeduction.cpp
+++ b/clang/lib/Sema/SemaTemplateDeduction.cpp
@@ -1818,7 +1818,7 @@ DeduceTemplateArgumentsByTypeMatch(Sema &S,
         // If this is a base class, try to perform template argument
         // deduction from it.
         if (NextT != RecordT) {
-          TemplateDeductionInfo BaseInfo(Info.getLocation());
+          TemplateDeductionInfo BaseInfo(TemplateDeductionInfo::ForBase, Info);
           Sema::TemplateDeductionResult BaseResult =
               DeduceTemplateArguments(S, TemplateParams, SpecParam,
                                       QualType(NextT, 0), BaseInfo, Deduced);
diff --git a/clang/test/SemaTemplate/deduction.cpp b/clang/test/SemaTemplate/deduction.cpp
index 7268912dd6c..5218543ab8a 100644
--- a/clang/test/SemaTemplate/deduction.cpp
+++ b/clang/test/SemaTemplate/deduction.cpp
@@ -564,3 +564,20 @@ namespace nested_packs {
   }
 #endif
 }
+
+namespace PR44890 {
+  template<typename ...Ts>
+    struct tuple {};
+
+  template<int I, typename ...Ts>
+    int get0(const tuple<Ts...> &t) { return 0; }
+
+  template<typename ...Ts> struct tuple_wrapper : tuple<Ts...> {
+    template<int I> int get() { return get0<0, Ts...>(*this); }
+  };
+
+  int f() {
+    tuple_wrapper<int> w;
+    return w.get<0>();
+  }
+}

commit 3dee8be1c3fe621b9c1926658f6c0df72ce804be
Author: Cristian Adam <cristian.adam@gmail.com>
Date:   Tue Feb 18 14:42:19 2020 +0200

    llvm: Use quotes around MSVC_DIA_SDK_DIR CMake variable
    
    MSVC_DIA_SDK_DIR variable will point to a path which contains spaces,
    and without quotes it will fail to configure the project.
    
    (cherry picked from commit d6fe253653b7e760f94ca21d0a7ebbfeeee28777)

diff --git a/llvm/cmake/config-ix.cmake b/llvm/cmake/config-ix.cmake
index a16038f7098..fc66dbfcbe7 100644
--- a/llvm/cmake/config-ix.cmake
+++ b/llvm/cmake/config-ix.cmake
@@ -469,7 +469,7 @@ if( MSVC )
   # though that we should handle it.  We do so by simply checking that
   # the DIA SDK folder exists.  Should this happen you will need to
   # uninstall VS 2012 and then re-install VS 2013.
-  if (IS_DIRECTORY ${MSVC_DIA_SDK_DIR})
+  if (IS_DIRECTORY "${MSVC_DIA_SDK_DIR}")
     set(HAVE_DIA_SDK 1)
   else()
     set(HAVE_DIA_SDK 0)

commit 8de07c31c1aafa848f515d721e6cf065a0701e81
Author: Nico Weber <thakis@chromium.org>
Date:   Mon Feb 3 14:16:52 2020 -0500

    Fix a -Wbitwise-conditional-parentheses warning in _LIBUNWIND_ARM_EHABI libunwind builds
    
    ```
    src/UnwindCursor.hpp:1344:51: error: operator '?:' has lower precedence than '|';
        '|' will be evaluated first [-Werror,-Wbitwise-conditional-parentheses]
      _info.flags = isSingleWordEHT ? 1 : 0 | scope32 ? 0x2 : 0;  // Use enum?
                                          ~~~~~~~~~~~ ^
    src/UnwindCursor.hpp:1344:51: note: place parentheses around the '|' expression
        to silence this warning
      _info.flags = isSingleWordEHT ? 1 : 0 | scope32 ? 0x2 : 0;  // Use enum?
                                                      ^
                                          (          )
    src/UnwindCursor.hpp:1344:51: note: place parentheses around the '?:' expression
        to evaluate it first
      _info.flags = isSingleWordEHT ? 1 : 0 | scope32 ? 0x2 : 0;  // Use enum?
                                                      ^
                                              (                )
    ```
    
    But `0 |` is a no-op for either of those two interpretations, so I think
    what was meant here was
    
    ```
      _info.flags = (isSingleWordEHT ? 1 : 0) | (scope32 ? 0x2 : 0);  // Use enum?
    ```
    
    Previously, if `isSingleWordEHT` was set, bit 2 would never be set. Now
    it is. From what I can tell, the only thing that checks these bitmask is
    ProcessDescriptors in Unwind-EHABI.cpp, and that only cares about bit 1,
    so in practice this shouldn't have much of an effect.
    
    Differential Revision: https://reviews.llvm.org/D73890
    
    (cherry picked from commit 221c5af4e4f4a504a4d1f352dd7b76d305e56a62)

diff --git a/libunwind/src/UnwindCursor.hpp b/libunwind/src/UnwindCursor.hpp
index 31be8366d23..e7fb70cc571 100644
--- a/libunwind/src/UnwindCursor.hpp
+++ b/libunwind/src/UnwindCursor.hpp
@@ -1353,7 +1353,8 @@ bool UnwindCursor<A, R>::getInfoFromEHABISection(
 
   // If the high bit is set, the exception handling table entry is inline inside
   // the index table entry on the second word (aka |indexDataAddr|). Otherwise,
-  // the table points at an offset in the exception handling table (section 5 EHABI).
+  // the table points at an offset in the exception handling table (section 5
+  // EHABI).
   pint_t exceptionTableAddr;
   uint32_t exceptionTableData;
   bool isSingleWordEHT;
@@ -1452,7 +1453,7 @@ bool UnwindCursor<A, R>::getInfoFromEHABISection(
   _info.unwind_info = exceptionTableAddr;
   _info.lsda = lsda;
   // flags is pr_cache.additional. See EHABI #7.2 for definition of bit 0.
-  _info.flags = isSingleWordEHT ? 1 : 0 | scope32 ? 0x2 : 0;  // Use enum?
+  _info.flags = (isSingleWordEHT ? 1 : 0) | (scope32 ? 0x2 : 0);  // Use enum?
 
   return true;
 }

commit 2db1f7f59a276923138d2115dd7bcc5e70479b9c
Author: Dimitry Andric <dimitry@andric.com>
Date:   Sun Feb 16 01:47:12 2020 +0100

    Restore functionality of --sysroot on FreeBSD after b18cb9c47
    
    After b18cb9c47, clang would sometimes prefer the host C++ includes
    (e.g. in /usr/include/c++/v1) before those specified via --sysroot.
    While this behavior may be desirable on Linux, it is not so on FreeBSD,
    where we make extensive use of --sysroot during the build of the base
    system.  In that case, clang must *not* search outside the sysroot,
    except for its own internal headers.
    
    Add an override addLibCxxIncludePaths() to restore the old behavior,
    which is to simply append /usr/include/c++/v1 to the specified sysroot.
    While here, apply clang-format to the FreeBSD specific toolchain files.
    
    Fixes PR44923.
    
    (cherry picked from commit 62654cab7e654384ba503d6b62b1054cde19a553)

diff --git a/clang/lib/Driver/ToolChains/FreeBSD.cpp b/clang/lib/Driver/ToolChains/FreeBSD.cpp
index c5c6f530f48..6fb4ddd7f50 100644
--- a/clang/lib/Driver/ToolChains/FreeBSD.cpp
+++ b/clang/lib/Driver/ToolChains/FreeBSD.cpp
@@ -99,7 +99,8 @@ void freebsd::Assembler::ConstructJob(Compilation &C, const JobAction &JA,
   case llvm::Triple::sparcel:
   case llvm::Triple::sparcv9: {
     std::string CPU = getCPUName(Args, getToolChain().getTriple());
-    CmdArgs.push_back(sparc::getSparcAsmModeForCPU(CPU, getToolChain().getTriple()));
+    CmdArgs.push_back(
+        sparc::getSparcAsmModeForCPU(CPU, getToolChain().getTriple()));
     AddAssemblerKPIC(getToolChain(), Args, CmdArgs);
     break;
   }
@@ -388,6 +389,12 @@ unsigned FreeBSD::GetDefaultDwarfVersion() const {
   return 4;
 }
 
+void FreeBSD::addLibCxxIncludePaths(const llvm::opt::ArgList &DriverArgs,
+                                    llvm::opt::ArgStringList &CC1Args) const {
+  addSystemInclude(DriverArgs, CC1Args,
+                   getDriver().SysRoot + "/usr/include/c++/v1");
+}
+
 void FreeBSD::addLibStdCxxIncludePaths(
     const llvm::opt::ArgList &DriverArgs,
     llvm::opt::ArgStringList &CC1Args) const {
diff --git a/clang/lib/Driver/ToolChains/FreeBSD.h b/clang/lib/Driver/ToolChains/FreeBSD.h
index 84bdbfd9a31..7e13f48b716 100644
--- a/clang/lib/Driver/ToolChains/FreeBSD.h
+++ b/clang/lib/Driver/ToolChains/FreeBSD.h
@@ -59,16 +59,18 @@ public:
   bool IsObjCNonFragileABIDefault() const override { return true; }
 
   CXXStdlibType GetDefaultCXXStdlibType() const override;
-  void addLibStdCxxIncludePaths(
-      const llvm::opt::ArgList &DriverArgs,
-      llvm::opt::ArgStringList &CC1Args) const override;
+  void addLibCxxIncludePaths(const llvm::opt::ArgList &DriverArgs,
+                             llvm::opt::ArgStringList &CC1Args) const override;
+  void
+  addLibStdCxxIncludePaths(const llvm::opt::ArgList &DriverArgs,
+                           llvm::opt::ArgStringList &CC1Args) const override;
   void AddCXXStdlibLibArgs(const llvm::opt::ArgList &Args,
                            llvm::opt::ArgStringList &CmdArgs) const override;
   void AddCudaIncludeArgs(const llvm::opt::ArgList &DriverArgs,
                           llvm::opt::ArgStringList &CC1Args) const override;
 
-  llvm::ExceptionHandling GetExceptionModel(
-      const llvm::opt::ArgList &Args) const override;
+  llvm::ExceptionHandling
+  GetExceptionModel(const llvm::opt::ArgList &Args) const override;
   bool IsUnwindTablesDefault(const llvm::opt::ArgList &Args) const override;
   bool isPIEDefault() const override;
   SanitizerMask getSupportedSanitizers() const override;

commit be45a5a4092d678c992ac5d32e4b41da9367989a
Author: Clement Courbet <courbet@google.com>
Date:   Wed Feb 19 13:29:22 2020 +0100

    [CodeGen][Tests] Fix b3cf70427eb1e97d9b89ba6e9298c280c8a32c74
    
    Add missing lit.local.cfg in test/Transforms/CodeGenPrepare/PowerPC

diff --git a/llvm/test/Transforms/CodeGenPrepare/PowerPC/lit.local.cfg b/llvm/test/Transforms/CodeGenPrepare/PowerPC/lit.local.cfg
new file mode 100644
index 00000000000..091332439b1
--- /dev/null
+++ b/llvm/test/Transforms/CodeGenPrepare/PowerPC/lit.local.cfg
@@ -0,0 +1,2 @@
+if not 'PowerPC' in config.root.targets:
+    config.unsupported = True

commit a0fe9e0517637c97f4f282bd3b76f2406a6cc1b2
Author: Florian Hahn <flo@fhahn.com>
Date:   Tue Feb 18 17:23:01 2020 +0100

    [SLPVectorizer] Do not assume extracelement idx is a ConstantInt.
    
    The index of an ExtractElementInst is not guaranteed to be a
    ConstantInt. It can be any integer value. Check explicitly for
    ConstantInts.
    
    The new test cases illustrate scenarios where we crash without
    this patch. I've also added another test case to check the matching
    of extractelement vector ops works.
    
    Reviewers: RKSimon, ABataev, dtemirbulatov, vporpo
    
    Reviewed By: ABataev
    
    Differential Revision: https://reviews.llvm.org/D74758
    
    (cherry picked from commit e32522ca178acc42e26f21d64ef8fc180ad772bd)

diff --git a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
index 479bca83b51..26cae4134eb 100644
--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
@@ -832,13 +832,12 @@ public:
 
       // Extracts from consecutive indexes of the same vector better score as
       // the extracts could be optimized away.
-      auto *Ex1 = dyn_cast<ExtractElementInst>(V1);
-      auto *Ex2 = dyn_cast<ExtractElementInst>(V2);
-      if (Ex1 && Ex2 && Ex1->getVectorOperand() == Ex2->getVectorOperand() &&
-          cast<ConstantInt>(Ex1->getIndexOperand())->getZExtValue() + 1 ==
-              cast<ConstantInt>(Ex2->getIndexOperand())->getZExtValue()) {
+      Value *EV;
+      ConstantInt *Ex1Idx, *Ex2Idx;
+      if (match(V1, m_ExtractElement(m_Value(EV), m_ConstantInt(Ex1Idx))) &&
+          match(V2, m_ExtractElement(m_Deferred(EV), m_ConstantInt(Ex2Idx))) &&
+          Ex1Idx->getZExtValue() + 1 == Ex2Idx->getZExtValue())
         return VLOperands::ScoreConsecutiveExtracts;
-      }
 
       auto *I1 = dyn_cast<Instruction>(V1);
       auto *I2 = dyn_cast<Instruction>(V2);
diff --git a/llvm/test/Transforms/SLPVectorizer/X86/lookahead.ll b/llvm/test/Transforms/SLPVectorizer/X86/lookahead.ll
index 4217d730375..75165308959 100644
--- a/llvm/test/Transforms/SLPVectorizer/X86/lookahead.ll
+++ b/llvm/test/Transforms/SLPVectorizer/X86/lookahead.ll
@@ -494,3 +494,153 @@ define void @ChecksExtractScores(double* %storeArray, double* %array, <2 x doubl
   store double %add1, double *%sidx1, align 8
   ret void
 }
+
+
+define i1 @ExtractIdxNotConstantInt1(float %a, float %b, float %c, <4 x float> %vec, i64 %idx2) {
+; CHECK-LABEL: @ExtractIdxNotConstantInt1(
+; CHECK-NEXT:    [[VECEXT_I291_I166:%.*]] = extractelement <4 x float> [[VEC:%.*]], i64 undef
+; CHECK-NEXT:    [[SUB14_I167:%.*]] = fsub float undef, [[VECEXT_I291_I166]]
+; CHECK-NEXT:    [[FM:%.*]] = fmul float [[A:%.*]], [[SUB14_I167]]
+; CHECK-NEXT:    [[SUB25_I168:%.*]] = fsub float [[FM]], [[B:%.*]]
+; CHECK-NEXT:    [[VECEXT_I276_I169:%.*]] = extractelement <4 x float> [[VEC]], i64 [[IDX2:%.*]]
+; CHECK-NEXT:    [[ADD36_I173:%.*]] = fadd float [[SUB25_I168]], 1.000000e+01
+; CHECK-NEXT:    [[MUL72_I179:%.*]] = fmul float [[C:%.*]], [[VECEXT_I276_I169]]
+; CHECK-NEXT:    [[ADD78_I180:%.*]] = fsub float [[MUL72_I179]], 3.000000e+01
+; CHECK-NEXT:    [[ADD79_I181:%.*]] = fadd float 2.000000e+00, [[ADD78_I180]]
+; CHECK-NEXT:    [[MUL123_I184:%.*]] = fmul float [[ADD36_I173]], [[ADD79_I181]]
+; CHECK-NEXT:    [[CMP_I185:%.*]] = fcmp ogt float [[MUL123_I184]], 0.000000e+00
+; CHECK-NEXT:    ret i1 [[CMP_I185]]
+;
+  %vecext.i291.i166 = extractelement <4 x float> %vec, i64 undef
+  %sub14.i167 = fsub float undef, %vecext.i291.i166
+  %fm = fmul float %a, %sub14.i167
+  %sub25.i168 = fsub float %fm, %b
+  %vecext.i276.i169 = extractelement <4 x float> %vec, i64 %idx2
+  %add36.i173 = fadd float %sub25.i168, 10.0
+  %mul72.i179 = fmul float %c, %vecext.i276.i169
+  %add78.i180 = fsub float %mul72.i179, 30.0
+  %add79.i181 = fadd float 2.0, %add78.i180
+  %mul123.i184 = fmul float %add36.i173, %add79.i181
+  %cmp.i185 = fcmp ogt float %mul123.i184, 0.000000e+00
+  ret i1 %cmp.i185
+}
+
+
+define i1 @ExtractIdxNotConstantInt2(float %a, float %b, float %c, <4 x float> %vec, i64 %idx2) {
+; CHECK-LABEL: @ExtractIdxNotConstantInt2(
+; CHECK-NEXT:    [[VECEXT_I291_I166:%.*]] = extractelement <4 x float> [[VEC:%.*]], i64 1
+; CHECK-NEXT:    [[SUB14_I167:%.*]] = fsub float undef, [[VECEXT_I291_I166]]
+; CHECK-NEXT:    [[FM:%.*]] = fmul float [[A:%.*]], [[SUB14_I167]]
+; CHECK-NEXT:    [[SUB25_I168:%.*]] = fsub float [[FM]], [[B:%.*]]
+; CHECK-NEXT:    [[VECEXT_I276_I169:%.*]] = extractelement <4 x float> [[VEC]], i64 [[IDX2:%.*]]
+; CHECK-NEXT:    [[ADD36_I173:%.*]] = fadd float [[SUB25_I168]], 1.000000e+01
+; CHECK-NEXT:    [[MUL72_I179:%.*]] = fmul float [[C:%.*]], [[VECEXT_I276_I169]]
+; CHECK-NEXT:    [[ADD78_I180:%.*]] = fsub float [[MUL72_I179]], 3.000000e+01
+; CHECK-NEXT:    [[ADD79_I181:%.*]] = fadd float 2.000000e+00, [[ADD78_I180]]
+; CHECK-NEXT:    [[MUL123_I184:%.*]] = fmul float [[ADD36_I173]], [[ADD79_I181]]
+; CHECK-NEXT:    [[CMP_I185:%.*]] = fcmp ogt float [[MUL123_I184]], 0.000000e+00
+; CHECK-NEXT:    ret i1 [[CMP_I185]]
+;
+  %vecext.i291.i166 = extractelement <4 x float> %vec, i64 1
+  %sub14.i167 = fsub float undef, %vecext.i291.i166
+  %fm = fmul float %a, %sub14.i167
+  %sub25.i168 = fsub float %fm, %b
+  %vecext.i276.i169 = extractelement <4 x float> %vec, i64 %idx2
+  %add36.i173 = fadd float %sub25.i168, 10.0
+  %mul72.i179 = fmul float %c, %vecext.i276.i169
+  %add78.i180 = fsub float %mul72.i179, 30.0
+  %add79.i181 = fadd float 2.0, %add78.i180
+  %mul123.i184 = fmul float %add36.i173, %add79.i181
+  %cmp.i185 = fcmp ogt float %mul123.i184, 0.000000e+00
+  ret i1 %cmp.i185
+}
+
+
+define i1 @foo(float %a, float %b, float %c, <4 x float> %vec, i64 %idx2) {
+; CHECK-LABEL: @foo(
+; CHECK-NEXT:    [[VECEXT_I291_I166:%.*]] = extractelement <4 x float> [[VEC:%.*]], i64 0
+; CHECK-NEXT:    [[SUB14_I167:%.*]] = fsub float undef, [[VECEXT_I291_I166]]
+; CHECK-NEXT:    [[FM:%.*]] = fmul float [[A:%.*]], [[SUB14_I167]]
+; CHECK-NEXT:    [[SUB25_I168:%.*]] = fsub float [[FM]], [[B:%.*]]
+; CHECK-NEXT:    [[VECEXT_I276_I169:%.*]] = extractelement <4 x float> [[VEC]], i64 1
+; CHECK-NEXT:    [[ADD36_I173:%.*]] = fadd float [[SUB25_I168]], 1.000000e+01
+; CHECK-NEXT:    [[MUL72_I179:%.*]] = fmul float [[C:%.*]], [[VECEXT_I276_I169]]
+; CHECK-NEXT:    [[ADD78_I180:%.*]] = fsub float [[MUL72_I179]], 3.000000e+01
+; CHECK-NEXT:    [[ADD79_I181:%.*]] = fadd float 2.000000e+00, [[ADD78_I180]]
+; CHECK-NEXT:    [[MUL123_I184:%.*]] = fmul float [[ADD36_I173]], [[ADD79_I181]]
+; CHECK-NEXT:    [[CMP_I185:%.*]] = fcmp ogt float [[MUL123_I184]], 0.000000e+00
+; CHECK-NEXT:    ret i1 [[CMP_I185]]
+;
+  %vecext.i291.i166 = extractelement <4 x float> %vec, i64 0
+  %sub14.i167 = fsub float undef, %vecext.i291.i166
+  %fm = fmul float %a, %sub14.i167
+  %sub25.i168 = fsub float %fm, %b
+  %vecext.i276.i169 = extractelement <4 x float> %vec, i64 1
+  %add36.i173 = fadd float %sub25.i168, 10.0
+  %mul72.i179 = fmul float %c, %vecext.i276.i169
+  %add78.i180 = fsub float %mul72.i179, 30.0
+  %add79.i181 = fadd float 2.0, %add78.i180
+  %mul123.i184 = fmul float %add36.i173, %add79.i181
+  %cmp.i185 = fcmp ogt float %mul123.i184, 0.000000e+00
+  ret i1 %cmp.i185
+}
+
+; Same as @ChecksExtractScores, but the extratelement vector operands do not match.
+define void @ChecksExtractScores_different_vectors(double* %storeArray, double* %array, <2 x double> *%vecPtr1, <2 x double>* %vecPtr2, <2 x double>* %vecPtr3, <2 x double>* %vecPtr4) {
+; CHECK-LABEL: @ChecksExtractScores_different_vectors(
+; CHECK-NEXT:    [[IDX0:%.*]] = getelementptr inbounds double, double* [[ARRAY:%.*]], i64 0
+; CHECK-NEXT:    [[IDX1:%.*]] = getelementptr inbounds double, double* [[ARRAY]], i64 1
+; CHECK-NEXT:    [[TMP1:%.*]] = bitcast double* [[IDX0]] to <2 x double>*
+; CHECK-NEXT:    [[TMP2:%.*]] = load <2 x double>, <2 x double>* [[TMP1]], align 4
+; CHECK-NEXT:    [[LOADVEC:%.*]] = load <2 x double>, <2 x double>* [[VECPTR1:%.*]], align 4
+; CHECK-NEXT:    [[LOADVEC2:%.*]] = load <2 x double>, <2 x double>* [[VECPTR2:%.*]], align 4
+; CHECK-NEXT:    [[EXTRA0:%.*]] = extractelement <2 x double> [[LOADVEC]], i32 0
+; CHECK-NEXT:    [[EXTRA1:%.*]] = extractelement <2 x double> [[LOADVEC2]], i32 1
+; CHECK-NEXT:    [[LOADVEC3:%.*]] = load <2 x double>, <2 x double>* [[VECPTR3:%.*]], align 4
+; CHECK-NEXT:    [[LOADVEC4:%.*]] = load <2 x double>, <2 x double>* [[VECPTR4:%.*]], align 4
+; CHECK-NEXT:    [[EXTRB0:%.*]] = extractelement <2 x double> [[LOADVEC3]], i32 0
+; CHECK-NEXT:    [[EXTRB1:%.*]] = extractelement <2 x double> [[LOADVEC4]], i32 1
+; CHECK-NEXT:    [[TMP3:%.*]] = insertelement <2 x double> undef, double [[EXTRB0]], i32 0
+; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x double> [[TMP3]], double [[EXTRA1]], i32 1
+; CHECK-NEXT:    [[TMP5:%.*]] = extractelement <2 x double> [[TMP2]], i32 1
+; CHECK-NEXT:    [[TMP6:%.*]] = insertelement <2 x double> undef, double [[TMP5]], i32 0
+; CHECK-NEXT:    [[TMP7:%.*]] = extractelement <2 x double> [[TMP2]], i32 0
+; CHECK-NEXT:    [[TMP8:%.*]] = insertelement <2 x double> [[TMP6]], double [[TMP7]], i32 1
+; CHECK-NEXT:    [[TMP9:%.*]] = fmul <2 x double> [[TMP4]], [[TMP8]]
+; CHECK-NEXT:    [[TMP10:%.*]] = insertelement <2 x double> undef, double [[EXTRA0]], i32 0
+; CHECK-NEXT:    [[TMP11:%.*]] = insertelement <2 x double> [[TMP10]], double [[EXTRB1]], i32 1
+; CHECK-NEXT:    [[TMP12:%.*]] = fmul <2 x double> [[TMP11]], [[TMP2]]
+; CHECK-NEXT:    [[TMP13:%.*]] = fadd <2 x double> [[TMP12]], [[TMP9]]
+; CHECK-NEXT:    [[SIDX0:%.*]] = getelementptr inbounds double, double* [[STOREARRAY:%.*]], i64 0
+; CHECK-NEXT:    [[SIDX1:%.*]] = getelementptr inbounds double, double* [[STOREARRAY]], i64 1
+; CHECK-NEXT:    [[TMP14:%.*]] = bitcast double* [[SIDX0]] to <2 x double>*
+; CHECK-NEXT:    store <2 x double> [[TMP13]], <2 x double>* [[TMP14]], align 8
+; CHECK-NEXT:    ret void
+;
+  %idx0 = getelementptr inbounds double, double* %array, i64 0
+  %idx1 = getelementptr inbounds double, double* %array, i64 1
+  %loadA0 = load double, double* %idx0, align 4
+  %loadA1 = load double, double* %idx1, align 4
+
+  %loadVec = load <2 x double>, <2 x double>* %vecPtr1, align 4
+  %loadVec2 = load <2 x double>, <2 x double>* %vecPtr2, align 4
+  %extrA0 = extractelement <2 x double> %loadVec, i32 0
+  %extrA1 = extractelement <2 x double> %loadVec2, i32 1
+  %loadVec3= load <2 x double>, <2 x double>* %vecPtr3, align 4
+  %loadVec4 = load <2 x double>, <2 x double>* %vecPtr4, align 4
+  %extrB0 = extractelement <2 x double> %loadVec3, i32 0
+  %extrB1 = extractelement <2 x double> %loadVec4, i32 1
+
+  %mul0 = fmul double %extrA0, %loadA0
+  %mul1 = fmul double %extrA1, %loadA0
+  %mul3 = fmul double %extrB0, %loadA1
+  %mul4 = fmul double %extrB1, %loadA1
+  %add0 = fadd double %mul0, %mul3
+  %add1 = fadd double %mul1, %mul4
+
+  %sidx0 = getelementptr inbounds double, double* %storeArray, i64 0
+  %sidx1 = getelementptr inbounds double, double* %storeArray, i64 1
+  store double %add0, double *%sidx0, align 8
+  store double %add1, double *%sidx1, align 8
+  ret void
+}

commit 222de784df453659144c6d07b530e7858c980021
Author: Nikita Popov <nikita.ppv@gmail.com>
Date:   Thu Feb 6 21:16:10 2020 +0100

    [X86CmovConversion] Make heuristic for optimized cmov depth more conservative (PR44539)
    
    Fix/workaround for https://bugs.llvm.org/show_bug.cgi?id=44539.
    As discussed there, this pass makes some overly optimistic
    assumptions, as it does not have access to actual branch weights.
    
    This patch makes the computation of the depth of the optimized cmov
    more conservative, by assuming a distribution of 75/25 rather than
    50/50 and placing the weights to get the more conservative result
    (larger depth). The fully conservative choice would be
    std::max(TrueOpDepth, FalseOpDepth), but that would break at least
    one existing test (which may or may not be an issue in practice).
    
    Differential Revision: https://reviews.llvm.org/D74155
    
    (cherry picked from commit 5eb19bf4a2b0c29a8d4d48dfb0276f096eff9bec)

diff --git a/llvm/lib/Target/X86/X86CmovConversion.cpp b/llvm/lib/Target/X86/X86CmovConversion.cpp
index fe43bf4cbbc..fe5cb3ae2bf 100644
--- a/llvm/lib/Target/X86/X86CmovConversion.cpp
+++ b/llvm/lib/Target/X86/X86CmovConversion.cpp
@@ -364,12 +364,13 @@ bool X86CmovConverterPass::collectCmovCandidates(
 /// \param TrueOpDepth depth cost of CMOV true value operand.
 /// \param FalseOpDepth depth cost of CMOV false value operand.
 static unsigned getDepthOfOptCmov(unsigned TrueOpDepth, unsigned FalseOpDepth) {
-  //===--------------------------------------------------------------------===//
-  // With no info about branch weight, we assume 50% for each value operand.
-  // Thus, depth of optimized CMOV instruction is the rounded up average of
-  // its True-Operand-Value-Depth and False-Operand-Value-Depth.
-  //===--------------------------------------------------------------------===//
-  return (TrueOpDepth + FalseOpDepth + 1) / 2;
+  // The depth of the result after branch conversion is
+  // TrueOpDepth * TrueOpProbability + FalseOpDepth * FalseOpProbability.
+  // As we have no info about branch weight, we assume 75% for one and 25% for
+  // the other, and pick the result with the largest resulting depth.
+  return std::max(
+      divideCeil(TrueOpDepth * 3 + FalseOpDepth, 4),
+      divideCeil(FalseOpDepth * 3 + TrueOpDepth, 4));
 }
 
 bool X86CmovConverterPass::checkForProfitableCmovCandidates(

commit d5f8656a68c25e93c5c8f03e0670fecb16609d40
Author: Kadir Cetinkaya <kadircet@google.com>
Date:   Thu Jan 16 11:37:58 2020 +0100

    [clangd] Make output order of allTargetDecls deterministic
    
    Summary:
    Makes use of insertion order to stabilize output for multiple decls.
    
    Fixes https://bugs.llvm.org/show_bug.cgi?id=44564
    
    Reviewers: sammccall
    
    Subscribers: ilya-biryukov, MaskRay, jkorous, mgrang, arphaman, usaxena95, cfe-commits, aemerson
    
    Tags: #clang
    
    Differential Revision: https://reviews.llvm.org/D72826
    
    (cherry picked from commit d54d71b67e602674a255e299a22fe31dee1f3619)

diff --git a/clang-tools-extra/clangd/FindTarget.cpp b/clang-tools-extra/clangd/FindTarget.cpp
index d8ce0b69283..82a2e8c27d5 100644
--- a/clang-tools-extra/clangd/FindTarget.cpp
+++ b/clang-tools-extra/clangd/FindTarget.cpp
@@ -35,6 +35,7 @@
 #include "llvm/Support/Compiler.h"
 #include "llvm/Support/raw_ostream.h"
 #include <utility>
+#include <vector>
 
 namespace clang {
 namespace clangd {
@@ -134,6 +135,35 @@ const Type *getPointeeType(const Type *T) {
   return FirstArg.getAsType().getTypePtrOrNull();
 }
 
+const NamedDecl *getTemplatePattern(const NamedDecl *D) {
+  if (const CXXRecordDecl *CRD = dyn_cast<CXXRecordDecl>(D)) {
+    return CRD->getTemplateInstantiationPattern();
+  } else if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
+    return FD->getTemplateInstantiationPattern();
+  } else if (auto *VD = dyn_cast<VarDecl>(D)) {
+    // Hmm: getTIP returns its arg if it's not an instantiation?!
+    VarDecl *T = VD->getTemplateInstantiationPattern();
+    return (T == D) ? nullptr : T;
+  } else if (const auto *ED = dyn_cast<EnumDecl>(D)) {
+    return ED->getInstantiatedFromMemberEnum();
+  } else if (isa<FieldDecl>(D) || isa<TypedefNameDecl>(D)) {
+    if (const auto *Parent = llvm::dyn_cast<NamedDecl>(D->getDeclContext()))
+      if (const DeclContext *ParentPat =
+              dyn_cast_or_null<DeclContext>(getTemplatePattern(Parent)))
+        for (const NamedDecl *BaseND : ParentPat->lookup(D->getDeclName()))
+          if (!BaseND->isImplicit() && BaseND->getKind() == D->getKind())
+            return BaseND;
+  } else if (const auto *ECD = dyn_cast<EnumConstantDecl>(D)) {
+    if (const auto *ED = dyn_cast<EnumDecl>(ECD->getDeclContext())) {
+      if (const EnumDecl *Pattern = ED->getInstantiatedFromMemberEnum()) {
+        for (const NamedDecl *BaseECD : Pattern->lookup(ECD->getDeclName()))
+          return BaseECD;
+      }
+    }
+  }
+  return nullptr;
+}
+
 // TargetFinder locates the entities that an AST node refers to.
 //
 // Typically this is (possibly) one declaration and (possibly) one type, but
@@ -167,37 +197,12 @@ const Type *getPointeeType(const Type *T) {
 struct TargetFinder {
   using RelSet = DeclRelationSet;
   using Rel = DeclRelation;
-  llvm::SmallDenseMap<const NamedDecl *, RelSet> Decls;
-  RelSet Flags;
 
-  static const NamedDecl *getTemplatePattern(const NamedDecl *D) {
-    if (const CXXRecordDecl *CRD = dyn_cast<CXXRecordDecl>(D)) {
-      return CRD->getTemplateInstantiationPattern();
-    } else if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
-      return FD->getTemplateInstantiationPattern();
-    } else if (auto *VD = dyn_cast<VarDecl>(D)) {
-      // Hmm: getTIP returns its arg if it's not an instantiation?!
-      VarDecl *T = VD->getTemplateInstantiationPattern();
-      return (T == D) ? nullptr : T;
-    } else if (const auto *ED = dyn_cast<EnumDecl>(D)) {
-      return ED->getInstantiatedFromMemberEnum();
-    } else if (isa<FieldDecl>(D) || isa<TypedefNameDecl>(D)) {
-      if (const auto *Parent = llvm::dyn_cast<NamedDecl>(D->getDeclContext()))
-        if (const DeclContext *ParentPat =
-                dyn_cast_or_null<DeclContext>(getTemplatePattern(Parent)))
-          for (const NamedDecl *BaseND : ParentPat->lookup(D->getDeclName()))
-            if (!BaseND->isImplicit() && BaseND->getKind() == D->getKind())
-              return BaseND;
-    } else if (const auto *ECD = dyn_cast<EnumConstantDecl>(D)) {
-      if (const auto *ED = dyn_cast<EnumDecl>(ECD->getDeclContext())) {
-        if (const EnumDecl *Pattern = ED->getInstantiatedFromMemberEnum()) {
-          for (const NamedDecl *BaseECD : Pattern->lookup(ECD->getDeclName()))
-            return BaseECD;
-        }
-      }
-    }
-    return nullptr;
-  }
+private:
+  llvm::SmallDenseMap<const NamedDecl *,
+                      std::pair<RelSet, /*InsertionOrder*/ size_t>>
+      Decls;
+  RelSet Flags;
 
   template <typename T> void debug(T &Node, RelSet Flags) {
     dlog("visit [{0}] {1}", Flags,
@@ -207,10 +212,22 @@ struct TargetFinder {
   void report(const NamedDecl *D, RelSet Flags) {
     dlog("--> [{0}] {1}", Flags,
          nodeToString(ast_type_traits::DynTypedNode::create(*D)));
-    Decls[D] |= Flags;
+    auto It = Decls.try_emplace(D, std::make_pair(Flags, Decls.size()));
+    // If already exists, update the flags.
+    if (!It.second)
+      It.first->second.first |= Flags;
   }
 
 public:
+  llvm::SmallVector<std::pair<const NamedDecl *, RelSet>, 1> takeDecls() const {
+    using ValTy = std::pair<const NamedDecl *, RelSet>;
+    llvm::SmallVector<ValTy, 1> Result;
+    Result.resize(Decls.size());
+    for (const auto &Elem : Decls)
+      Result[Elem.second.second] = {Elem.first, Elem.second.first};
+    return Result;
+  }
+
   void add(const Decl *Dcl, RelSet Flags) {
     const NamedDecl *D = llvm::dyn_cast<NamedDecl>(Dcl);
     if (!D)
@@ -485,7 +502,7 @@ allTargetDecls(const ast_type_traits::DynTypedNode &N) {
   else if (const CXXCtorInitializer *CCI = N.get<CXXCtorInitializer>())
     Finder.add(CCI, Flags);
 
-  return {Finder.Decls.begin(), Finder.Decls.end()};
+  return Finder.takeDecls();
 }
 
 llvm::SmallVector<const NamedDecl *, 1>

commit 7751f0c191518b377d9b71bdd17281abec83945a
Author: Adrian Prantl <aprantl@apple.com>
Date:   Thu Jan 16 14:21:03 2020 -0800

    Add testing for DW_OP_piece and fix a bug with small Scalar values.
    
    By switching to Scalars that are backed by explicitly-sized APInts we
    can avoid a bug that increases the buffer reserved for a small piece
    to the next-largest host integer type.
    
    This manifests as "DW_OP_piece for offset foo but top of stack is of size bar".
    
    Differential Revision: https://reviews.llvm.org/D72879
    
    (cherry picked from commit 7b0d58e339b271e3b1d9dc14b781b57fa0262e3a)

diff --git a/lldb/source/Expression/DWARFExpression.cpp b/lldb/source/Expression/DWARFExpression.cpp
index 69c84640ef9..0f8eea754c2 100644
--- a/lldb/source/Expression/DWARFExpression.cpp
+++ b/lldb/source/Expression/DWARFExpression.cpp
@@ -2128,7 +2128,8 @@ bool DWARFExpression::Evaluate(
           case Value::eValueTypeScalar: {
             uint32_t bit_size = piece_byte_size * 8;
             uint32_t bit_offset = 0;
-            if (!curr_piece_source_value.GetScalar().ExtractBitfield(
+            Scalar &scalar = curr_piece_source_value.GetScalar();
+            if (!scalar.ExtractBitfield(
                     bit_size, bit_offset)) {
               if (error_ptr)
                 error_ptr->SetErrorStringWithFormat(
@@ -2139,7 +2140,14 @@ bool DWARFExpression::Evaluate(
                         .GetByteSize());
               return false;
             }
-            curr_piece = curr_piece_source_value;
+            // Create curr_piece with bit_size. By default Scalar
+            // grows to the nearest host integer type.
+            llvm::APInt fail_value(1, 0, false);
+            llvm::APInt ap_int = scalar.UInt128(fail_value);
+            assert(ap_int.getBitWidth() >= bit_size);
+            llvm::ArrayRef<uint64_t> buf{ap_int.getRawData(),
+                                         ap_int.getNumWords()};
+            curr_piece.GetScalar() = Scalar(llvm::APInt(bit_size, buf));
           } break;
 
           case Value::eValueTypeVector: {
@@ -2161,7 +2169,7 @@ bool DWARFExpression::Evaluate(
           if (op_piece_offset == 0) {
             // This is the first piece, we should push it back onto the stack
             // so subsequent pieces will be able to access this piece and add
-            // to it
+            // to it.
             if (pieces.AppendDataToHostBuffer(curr_piece) == 0) {
               if (error_ptr)
                 error_ptr->SetErrorString("failed to append piece data");
@@ -2169,7 +2177,7 @@ bool DWARFExpression::Evaluate(
             }
           } else {
             // If this is the second or later piece there should be a value on
-            // the stack
+            // the stack.
             if (pieces.GetBuffer().GetByteSize() != op_piece_offset) {
               if (error_ptr)
                 error_ptr->SetErrorStringWithFormat(
diff --git a/lldb/unittests/Expression/DWARFExpressionTest.cpp b/lldb/unittests/Expression/DWARFExpressionTest.cpp
index 8fad88a93e1..fe5e9c957ba 100644
--- a/lldb/unittests/Expression/DWARFExpressionTest.cpp
+++ b/lldb/unittests/Expression/DWARFExpressionTest.cpp
@@ -37,7 +37,22 @@ static llvm::Expected<Scalar> Evaluate(llvm::ArrayRef<uint8_t> expr,
           /*object_address_ptr*/ nullptr, result, &status))
     return status.ToError();
 
-  return result.GetScalar();
+  switch (result.GetValueType()) {
+  case Value::eValueTypeScalar:
+    return result.GetScalar();
+  case Value::eValueTypeHostAddress: {
+    // Convert small buffers to scalars to simplify the tests.
+    DataBufferHeap &buf = result.GetBuffer();
+    if (buf.GetByteSize() <= 8) {
+      uint64_t val = 0;
+      memcpy(&val, buf.GetBytes(), buf.GetByteSize());
+      return Scalar(llvm::APInt(buf.GetByteSize()*8, val, false));
+    }
+  }
+    LLVM_FALLTHROUGH;
+  default:
+    return status.ToError();
+  }
 }
 
 /// A mock module holding an object file parsed from YAML.
@@ -335,3 +350,9 @@ TEST(DWARFExpression, DW_OP_convert) {
       t.Eval({DW_OP_const1s, 'X', DW_OP_convert, 0x1d}).takeError(),
       llvm::Failed());
 }
+
+TEST(DWARFExpression, DW_OP_piece) {
+  EXPECT_THAT_EXPECTED(Evaluate({DW_OP_const2u, 0x11, 0x22, DW_OP_piece, 2,
+                                 DW_OP_const2u, 0x33, 0x44, DW_OP_piece, 2}),
+                       llvm::HasValue(GetScalar(32, 0x44332211, true)));
+}

commit cab81521b5afc2d4295f988aa5f087cbaeefb981
Author: Adrian Prantl <aprantl@apple.com>
Date:   Thu Jan 16 14:21:17 2020 -0800

    Fix a buffer-size bug when the first DW_OP_piece is undefined
    
    and document the shortcomings of LLDB's partially defined DW_OP_piece
    handling.
    
    This would manifest as "DW_OP_piece for offset foo but top of stack is
    of size bar".
    
    rdar://problem/46262998
    
    Differential Revision: https://reviews.llvm.org/D72880
    
    (cherry picked from commit f55ab6f90b7317a6bb85303a6102702bdae1199e)

diff --git a/lldb/source/Expression/DWARFExpression.cpp b/lldb/source/Expression/DWARFExpression.cpp
index 0f8eea754c2..08cc70c201f 100644
--- a/lldb/source/Expression/DWARFExpression.cpp
+++ b/lldb/source/Expression/DWARFExpression.cpp
@@ -2071,6 +2071,10 @@ bool DWARFExpression::Evaluate(
           // not available. Fill with zeros for now by resizing the data and
           // appending it
           curr_piece.ResizeData(piece_byte_size);
+          // Note that "0" is not a correct value for the unknown bits.
+          // It would be better to also return a mask of valid bits together
+          // with the expression result, so the debugger can print missing
+          // members as "<optimized out>" or something.
           ::memset(curr_piece.GetBuffer().GetBytes(), 0, piece_byte_size);
           pieces.AppendDataToHostBuffer(curr_piece);
         } else {
@@ -2193,8 +2197,8 @@ bool DWARFExpression::Evaluate(
               return false;
             }
           }
-          op_piece_offset += piece_byte_size;
         }
+        op_piece_offset += piece_byte_size;
       }
     } break;
 
diff --git a/lldb/unittests/Expression/DWARFExpressionTest.cpp b/lldb/unittests/Expression/DWARFExpressionTest.cpp
index fe5e9c957ba..45876152f02 100644
--- a/lldb/unittests/Expression/DWARFExpressionTest.cpp
+++ b/lldb/unittests/Expression/DWARFExpressionTest.cpp
@@ -355,4 +355,9 @@ TEST(DWARFExpression, DW_OP_piece) {
   EXPECT_THAT_EXPECTED(Evaluate({DW_OP_const2u, 0x11, 0x22, DW_OP_piece, 2,
                                  DW_OP_const2u, 0x33, 0x44, DW_OP_piece, 2}),
                        llvm::HasValue(GetScalar(32, 0x44332211, true)));
+  EXPECT_THAT_EXPECTED(
+      Evaluate({DW_OP_piece, 1, DW_OP_const1u, 0xff, DW_OP_piece, 1}),
+      // Note that the "00" should really be "undef", but we can't
+      // represent that yet.
+      llvm::HasValue(GetScalar(16, 0xff00, true)));
 }

commit 5f76fcc9796e1a68f44a79b7910a199c0db9fe82
Author: Hans Wennborg <hans@chromium.org>
Date:   Wed Feb 12 15:12:31 2020 +0100

    Fix unused function warning (PR44808)
    
    (cherry picked from commit a19de32095e4cdb18957e66609574ce2021a8d1c)

diff --git a/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp b/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp
index 05c81feb23e..c4f511abc4a 100644
--- a/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp
+++ b/llvm/lib/Target/AMDGPU/SIPeepholeSDWA.cpp
@@ -244,11 +244,6 @@ static raw_ostream& operator<<(raw_ostream &OS, const DstUnused &Un) {
   return OS;
 }
 
-static raw_ostream& operator<<(raw_ostream &OS, const SDWAOperand &Operand) {
-  Operand.print(OS);
-  return OS;
-}
-
 LLVM_DUMP_METHOD
 void SDWASrcOperand::print(raw_ostream& OS) const {
   OS << "SDWA src: " << *getTargetOperand()
@@ -850,6 +845,13 @@ SIPeepholeSDWA::matchSDWAOperand(MachineInstr &MI) {
   return std::unique_ptr<SDWAOperand>(nullptr);
 }
 
+#if !defined(NDEBUG)
+static raw_ostream& operator<<(raw_ostream &OS, const SDWAOperand &Operand) {
+  Operand.print(OS);
+  return OS;
+}
+#endif
+
 void SIPeepholeSDWA::matchSDWAOperands(MachineBasicBlock &MBB) {
   for (MachineInstr &MI : MBB) {
     if (auto Operand = matchSDWAOperand(MI)) {

commit 5175565cf154aede57354336102a7f6e15a16a20
Author: Richard Smith <richard@metafoo.co.uk>
Date:   Tue Feb 18 16:13:23 2020 -0800

    Add -std=c++20 flag, replace C++2a with C++20 throughout the Clang
    user interface and documentation, and update __cplusplus for C++20.
    
    WG21 considers the C++20 standard to be finished (even though it still
    has some more steps to pass through in the ISO process).
    
    The old flag names are accepted for compatibility, as usual, and we
    still have lots of references to C++2a in comments and identifiers;
    those can be cleaned up separately.
    
    (cherry picked from commit 24ad121582454e625bdad125c90d9ac0dae948c8)

diff --git a/clang/docs/LanguageExtensions.rst b/clang/docs/LanguageExtensions.rst
index f1df9dd93f9..456bcb305e3 100644
--- a/clang/docs/LanguageExtensions.rst
+++ b/clang/docs/LanguageExtensions.rst
@@ -122,7 +122,7 @@ of ``cxx_rvalue_references``.
 ``__has_cpp_attribute``
 -----------------------
 
-This function-like macro is available in C++2a by default, and is provided as an
+This function-like macro is available in C++20 by default, and is provided as an
 extension in earlier language standards. It takes a single argument that is the
 name of a double-square-bracket-style attribute. The argument can either be a
 single identifier or a scoped identifier. If the attribute is supported, a
diff --git a/clang/include/clang/Basic/DiagnosticASTKinds.td b/clang/include/clang/Basic/DiagnosticASTKinds.td
index 95505b00344..a0c15ba1cb0 100644
--- a/clang/include/clang/Basic/DiagnosticASTKinds.td
+++ b/clang/include/clang/Basic/DiagnosticASTKinds.td
@@ -13,7 +13,7 @@ def note_expr_divide_by_zero : Note<"division by zero">;
 def note_constexpr_invalid_cast : Note<
   "%select{reinterpret_cast|dynamic_cast|cast that performs the conversions of"
   " a reinterpret_cast|cast from %1}0 is not allowed in a constant expression"
-  "%select{| in C++ standards before C++2a||}0">;
+  "%select{| in C++ standards before C++20||}0">;
 def note_constexpr_invalid_downcast : Note<
   "cannot cast object of dynamic type %0 to type %1">;
 def note_constexpr_overflow : Note<
@@ -33,7 +33,7 @@ def note_constexpr_no_return : Note<
   "control reached end of constexpr function">;
 def note_constexpr_virtual_call : Note<
   "cannot evaluate call to virtual function in a constant expression "
-  "in C++ standards before C++2a">;
+  "in C++ standards before C++20">;
 def note_constexpr_pure_virtual_call : Note<
   "pure virtual function %q0 called">;
 def note_constexpr_polymorphic_unknown_dynamic_type : Note<
@@ -102,7 +102,7 @@ def note_constexpr_var_init_non_constant : Note<
   "initializer of %0 is not a constant expression">;
 def note_constexpr_typeid_polymorphic : Note<
   "typeid applied to expression of polymorphic type %0 is "
-  "not allowed in a constant expression in C++ standards before C++2a">;
+  "not allowed in a constant expression in C++ standards before C++20">;
 def note_constexpr_void_comparison : Note<
   "comparison between unequal pointers to void has unspecified result">;
 def note_constexpr_temporary_here : Note<"temporary created here">;
diff --git a/clang/include/clang/Basic/DiagnosticCommonKinds.td b/clang/include/clang/Basic/DiagnosticCommonKinds.td
index d6281f157ee..5c7803d71e1 100644
--- a/clang/include/clang/Basic/DiagnosticCommonKinds.td
+++ b/clang/include/clang/Basic/DiagnosticCommonKinds.td
@@ -120,7 +120,7 @@ def err_enum_template : Error<"enumeration cannot be a template">;
 
 def warn_cxx20_compat_consteval : Warning<
   "'consteval' specifier is incompatible with C++ standards before C++20">,
-  InGroup<CXX2aCompat>, DefaultIgnore;
+  InGroup<CXX20Compat>, DefaultIgnore;
 
 }
 
diff --git a/clang/include/clang/Basic/DiagnosticFrontendKinds.td b/clang/include/clang/Basic/DiagnosticFrontendKinds.td
index ed2092fb4c8..87fdfc89c63 100644
--- a/clang/include/clang/Basic/DiagnosticFrontendKinds.td
+++ b/clang/include/clang/Basic/DiagnosticFrontendKinds.td
@@ -106,7 +106,7 @@ def err_fe_invalid_wchar_type
 def err_fe_invalid_exception_model
    : Error<"invalid exception model '%0' for target '%1'">;
 def warn_fe_concepts_ts_flag : Warning<
-  "-fconcepts-ts is deprecated - use '-std=c++2a' for Concepts support">,
+  "-fconcepts-ts is deprecated - use '-std=c++20' for Concepts support">,
   InGroup<Deprecated>;
 
 def warn_fe_serialized_diag_merge_failure : Warning<
@@ -175,9 +175,9 @@ def note_incompatible_analyzer_plugin_api : Note<
 def err_module_build_requires_fmodules : Error<
   "module compilation requires '-fmodules'">;
 def err_module_interface_requires_cpp_modules : Error<
-  "module interface compilation requires '-std=c++2a' or '-fmodules-ts'">;
+  "module interface compilation requires '-std=c++20' or '-fmodules-ts'">;
 def err_header_module_requires_modules : Error<
-  "header module compilation requires '-fmodules', '-std=c++2a', or "
+  "header module compilation requires '-fmodules', '-std=c++20', or "
   "'-fmodules-ts'">;
 def warn_module_config_mismatch : Warning<
   "module file %0 cannot be loaded due to a configuration mismatch with the current "
diff --git a/clang/include/clang/Basic/DiagnosticGroups.td b/clang/include/clang/Basic/DiagnosticGroups.td
index 5ad07915d2f..67885ac14ab 100644
--- a/clang/include/clang/Basic/DiagnosticGroups.td
+++ b/clang/include/clang/Basic/DiagnosticGroups.td
@@ -187,10 +187,10 @@ def Deprecated : DiagGroup<"deprecated", [DeprecatedAnonEnumEnumConversion,
                                           DeprecatedWritableStr]>,
                  DiagCategory<"Deprecations">;
 
-def CXX2aDesignator : DiagGroup<"c++2a-designator">;
+def CXX20Designator : DiagGroup<"c++20-designator">;
 // Allow -Wno-c99-designator to be used to turn off all warnings on valid C99
-// designators (including the warning controlled by -Wc++2a-designator).
-def C99Designator : DiagGroup<"c99-designator", [CXX2aDesignator]>;
+// designators (including the warning controlled by -Wc++20-designator).
+def C99Designator : DiagGroup<"c99-designator", [CXX20Designator]>;
 def GNUDesignator : DiagGroup<"gnu-designator">;
 
 def DynamicExceptionSpec
@@ -246,9 +246,9 @@ def CXXPre14CompatPedantic : DiagGroup<"c++98-c++11-compat-pedantic",
 def CXXPre17Compat : DiagGroup<"c++98-c++11-c++14-compat">;
 def CXXPre17CompatPedantic : DiagGroup<"c++98-c++11-c++14-compat-pedantic",
                                        [CXXPre17Compat]>;
-def CXXPre2aCompat : DiagGroup<"c++98-c++11-c++14-c++17-compat">;
-def CXXPre2aCompatPedantic : DiagGroup<"c++98-c++11-c++14-c++17-compat-pedantic",
-                                       [CXXPre2aCompat]>;
+def CXXPre20Compat : DiagGroup<"c++98-c++11-c++14-c++17-compat">;
+def CXXPre20CompatPedantic : DiagGroup<"c++98-c++11-c++14-c++17-compat-pedantic",
+                                       [CXXPre20Compat]>;
 
 def CXX98CompatBindToTemporaryCopy :
   DiagGroup<"c++98-compat-bind-to-temporary-copy">;
@@ -262,7 +262,7 @@ def CXX98Compat : DiagGroup<"c++98-compat",
                              CXX98CompatUnnamedTypeTemplateArgs,
                              CXXPre14Compat,
                              CXXPre17Compat,
-                             CXXPre2aCompat]>;
+                             CXXPre20Compat]>;
 // Warnings for C++11 features which are Extensions in C++98 mode.
 def CXX98CompatPedantic : DiagGroup<"c++98-compat-pedantic",
                                     [CXX98Compat,
@@ -270,7 +270,7 @@ def CXX98CompatPedantic : DiagGroup<"c++98-compat-pedantic",
                                      CXX98CompatExtraSemi,
                                      CXXPre14CompatPedantic,
                                      CXXPre17CompatPedantic,
-                                     CXXPre2aCompatPedantic]>;
+                                     CXXPre20CompatPedantic]>;
 
 def CXX11Narrowing : DiagGroup<"c++11-narrowing">;
 
@@ -296,33 +296,35 @@ def CXX11Compat : DiagGroup<"c++11-compat",
                              CXX11CompatDeprecatedWritableStr,
                              CXXPre14Compat,
                              CXXPre17Compat,
-                             CXXPre2aCompat]>;
+                             CXXPre20Compat]>;
 def : DiagGroup<"c++0x-compat", [CXX11Compat]>;
 def CXX11CompatPedantic : DiagGroup<"c++11-compat-pedantic",
                                     [CXX11Compat,
                                      CXXPre14CompatPedantic,
                                      CXXPre17CompatPedantic,
-                                     CXXPre2aCompatPedantic]>;
+                                     CXXPre20CompatPedantic]>;
 
 def CXX14Compat : DiagGroup<"c++14-compat", [CXXPre17Compat,
-                                             CXXPre2aCompat]>;
+                                             CXXPre20Compat]>;
 def CXX14CompatPedantic : DiagGroup<"c++14-compat-pedantic",
                                     [CXX14Compat,
                                      CXXPre17CompatPedantic,
-                                     CXXPre2aCompatPedantic]>;
+                                     CXXPre20CompatPedantic]>;
 
 def CXX17Compat : DiagGroup<"c++17-compat", [DeprecatedRegister,
                                              DeprecatedIncrementBool,
                                              CXX17CompatMangling,
-                                             CXXPre2aCompat]>;
+                                             CXXPre20Compat]>;
 def CXX17CompatPedantic : DiagGroup<"c++17-compat-pedantic",
                                     [CXX17Compat,
-                                     CXXPre2aCompatPedantic]>;
+                                     CXXPre20CompatPedantic]>;
 def : DiagGroup<"c++1z-compat", [CXX17Compat]>;
 
-def CXX2aCompat : DiagGroup<"c++2a-compat">;
-def CXX2aCompatPedantic : DiagGroup<"c++2a-compat-pedantic",
-                                    [CXX2aCompat]>;
+def CXX20Compat : DiagGroup<"c++20-compat">;
+def CXX20CompatPedantic : DiagGroup<"c++20-compat-pedantic",
+                                    [CXX20Compat]>;
+def : DiagGroup<"c++2a-compat", [CXX20Compat]>;
+def : DiagGroup<"c++2a-compat-pedantic", [CXX20CompatPedantic]>;
 
 def ExitTimeDestructors : DiagGroup<"exit-time-destructors">;
 def FlexibleArrayExtensions : DiagGroup<"flexible-array-extensions">;
@@ -955,13 +957,14 @@ def CXX14 : DiagGroup<"c++14-extensions", [CXX14BinaryLiteral]>;
 // earlier C++ versions.
 def CXX17 : DiagGroup<"c++17-extensions">;
 
-// A warning group for warnings about using C++2a features as extensions in
+// A warning group for warnings about using C++20 features as extensions in
 // earlier C++ versions.
-def CXX2a : DiagGroup<"c++2a-extensions", [CXX2aDesignator]>;
+def CXX20 : DiagGroup<"c++20-extensions", [CXX20Designator]>;
 
 def : DiagGroup<"c++0x-extensions", [CXX11]>;
 def : DiagGroup<"c++1y-extensions", [CXX14]>;
 def : DiagGroup<"c++1z-extensions", [CXX17]>;
+def : DiagGroup<"c++2a-extensions", [CXX20]>;
 
 def DelegatingCtorCycles :
   DiagGroup<"delegating-ctor-cycles">;
diff --git a/clang/include/clang/Basic/DiagnosticLexKinds.td b/clang/include/clang/Basic/DiagnosticLexKinds.td
index b64cbc23f81..9e0449d3410 100644
--- a/clang/include/clang/Basic/DiagnosticLexKinds.td
+++ b/clang/include/clang/Basic/DiagnosticLexKinds.td
@@ -31,12 +31,12 @@ def warn_cxx98_compat_less_colon_colon : Warning<
   InGroup<CXX98Compat>, DefaultIgnore;
 
 def warn_cxx17_compat_spaceship : Warning<
-  "'<=>' operator is incompatible with C++ standards before C++2a">,
-  InGroup<CXXPre2aCompat>, DefaultIgnore;
+  "'<=>' operator is incompatible with C++ standards before C++20">,
+  InGroup<CXXPre20Compat>, DefaultIgnore;
 def warn_cxx2a_compat_spaceship : Warning<
-  "'<=>' is a single token in C++2a; "
+  "'<=>' is a single token in C++20; "
   "add a space to avoid a change in behavior">,
-  InGroup<CXX2aCompat>;
+  InGroup<CXX20Compat>;
 
 // Trigraphs.
 def trigraph_ignored : Warning<"trigraph ignored">, InGroup<Trigraphs>;
@@ -78,8 +78,8 @@ def ext_token_used : Extension<"extension used">,
 
 def warn_cxx11_keyword : Warning<"'%0' is a keyword in C++11">,
   InGroup<CXX11Compat>, DefaultIgnore;
-def warn_cxx2a_keyword : Warning<"'%0' is a keyword in C++2a">,
-  InGroup<CXX2aCompat>, DefaultIgnore;
+def warn_cxx2a_keyword : Warning<"'%0' is a keyword in C++20">,
+  InGroup<CXX20Compat>, DefaultIgnore;
 
 def ext_unterminated_char_or_string : ExtWarn<
   "missing terminating %select{'|'\"'}0 character">, InGroup<InvalidPPToken>;
diff --git a/clang/include/clang/Basic/DiagnosticParseKinds.td b/clang/include/clang/Basic/DiagnosticParseKinds.td
index 04b103e3087..33adf093693 100644
--- a/clang/include/clang/Basic/DiagnosticParseKinds.td
+++ b/clang/include/clang/Basic/DiagnosticParseKinds.td
@@ -241,10 +241,10 @@ def warn_cxx14_compat_nested_namespace_definition : Warning<
   "nested namespace definition is incompatible with C++ standards before C++17">,
   InGroup<CXXPre17Compat>, DefaultIgnore;
 def ext_inline_nested_namespace_definition : ExtWarn<
-  "inline nested namespace definition is a C++2a extension">, InGroup<CXX2a>;
+  "inline nested namespace definition is a C++20 extension">, InGroup<CXX20>;
 def warn_cxx17_compat_inline_nested_namespace_definition : Warning<
   "inline nested namespace definition is incompatible with C++ standards before"
-  " C++2a">, InGroup<CXXPre2aCompat>, DefaultIgnore;
+  " C++20">, InGroup<CXXPre20Compat>, DefaultIgnore;
 def err_inline_nested_namespace_definition : Error<
   "nested namespace definition cannot be 'inline'">;
 def err_expected_semi_after_attribute_list : Error<
@@ -589,11 +589,11 @@ def warn_cxx14_compat_init_statement : Warning<
   "%select{if|switch}0 initialization statements are incompatible with "
   "C++ standards before C++17">, DefaultIgnore, InGroup<CXXPre17Compat>;
 def ext_for_range_init_stmt : ExtWarn<
-  "range-based for loop initialization statements are a C++2a extension">,
-  InGroup<CXX2a>;
+  "range-based for loop initialization statements are a C++20 extension">,
+  InGroup<CXX20>;
 def warn_cxx17_compat_for_range_init_stmt : Warning<
   "range-based for loop initialization statements are incompatible with "
-  "C++ standards before C++2a">, DefaultIgnore, InGroup<CXXPre2aCompat>;
+  "C++ standards before C++20">, DefaultIgnore, InGroup<CXXPre20Compat>;
 def warn_empty_init_statement : Warning<
   "empty initialization statement of '%select{if|switch|range-based for}0' "
   "has no effect">, InGroup<EmptyInitStatement>, DefaultIgnore;
@@ -681,13 +681,13 @@ def err_ms_property_initializer : Error<
   "property declaration cannot have an in-class initializer">;
 
 def warn_cxx2a_compat_explicit_bool : Warning<
-  "this expression will be parsed as explicit(bool) in C++2a">,
-  InGroup<CXX2aCompat>, DefaultIgnore;
+  "this expression will be parsed as explicit(bool) in C++20">,
+  InGroup<CXX20Compat>, DefaultIgnore;
 def warn_cxx17_compat_explicit_bool : Warning<
-  "explicit(bool) is incompatible with C++ standards before C++2a">,
-  InGroup<CXXPre2aCompat>, DefaultIgnore;
-def ext_explicit_bool : ExtWarn<"explicit(bool) is a C++2a extension">,
-  InGroup<CXX2a>;
+  "explicit(bool) is incompatible with C++ standards before C++20">,
+  InGroup<CXXPre20Compat>, DefaultIgnore;
+def ext_explicit_bool : ExtWarn<"explicit(bool) is a C++20 extension">,
+  InGroup<CXX20>;
 
 /// C++ Templates
 def err_expected_template : Error<"expected template">;
@@ -844,11 +844,11 @@ def warn_cxx98_compat_nonstatic_member_init : Warning<
   "in-class initialization of non-static data members is incompatible with C++98">,
   InGroup<CXX98Compat>, DefaultIgnore;
 def ext_bitfield_member_init: ExtWarn<
-  "default member initializer for bit-field is a C++2a extension">,
-  InGroup<CXX2a>;
+  "default member initializer for bit-field is a C++20 extension">,
+  InGroup<CXX20>;
 def warn_cxx17_compat_bitfield_member_init: Warning<
   "default member initializer for bit-field is incompatible with "
-  "C++ standards before C++2a">, InGroup<CXXPre2aCompat>, DefaultIgnore;
+  "C++ standards before C++20">, InGroup<CXXPre20Compat>, DefaultIgnore;
 def err_incomplete_array_member_init: Error<
   "array bound cannot be deduced from an in-class initializer">;
 
@@ -944,13 +944,13 @@ def warn_cxx14_compat_constexpr_on_lambda : Warning<
 def ext_constexpr_on_lambda_cxx17 : ExtWarn<
   "'constexpr' on lambda expressions is a C++17 extension">, InGroup<CXX17>;
 
-// C++2a template lambdas
+// C++20 template lambdas
 def ext_lambda_template_parameter_list: ExtWarn<
-  "explicit template parameter list for lambdas is a C++2a extension">,
-  InGroup<CXX2a>;
+  "explicit template parameter list for lambdas is a C++20 extension">,
+  InGroup<CXX20>;
 def warn_cxx17_compat_lambda_template_parameter_list: Warning<
   "explicit template parameter list for lambdas is incompatible with "
-  "C++ standards before C++2a">, InGroup<CXXPre2aCompat>, DefaultIgnore;
+  "C++ standards before C++20">, InGroup<CXXPre20Compat>, DefaultIgnore;
 def err_lambda_template_parameter_list_empty : Error<
   "lambda template parameter list cannot be empty">;
 
@@ -1369,7 +1369,7 @@ let CategoryName = "Concepts Issue" in {
 def err_concept_definition_not_identifier : Error<
   "name defined in concept definition must be an identifier">;
 def ext_concept_legacy_bool_keyword : ExtWarn<
-  "ISO C++2a does not permit the 'bool' keyword after 'concept'">,
+  "ISO C++20 does not permit the 'bool' keyword after 'concept'">,
   InGroup<DiagGroup<"concepts-ts-compat">>;
 def err_placeholder_expected_auto_or_decltype_auto : Error<
   "expected 'auto' or 'decltype(auto)' after concept name">;
diff --git a/clang/include/clang/Basic/DiagnosticSemaKinds.td b/clang/include/clang/Basic/DiagnosticSemaKinds.td
index 2199dfbddc8..f643739eaac 100644
--- a/clang/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/clang/include/clang/Basic/DiagnosticSemaKinds.td
@@ -193,10 +193,10 @@ def ext_flexible_array_init : Extension<
 
 // C++20 designated initializers
 def ext_cxx_designated_init : Extension<
-  "designated initializers are a C++20 extension">, InGroup<CXX2aDesignator>;
+  "designated initializers are a C++20 extension">, InGroup<CXX20Designator>;
 def warn_cxx17_compat_designated_init : Warning<
   "designated initializers are incompatible with C++ standards before C++20">,
-  InGroup<CXXPre2aCompatPedantic>, DefaultIgnore;
+  InGroup<CXXPre20CompatPedantic>, DefaultIgnore;
 def ext_designated_init_mixed : ExtWarn<
   "mixture of designated and non-designated initializers in the same "
   "initializer list is a C99 extension">, InGroup<C99Designator>;
@@ -444,13 +444,13 @@ def err_decomp_decl_spec : Error<
   "%plural{1:'%1'|:with '%1' specifiers}0">;
 def ext_decomp_decl_spec : ExtWarn<
   "decomposition declaration declared "
-  "%plural{1:'%1'|:with '%1' specifiers}0 is a C++2a extension">,
-  InGroup<CXX2a>;
+  "%plural{1:'%1'|:with '%1' specifiers}0 is a C++20 extension">,
+  InGroup<CXX20>;
 def warn_cxx17_compat_decomp_decl_spec : Warning<
   "decomposition declaration declared "
   "%plural{1:'%1'|:with '%1' specifiers}0 "
-  "is incompatible with C++ standards before C++2a">,
-  InGroup<CXXPre2aCompat>, DefaultIgnore;
+  "is incompatible with C++ standards before C++20">,
+  InGroup<CXXPre20Compat>, DefaultIgnore;
 def err_decomp_decl_type : Error<
   "decomposition declaration cannot be declared with type %0; "
   "declared type must be 'auto' or reference to 'auto'">;
@@ -1949,7 +1949,7 @@ def err_init_list_bad_dest_type : Error<
   "list">;
 def warn_cxx2a_compat_aggregate_init_with_ctors : Warning<
   "aggregate initialization of type %0 with user-declared constructors "
-  "is incompatible with C++2a">, DefaultIgnore, InGroup<CXX2aCompat>;
+  "is incompatible with C++20">, DefaultIgnore, InGroup<CXX20Compat>;
 
 def err_reference_bind_to_bitfield : Error<
   "%select{non-const|volatile}0 reference cannot bind to "
@@ -2438,7 +2438,7 @@ def err_constexpr_redecl_mismatch : Error<
 def err_constexpr_virtual : Error<"virtual function cannot be constexpr">;
 def warn_cxx17_compat_constexpr_virtual : Warning<
   "virtual constexpr functions are incompatible with "
-  "C++ standards before C++2a">, InGroup<CXXPre2aCompat>, DefaultIgnore;
+  "C++ standards before C++20">, InGroup<CXXPre20Compat>, DefaultIgnore;
 def err_constexpr_virtual_base : Error<
   "constexpr %select{member function|constructor}0 not allowed in "
   "%select{struct|interface|class}1 with virtual base "
@@ -2464,11 +2464,11 @@ def warn_cxx11_compat_constexpr_body_invalid_stmt : Warning<
   InGroup<CXXPre14Compat>, DefaultIgnore;
 def ext_constexpr_body_invalid_stmt_cxx2a : ExtWarn<
   "use of this statement in a constexpr %select{function|constructor}0 "
-  "is a C++2a extension">, InGroup<CXX2a>;
+  "is a C++20 extension">, InGroup<CXX20>;
 def warn_cxx17_compat_constexpr_body_invalid_stmt : Warning<
   "use of this statement in a constexpr %select{function|constructor}0 "
-  "is incompatible with C++ standards before C++2a">,
-  InGroup<CXXPre2aCompat>, DefaultIgnore;
+  "is incompatible with C++ standards before C++20">,
+  InGroup<CXXPre20Compat>, DefaultIgnore;
 def ext_constexpr_type_definition : ExtWarn<
   "type definition in a constexpr %select{function|constructor}0 "
   "is a C++14 extension">, InGroup<CXX14>;
@@ -2494,11 +2494,11 @@ def err_constexpr_local_var_non_literal_type : Error<
   "%select{function|constructor}0">;
 def ext_constexpr_local_var_no_init : ExtWarn<
   "uninitialized variable in a constexpr %select{function|constructor}0 "
-  "is a C++20 extension">, InGroup<CXX2a>;
+  "is a C++20 extension">, InGroup<CXX20>;
 def warn_cxx17_compat_constexpr_local_var_no_init : Warning<
   "uninitialized variable in a constexpr %select{function|constructor}0 "
   "is incompatible with C++ standards before C++20">,
-  InGroup<CXXPre2aCompat>, DefaultIgnore;
+  InGroup<CXXPre20Compat>, DefaultIgnore;
 def ext_constexpr_function_never_constant_expr : ExtWarn<
   "constexpr %select{function|constructor}0 never produces a "
   "constant expression">, InGroup<DiagGroup<"invalid-constexpr">>, DefaultError;
@@ -2524,29 +2524,29 @@ def warn_cxx11_compat_constexpr_body_multiple_return : Warning<
 def note_constexpr_body_previous_return : Note<
   "previous return statement is here">;
 
-// C++2a function try blocks in constexpr
+// C++20 function try blocks in constexpr
 def ext_constexpr_function_try_block_cxx2a : ExtWarn<
   "function try block in constexpr %select{function|constructor}0 is "
-  "a C++2a extension">, InGroup<CXX2a>;
+  "a C++20 extension">, InGroup<CXX20>;
 def warn_cxx17_compat_constexpr_function_try_block : Warning<
   "function try block in constexpr %select{function|constructor}0 is "
-  "incompatible with C++ standards before C++2a">,
-  InGroup<CXXPre2aCompat>, DefaultIgnore;
+  "incompatible with C++ standards before C++20">,
+  InGroup<CXXPre20Compat>, DefaultIgnore;
 
 def ext_constexpr_union_ctor_no_init : ExtWarn<
   "constexpr union constructor that does not initialize any member "
-  "is a C++20 extension">, InGroup<CXX2a>;
+  "is a C++20 extension">, InGroup<CXX20>;
 def warn_cxx17_compat_constexpr_union_ctor_no_init : Warning<
   "constexpr union constructor that does not initialize any member "
   "is incompatible with C++ standards before C++20">,
-  InGroup<CXXPre2aCompat>, DefaultIgnore;
+  InGroup<CXXPre20Compat>, DefaultIgnore;
 def ext_constexpr_ctor_missing_init : ExtWarn<
   "constexpr constructor that does not initialize all members "
-  "is a C++20 extension">, InGroup<CXX2a>;
+  "is a C++20 extension">, InGroup<CXX20>;
 def warn_cxx17_compat_constexpr_ctor_missing_init : Warning<
   "constexpr constructor that does not initialize all members "
   "is incompatible with C++ standards before C++20">,
-  InGroup<CXXPre2aCompat>, DefaultIgnore;
+  InGroup<CXXPre20Compat>, DefaultIgnore;
 def note_constexpr_ctor_missing_init : Note<
   "member not initialized by constructor">;
 def note_non_literal_no_constexpr_ctors : Note<
@@ -2678,7 +2678,7 @@ def warn_cxx98_compat_unicode_type : Warning<
   InGroup<CXX98Compat>, DefaultIgnore;
 def warn_cxx17_compat_unicode_type : Warning<
   "'char8_t' type specifier is incompatible with C++ standards before C++20">,
-  InGroup<CXXPre2aCompat>, DefaultIgnore;
+  InGroup<CXXPre20Compat>, DefaultIgnore;
 
 // __make_integer_seq
 def err_integer_sequence_negative_length : Error<
@@ -4289,11 +4289,11 @@ def err_template_tag_noparams : Error<
 def warn_cxx17_compat_adl_only_template_id : Warning<
   "use of function template name with no prior function template "
   "declaration in function call with explicit template arguments "
-  "is incompatible with C++ standards before C++2a">,
-  InGroup<CXXPre2aCompat>, DefaultIgnore;
+  "is incompatible with C++ standards before C++20">,
+  InGroup<CXXPre20Compat>, DefaultIgnore;
 def ext_adl_only_template_id : ExtWarn<
   "use of function template name with no prior declaration in function call "
-  "with explicit template arguments is a C++2a extension">, InGroup<CXX2a>;
+  "with explicit template arguments is a C++20 extension">, InGroup<CXX20>;
 
 // C++ Template Argument Lists
 def err_template_missing_args : Error<
@@ -4435,12 +4435,12 @@ def err_pointer_to_member_oper_value_classify: Error<
   "pointer-to-member function type %0 can only be called on an "
   "%select{rvalue|lvalue}1">;
 def ext_pointer_to_const_ref_member_on_rvalue : Extension<
-  "invoking a pointer to a 'const &' member function on an rvalue is a C++2a extension">,
-  InGroup<CXX2a>, SFINAEFailure;
+  "invoking a pointer to a 'const &' member function on an rvalue is a C++20 extension">,
+  InGroup<CXX20>, SFINAEFailure;
 def warn_cxx17_compat_pointer_to_const_ref_member_on_rvalue : Warning<
   "invoking a pointer to a 'const &' member function on an rvalue is "
-  "incompatible with C++ standards before C++2a">,
-  InGroup<CXXPre2aCompatPedantic>, DefaultIgnore;
+  "incompatible with C++ standards before C++20">,
+  InGroup<CXXPre20CompatPedantic>, DefaultIgnore;
 def ext_ms_deref_template_argument: ExtWarn<
   "non-type template argument containing a dereference operation is a "
   "Microsoft extension">, InGroup<MicrosoftTemplate>;
@@ -6189,7 +6189,7 @@ def err_array_init_utf8_string_into_char : Error<
   "UTF-8 string literal%select{ is not permitted by '-fchar8_t'|}0">;
 def warn_cxx2a_compat_utf8_string : Warning<
   "type of UTF-8 string literal will change from array of const char to "
-  "array of const char8_t in C++2a">, InGroup<CXX2aCompat>, DefaultIgnore;
+  "array of const char8_t in C++20">, InGroup<CXX20Compat>, DefaultIgnore;
 def note_cxx2a_compat_utf8_string_remove_u8 : Note<
   "remove 'u8' prefix to avoid a change of behavior; "
   "Clang encodes unprefixed narrow string literals as UTF-8">;
@@ -7116,9 +7116,9 @@ let CategoryName = "Lambda Issue" in {
     "cannot deduce type for lambda capture %0 from initializer list">;
   def warn_cxx17_compat_init_capture_pack : Warning<
     "initialized lambda capture packs are incompatible with C++ standards "
-    "before C++2a">, InGroup<CXXPre2aCompat>, DefaultIgnore;
+    "before C++20">, InGroup<CXXPre20Compat>, DefaultIgnore;
   def ext_init_capture_pack : ExtWarn<
-    "initialized lambda pack captures are a C++2a extension">, InGroup<CXX2a>;
+    "initialized lambda pack captures are a C++20 extension">, InGroup<CXX20>;
 
   // C++14 generic lambdas.
   def warn_cxx11_compat_generic_lambda : Warning<
@@ -7136,23 +7136,23 @@ let CategoryName = "Lambda Issue" in {
   def err_parameter_shadow_capture : Error<
     "a lambda parameter cannot shadow an explicitly captured entity">;
 
-  // C++2a [=, this] captures.
+  // C++20 [=, this] captures.
   def warn_cxx17_compat_equals_this_lambda_capture : Warning<
     "explicit capture of 'this' with a capture default of '=' is incompatible "
-    "with C++ standards before C++2a">, InGroup<CXXPre2aCompat>, DefaultIgnore;
+    "with C++ standards before C++20">, InGroup<CXXPre20Compat>, DefaultIgnore;
   def ext_equals_this_lambda_capture_cxx2a : ExtWarn<
     "explicit capture of 'this' with a capture default of '=' "
-    "is a C++2a extension">, InGroup<CXX2a>;
+    "is a C++20 extension">, InGroup<CXX20>;
   def warn_deprecated_this_capture : Warning<
     "implicit capture of 'this' with a capture default of '=' is deprecated">,
     InGroup<DeprecatedThisCapture>, DefaultIgnore;
   def note_deprecated_this_capture : Note<
     "add an explicit capture of 'this' to capture '*this' by reference">;
 
-  // C++2a default constructible / assignable lambdas.
+  // C++20 default constructible / assignable lambdas.
   def warn_cxx17_compat_lambda_def_ctor_assign : Warning<
     "%select{default construction|assignment}0 of lambda is incompatible with "
-    "C++ standards before C++2a">, InGroup<CXXPre2aCompat>, DefaultIgnore;
+    "C++ standards before C++20">, InGroup<CXXPre20Compat>, DefaultIgnore;
 }
 
 def err_return_in_captured_stmt : Error<
@@ -7853,7 +7853,7 @@ def ext_cxx14_attr : Extension<
 def ext_cxx17_attr : Extension<
   "use of the %0 attribute is a C++17 extension">, InGroup<CXX17>;
 def ext_cxx2a_attr : Extension<
-  "use of the %0 attribute is a C++2a extension">, InGroup<CXX2a>;
+  "use of the %0 attribute is a C++20 extension">, InGroup<CXX20>;
 
 def warn_unused_comparison : Warning<
   "%select{equality|inequality|relational|three-way}0 comparison result unused">,
@@ -7867,7 +7867,7 @@ def err_incomplete_type_used_in_type_trait_expr : Error<
 // C++20 constinit and require_constant_initialization attribute
 def warn_cxx20_compat_constinit : Warning<
   "'constinit' specifier is incompatible with C++ standards before C++20">,
-  InGroup<CXX2aCompat>, DefaultIgnore;
+  InGroup<CXX20Compat>, DefaultIgnore;
 def err_constinit_local_variable : Error<
   "local variable cannot be declared 'constinit'">;
 def err_require_constant_init_failed : Error<
@@ -8322,7 +8322,7 @@ def note_deleted_type_mismatch : Note<
 def warn_cxx17_compat_defaulted_method_type_mismatch : Warning<
   "explicitly defaulting this %sub{select_special_member_kind}0 with a type "
   "different from the implicit type is incompatible with C++ standards before "
-  "C++2a">, InGroup<CXXPre2aCompat>, DefaultIgnore;
+  "C++20">, InGroup<CXXPre20Compat>, DefaultIgnore;
 def warn_vbase_moved_multiple_times : Warning<
   "defaulted move assignment operator of %0 will move assign virtual base "
   "class %1 multiple times">, InGroup<DiagGroup<"multiple-move-vbase">>;
@@ -8336,10 +8336,10 @@ def select_defaulted_comparison_kind : TextSubstitution<
   "%select{<ERROR>|equality|three-way|equality|relational}0 comparison "
   "operator">;
 def ext_defaulted_comparison : ExtWarn<
-  "defaulted comparison operators are a C++20 extension">, InGroup<CXX2a>;
+  "defaulted comparison operators are a C++20 extension">, InGroup<CXX20>;
 def warn_cxx17_compat_defaulted_comparison : Warning<
   "defaulted comparison operators are incompatible with C++ standards "
-  "before C++20">, InGroup<CXXPre2aCompat>, DefaultIgnore;
+  "before C++20">, InGroup<CXXPre20Compat>, DefaultIgnore;
 def err_defaulted_comparison_template : Error<
   "comparison operator template cannot be defaulted">;
 def err_defaulted_comparison_out_of_class : Error<
diff --git a/clang/include/clang/Basic/LangStandards.def b/clang/include/clang/Basic/LangStandards.def
index 427691fb71e..7f1a24db7e9 100644
--- a/clang/include/clang/Basic/LangStandards.def
+++ b/clang/include/clang/Basic/LangStandards.def
@@ -140,15 +140,17 @@ LANGSTANDARD(gnucxx17, "gnu++17",
              Digraphs | HexFloat | GNUMode)
 LANGSTANDARD_ALIAS_DEPR(gnucxx17, "gnu++1z")
 
-LANGSTANDARD(cxx2a, "c++2a",
-             CXX, "Working draft for ISO C++ 2020",
+LANGSTANDARD(cxx20, "c++20",
+             CXX, "ISO C++ 2020 DIS",
              LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus14 | CPlusPlus17 |
              CPlusPlus2a | Digraphs | HexFloat)
+LANGSTANDARD_ALIAS_DEPR(cxx20, "c++2a")
 
-LANGSTANDARD(gnucxx2a, "gnu++2a",
-             CXX, "Working draft for ISO C++ 2020 with GNU extensions",
+LANGSTANDARD(gnucxx20, "gnu++20",
+             CXX, "ISO C++ 2020 DIS with GNU extensions",
              LineComment | CPlusPlus | CPlusPlus11 | CPlusPlus14 | CPlusPlus17 |
              CPlusPlus2a | Digraphs | HexFloat | GNUMode)
+LANGSTANDARD_ALIAS_DEPR(gnucxx20, "gnu++2a")
 
 // OpenCL
 LANGSTANDARD(opencl10, "cl1.0",
diff --git a/clang/include/clang/Basic/StmtNodes.td b/clang/include/clang/Basic/StmtNodes.td
index 41923cddc49..23332029681 100644
--- a/clang/include/clang/Basic/StmtNodes.td
+++ b/clang/include/clang/Basic/StmtNodes.td
@@ -162,7 +162,7 @@ def CoawaitExpr : StmtNode<CoroutineSuspendExpr>;
 def DependentCoawaitExpr : StmtNode<Expr>;
 def CoyieldExpr : StmtNode<CoroutineSuspendExpr>;
 
-// C++2a Concepts expressions
+// C++20 Concepts expressions
 def ConceptSpecializationExpr : StmtNode<Expr>;
 def RequiresExpr : StmtNode<Expr>;
 
diff --git a/clang/lib/Frontend/InitPreprocessor.cpp b/clang/lib/Frontend/InitPreprocessor.cpp
index 8a0ff55e44f..c273cb96d9b 100644
--- a/clang/lib/Frontend/InitPreprocessor.cpp
+++ b/clang/lib/Frontend/InitPreprocessor.cpp
@@ -344,13 +344,27 @@ static void InitializeStandardPredefinedMacros(const TargetInfo &TI,
                                                const LangOptions &LangOpts,
                                                const FrontendOptions &FEOpts,
                                                MacroBuilder &Builder) {
+  // C++ [cpp.predefined]p1:
+  //   The following macro names shall be defined by the implementation:
+
+  //   -- __STDC__
+  //      [C++] Whether __STDC__ is predefined and if so, what its value is,
+  //      are implementation-defined.
+  // (Removed in C++20.)
   if (!LangOpts.MSVCCompat && !LangOpts.TraditionalCPP)
     Builder.defineMacro("__STDC__");
+  //   -- __STDC_HOSTED__
+  //      The integer literal 1 if the implementation is a hosted
+  //      implementation or the integer literal 0 if it is not.
   if (LangOpts.Freestanding)
     Builder.defineMacro("__STDC_HOSTED__", "0");
   else
     Builder.defineMacro("__STDC_HOSTED__");
 
+  //   -- __STDC_VERSION__
+  //      [C++] Whether __STDC_VERSION__ is predefined and if so, what its
+  //      value is, are implementation-defined.
+  // (Removed in C++20.)
   if (!LangOpts.CPlusPlus) {
     if (LangOpts.C17)
       Builder.defineMacro("__STDC_VERSION__", "201710L");
@@ -361,33 +375,29 @@ static void InitializeStandardPredefinedMacros(const TargetInfo &TI,
     else if (!LangOpts.GNUMode && LangOpts.Digraphs)
       Builder.defineMacro("__STDC_VERSION__", "199409L");
   } else {
-    // FIXME: Use correct value for C++20.
+    //   -- __cplusplus
+    //      [C++20] The integer literal 202002L.
     if (LangOpts.CPlusPlus2a)
-      Builder.defineMacro("__cplusplus", "201707L");
-    // C++17 [cpp.predefined]p1:
-    //   The name __cplusplus is defined to the value 201703L when compiling a
-    //   C++ translation unit.
+      Builder.defineMacro("__cplusplus", "202002L");
+    //      [C++17] The integer literal 201703L.
     else if (LangOpts.CPlusPlus17)
       Builder.defineMacro("__cplusplus", "201703L");
-    // C++1y [cpp.predefined]p1:
-    //   The name __cplusplus is defined to the value 201402L when compiling a
-    //   C++ translation unit.
+    //      [C++14] The name __cplusplus is defined to the value 201402L when
+    //      compiling a C++ translation unit.
     else if (LangOpts.CPlusPlus14)
       Builder.defineMacro("__cplusplus", "201402L");
-    // C++11 [cpp.predefined]p1:
-    //   The name __cplusplus is defined to the value 201103L when compiling a
-    //   C++ translation unit.
+    //      [C++11] The name __cplusplus is defined to the value 201103L when
+    //      compiling a C++ translation unit.
     else if (LangOpts.CPlusPlus11)
       Builder.defineMacro("__cplusplus", "201103L");
-    // C++03 [cpp.predefined]p1:
-    //   The name __cplusplus is defined to the value 199711L when compiling a
-    //   C++ translation unit.
+    //      [C++03] The name __cplusplus is defined to the value 199711L when
+    //      compiling a C++ translation unit.
     else
       Builder.defineMacro("__cplusplus", "199711L");
 
-    // C++1z [cpp.predefined]p1:
-    //   An integer literal of type std::size_t whose value is the alignment
-    //   guaranteed by a call to operator new(std::size_t)
+    //   -- __STDCPP_DEFAULT_NEW_ALIGNMENT__
+    //      [C++17] An integer literal of type std::size_t whose value is the
+    //      alignment guaranteed by a call to operator new(std::size_t)
     //
     // We provide this in all language modes, since it seems generally useful.
     Builder.defineMacro("__STDCPP_DEFAULT_NEW_ALIGNMENT__",
diff --git a/clang/test/CXX/basic/basic.lookup/basic.lookup.unqual/p3.cpp b/clang/test/CXX/basic/basic.lookup/basic.lookup.unqual/p3.cpp
index 0138b88578f..ef3b127ef82 100644
--- a/clang/test/CXX/basic/basic.lookup/basic.lookup.unqual/p3.cpp
+++ b/clang/test/CXX/basic/basic.lookup/basic.lookup.unqual/p3.cpp
@@ -1,6 +1,6 @@
 // RUN: %clang_cc1 -fsyntax-only -verify %s
 // RUN: %clang_cc1 -std=c++17 -fsyntax-only -verify %s
-// RUN: %clang_cc1 -std=c++2a -fsyntax-only -verify %s
+// RUN: %clang_cc1 -std=c++20 -fsyntax-only -verify %s
 
 typedef int fn;
 
@@ -43,7 +43,7 @@ namespace std_example {
 
   int x = f<N::A>(N::A());
 #if __cplusplus <= 201703L
-  // expected-warning@-2 {{C++2a extension}}
+  // expected-warning@-2 {{C++20 extension}}
 #endif
   int y = g<N::A>(N::A());
 #if __cplusplus <= 201703L
diff --git a/clang/test/CXX/dcl.dcl/dcl.attr/dcl.attr.nodiscard/p2.cpp b/clang/test/CXX/dcl.dcl/dcl.attr/dcl.attr.nodiscard/p2.cpp
index bdf829210e0..3d3223cda75 100644
--- a/clang/test/CXX/dcl.dcl/dcl.attr/dcl.attr.nodiscard/p2.cpp
+++ b/clang/test/CXX/dcl.dcl/dcl.attr/dcl.attr.nodiscard/p2.cpp
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -fsyntax-only -std=c++2a -verify -Wc++2a-extensions %s
+// RUN: %clang_cc1 -fsyntax-only -std=c++20 -verify -Wc++20-extensions %s
 // RUN: %clang_cc1 -fsyntax-only -std=c++17 -verify -Wc++17-extensions %s
-// RUN: %clang_cc1 -fsyntax-only -std=c++11 -verify -DEXT -Wc++17-extensions -Wc++2a-extensions %s
+// RUN: %clang_cc1 -fsyntax-only -std=c++11 -verify -DEXT -Wc++17-extensions -Wc++20-extensions %s
 
 struct [[nodiscard]] S {};
 S get_s();
@@ -73,7 +73,7 @@ LaterReason get_later_reason();
 [[nodiscard("conflicting reason")]] int conflicting_reason();
 [[nodiscard("special reason")]] int conflicting_reason();
 
-void cxx2a_use() {
+void cxx20_use() {
   get_reason(); // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute: reason}}
   get_later_reason(); // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute: later reason}}
   another_reason(); // expected-warning {{ignoring return value of function declared with 'nodiscard' attribute: another reason}}
@@ -130,15 +130,15 @@ void usage() {
 // expected-warning@12 {{use of the 'nodiscard' attribute is a C++17 extension}}
 // expected-warning@13 {{use of the 'nodiscard' attribute is a C++17 extension}}
 // expected-warning@29 {{use of the 'nodiscard' attribute is a C++17 extension}}
-// expected-warning@65 {{use of the 'nodiscard' attribute is a C++2a extension}}
-// expected-warning@67 {{use of the 'nodiscard' attribute is a C++2a extension}}
-// expected-warning@71 {{use of the 'nodiscard' attribute is a C++2a extension}}
-// expected-warning@73 {{use of the 'nodiscard' attribute is a C++2a extension}}
-// expected-warning@74 {{use of the 'nodiscard' attribute is a C++2a extension}}
-// expected-warning@84 {{use of the 'nodiscard' attribute is a C++2a extension}}
+// expected-warning@65 {{use of the 'nodiscard' attribute is a C++20 extension}}
+// expected-warning@67 {{use of the 'nodiscard' attribute is a C++20 extension}}
+// expected-warning@71 {{use of the 'nodiscard' attribute is a C++20 extension}}
+// expected-warning@73 {{use of the 'nodiscard' attribute is a C++20 extension}}
+// expected-warning@74 {{use of the 'nodiscard' attribute is a C++20 extension}}
+// expected-warning@84 {{use of the 'nodiscard' attribute is a C++20 extension}}
 // expected-warning@86 {{use of the 'nodiscard' attribute is a C++17 extension}}
-// expected-warning@87 {{use of the 'nodiscard' attribute is a C++2a extension}}
+// expected-warning@87 {{use of the 'nodiscard' attribute is a C++20 extension}}
 // expected-warning@91 {{use of the 'nodiscard' attribute is a C++17 extension}}
-// expected-warning@92 {{use of the 'nodiscard' attribute is a C++2a extension}}
-// expected-warning@95 {{use of the 'nodiscard' attribute is a C++2a extension}}
+// expected-warning@92 {{use of the 'nodiscard' attribute is a C++20 extension}}
+// expected-warning@95 {{use of the 'nodiscard' attribute is a C++20 extension}}
 #endif
diff --git a/clang/test/CXX/dcl.dcl/dcl.spec/dcl.constexpr/p3.cpp b/clang/test/CXX/dcl.dcl/dcl.spec/dcl.constexpr/p3.cpp
index 59c2ee7d936..9b0e7cc60f1 100644
--- a/clang/test/CXX/dcl.dcl/dcl.spec/dcl.constexpr/p3.cpp
+++ b/clang/test/CXX/dcl.dcl/dcl.spec/dcl.constexpr/p3.cpp
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -fcxx-exceptions -triple=x86_64-linux-gnu -std=c++11 -Werror=c++1y-extensions -Werror=c++2a-extensions %s
-// RUN: %clang_cc1 -verify -fcxx-exceptions -triple=x86_64-linux-gnu -std=c++1y -DCXX1Y -Werror=c++2a-extensions %s
-// RUN: %clang_cc1 -verify -fcxx-exceptions -triple=x86_64-linux-gnu -std=c++2a -DCXX1Y -DCXX2A %s
+// RUN: %clang_cc1 -verify -fcxx-exceptions -triple=x86_64-linux-gnu -std=c++11 -Werror=c++14-extensions -Werror=c++20-extensions %s
+// RUN: %clang_cc1 -verify -fcxx-exceptions -triple=x86_64-linux-gnu -std=c++14 -DCXX14 -Werror=c++20-extensions %s
+// RUN: %clang_cc1 -verify -fcxx-exceptions -triple=x86_64-linux-gnu -std=c++20 -DCXX14 -DCXX20 %s
 
 namespace N {
   typedef char C;
@@ -54,11 +54,11 @@ struct T : SS, NonLiteral {
   //  - its return type shall be a literal type;
   constexpr NonLiteral NonLiteralReturn() const { return {}; } // expected-error {{constexpr function's return type 'NonLiteral' is not a literal type}}
   constexpr void VoidReturn() const { return; }
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{constexpr function's return type 'void' is not a literal type}}
 #endif
   constexpr ~T();
-#ifndef CXX2A
+#ifndef CXX20
   // expected-error@-2 {{destructor cannot be declared constexpr}}
 #endif
   typedef NonLiteral F() const;
@@ -78,7 +78,7 @@ struct T : SS, NonLiteral {
   // don't have a literal return type. Defaulted assignment operators can't be
   // constexpr since they can't be const.
   constexpr T &operator=(const T&) = default;
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{an explicitly-defaulted copy assignment operator may not have 'const', 'constexpr' or 'volatile' qualifiers}}
   // expected-warning@-3 {{C++14}}
 #else
@@ -87,14 +87,14 @@ struct T : SS, NonLiteral {
 };
 
 constexpr int T::OutOfLineVirtual() const { return 0; }
-#ifdef CXX1Y
+#ifdef CXX14
 struct T2 {
   int n = 0;
   constexpr T2 &operator=(const T2&) = default; // ok
 };
 struct T3 {
   constexpr T3 &operator=(const T3&) const = default;
-#ifndef CXX2A
+#ifndef CXX20
   // expected-error@-2 {{an explicitly-defaulted copy assignment operator may not have 'const' or 'volatile' qualifiers}}
 #else
   // expected-warning@-4 {{explicitly defaulted copy assignment operator is implicitly deleted}}
@@ -138,56 +138,56 @@ constexpr int AllowedStmtsCXX11() {
   return sizeof(K) + sizeof(C) + sizeof(K);
 }
 
-//  or a compound-statement that does not contain [CXX1Y]
-constexpr int DisallowedStmtsCXX1Y_1(bool b) {
+//  or a compound-statement that does not contain [C++14]
+constexpr int DisallowedStmtsCXX14_1(bool b) {
   //  - an asm-definition
   if (b)
     asm("int3");
-#if !defined(CXX2A)
-  // expected-error@-2 {{use of this statement in a constexpr function is a C++2a extension}}
+#if !defined(CXX20)
+  // expected-error@-2 {{use of this statement in a constexpr function is a C++20 extension}}
 #endif
   return 0;
 }
-constexpr int DisallowedStmtsCXX1Y_2() {
+constexpr int DisallowedStmtsCXX14_2() {
   //  - a goto statement
   goto x; // expected-error {{statement not allowed in constexpr function}}
 x:
   return 0;
 }
-constexpr int DisallowedStmtsCXX1Y_2_1() {
+constexpr int DisallowedStmtsCXX14_2_1() {
   try {
     return 0;
   } catch (...) {
   merp: goto merp; // expected-error {{statement not allowed in constexpr function}}
   }
 }
-constexpr int DisallowedStmtsCXX1Y_3() {
+constexpr int DisallowedStmtsCXX14_3() {
   //  - a try-block,
   try {} catch (...) {}
-#if !defined(CXX2A)
-  // expected-error@-2 {{use of this statement in a constexpr function is a C++2a extension}}
+#if !defined(CXX20)
+  // expected-error@-2 {{use of this statement in a constexpr function is a C++20 extension}}
 #endif
   return 0;
 }
-constexpr int DisallowedStmtsCXX1Y_4() {
+constexpr int DisallowedStmtsCXX14_4() {
   //  - a definition of a variable of non-literal type
   NonLiteral nl; // expected-error {{variable of non-literal type 'NonLiteral' cannot be defined in a constexpr function}}
   return 0;
 }
-constexpr int DisallowedStmtsCXX1Y_5() {
+constexpr int DisallowedStmtsCXX14_5() {
   //  - a definition of a variable of static storage duration
   static constexpr int n = 123; // expected-error {{static variable not permitted in a constexpr function}}
   return n;
 }
-constexpr int DisallowedStmtsCXX1Y_6() {
+constexpr int DisallowedStmtsCXX14_6() {
   //  - a definition of a variable of thread storage duration
   thread_local constexpr int n = 123; // expected-error {{thread_local variable not permitted in a constexpr function}}
   return n;
 }
-constexpr int DisallowedStmtsCXX1Y_7() {
+constexpr int DisallowedStmtsCXX14_7() {
   //  - a definition of a variable for which no initialization is performed
   int n;
-#ifndef CXX2A
+#ifndef CXX20
   // expected-error@-2 {{uninitialized variable in a constexpr function}}
 #endif
   return 0;
@@ -195,28 +195,28 @@ constexpr int DisallowedStmtsCXX1Y_7() {
 
 constexpr int ForStmt() {
   for (int n = 0; n < 10; ++n)
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{statement not allowed in constexpr function}}
 #endif
     return 0;
 }
 constexpr int VarDecl() {
   int a = 0;
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{variable declaration in a constexpr function is a C++14 extension}}
 #endif
   return 0;
 }
 constexpr int ConstexprVarDecl() {
   constexpr int a = 0;
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{variable declaration in a constexpr function is a C++14 extension}}
 #endif
   return 0;
 }
 constexpr int VarWithCtorDecl() {
   Literal a;
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{variable declaration in a constexpr function is a C++14 extension}}
 #endif
   return 0;
@@ -224,7 +224,7 @@ constexpr int VarWithCtorDecl() {
 NonLiteral nl;
 constexpr NonLiteral &ExternNonLiteralVarDecl() {
   extern NonLiteral nl;
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{variable declaration in a constexpr function is a C++14 extension}}
 #endif
   return nl;
@@ -232,28 +232,28 @@ constexpr NonLiteral &ExternNonLiteralVarDecl() {
 static_assert(&ExternNonLiteralVarDecl() == &nl, "");
 constexpr int FuncDecl() {
   constexpr int ForwardDecl(int);
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{use of this statement in a constexpr function is a C++14 extension}}
 #endif
   return ForwardDecl(42);
 }
 constexpr int ClassDecl1() {
   typedef struct { } S1;
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{type definition in a constexpr function is a C++14 extension}}
 #endif
   return 0;
 }
 constexpr int ClassDecl2() {
   using S2 = struct { };
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{type definition in a constexpr function is a C++14 extension}}
 #endif
   return 0;
 }
 constexpr int ClassDecl3() {
   struct S3 { };
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{type definition in a constexpr function is a C++14 extension}}
 #endif
   return 0;
@@ -262,7 +262,7 @@ constexpr int NoReturn() {} // expected-error {{no return statement in constexpr
 constexpr int MultiReturn() {
   return 0;
   return 0;
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{multiple return statements in constexpr function}}
   // expected-note@-4 {{return statement}}
 #endif
@@ -310,7 +310,7 @@ namespace std_example {
   }
   constexpr int abs(int x) {
     if (x < 0)
-#ifndef CXX1Y
+#ifndef CXX14
       // expected-error@-2 {{C++14}}
 #endif
       x = -x;
@@ -322,7 +322,7 @@ namespace std_example {
   }
   constexpr int uninit() {
     int a;
-#ifndef CXX2A
+#ifndef CXX20
     // expected-error@-2 {{uninitialized}}
 #endif
     return a;
@@ -330,7 +330,7 @@ namespace std_example {
   constexpr int prev(int x) {
     return --x;
   }
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-4 {{never produces a constant expression}}
   // expected-note@-4 {{subexpression}}
 #endif
@@ -339,7 +339,7 @@ namespace std_example {
     while (--n > 0) r *= x;
     return r;
   }
-#ifndef CXX1Y
+#ifndef CXX14
     // expected-error@-5 {{C++14}}
     // expected-error@-5 {{statement not allowed}}
 #endif
diff --git a/clang/test/CXX/dcl.dcl/dcl.spec/dcl.constexpr/p4.cpp b/clang/test/CXX/dcl.dcl/dcl.spec/dcl.constexpr/p4.cpp
index 39088042251..aed2f29f67c 100644
--- a/clang/test/CXX/dcl.dcl/dcl.spec/dcl.constexpr/p4.cpp
+++ b/clang/test/CXX/dcl.dcl/dcl.spec/dcl.constexpr/p4.cpp
@@ -1,6 +1,6 @@
-// RUN: %clang_cc1 -verify -std=c++11 -fcxx-exceptions -Werror=c++1y-extensions -Werror=c++2a-extensions %s
-// RUN: %clang_cc1 -verify -std=c++1y -fcxx-exceptions -DCXX1Y -Werror=c++2a-extensions %s
-// RUN: %clang_cc1 -verify -std=c++2a -fcxx-exceptions -DCXX1Y -DCXX2A %s
+// RUN: %clang_cc1 -verify -std=c++11 -fcxx-exceptions -Werror=c++14-extensions -Werror=c++20-extensions %s
+// RUN: %clang_cc1 -verify -std=c++14 -fcxx-exceptions -DCXX14 -Werror=c++20-extensions %s
+// RUN: %clang_cc1 -verify -std=c++20 -fcxx-exceptions -DCXX14 -DCXX2A %s
 
 namespace N {
   typedef char C;
@@ -52,10 +52,10 @@ struct U {
   constexpr U()
     try
 #ifndef CXX2A
-  // expected-error@-2 {{function try block in constexpr constructor is a C++2a extension}}
+  // expected-error@-2 {{function try block in constexpr constructor is a C++20 extension}}
 #endif
     : u() {
-#ifndef CXX1Y
+#ifndef CXX14
   // expected-error@-2 {{use of this statement in a constexpr constructor is a C++14 extension}}
 #endif
   } catch (...) {
@@ -92,43 +92,43 @@ struct V {
   constexpr V(int(&)[1]) {
     for (int n = 0; n < 10; ++n)
       /**/;
-#ifndef CXX1Y
+#ifndef CXX14
     // expected-error@-3 {{statement not allowed in constexpr constructor}}
 #endif
   }
   constexpr V(int(&)[2]) {
     constexpr int a = 0;
-#ifndef CXX1Y
+#ifndef CXX14
     // expected-error@-2 {{variable declaration in a constexpr constructor is a C++14 extension}}
 #endif
   }
   constexpr V(int(&)[3]) {
     constexpr int ForwardDecl(int);
-#ifndef CXX1Y
+#ifndef CXX14
     // expected-error@-2 {{use of this statement in a constexpr constructor is a C++14 extension}}
 #endif
   }
   constexpr V(int(&)[4]) {
     typedef struct { } S1;
-#ifndef CXX1Y
+#ifndef CXX14
     // expected-error@-2 {{type definition in a constexpr constructor is a C++14 extension}}
 #endif
   }
   constexpr V(int(&)[5]) {
     using S2 = struct { };
-#ifndef CXX1Y
+#ifndef CXX14
     // expected-error@-2 {{type definition in a constexpr constructor is a C++14 extension}}
 #endif
   }
   constexpr V(int(&)[6]) {
     struct S3 { };
-#ifndef CXX1Y
+#ifndef CXX14
     // expected-error@-2 {{type definition in a constexpr constructor is a C++14 extension}}
 #endif
   }
   constexpr V(int(&)[7]) {
     return;
-#ifndef CXX1Y
+#ifndef CXX14
     // expected-error@-2 {{use of this statement in a constexpr constructor is a C++14 extension}}
 #endif
   }
diff --git a/clang/test/CXX/dcl.decl/dcl.fct.def/dcl.fct.def.default/p1.cpp b/clang/test/CXX/dcl.decl/dcl.fct.def/dcl.fct.def.default/p1.cpp
index 6e9b45903d3..9614a172419 100644
--- a/clang/test/CXX/dcl.decl/dcl.fct.def/dcl.fct.def.default/p1.cpp
+++ b/clang/test/CXX/dcl.decl/dcl.fct.def/dcl.fct.def.default/p1.cpp
@@ -1,10 +1,10 @@
-// RUN: %clang_cc1 -verify=expected,pre2a %s -std=c++11
-// RUN: %clang_cc1 -verify=expected,pre2a %s -std=c++17
-// RUN: %clang_cc1 -verify=expected %s -std=c++2a
+// RUN: %clang_cc1 -verify=expected,pre20 %s -std=c++11
+// RUN: %clang_cc1 -verify=expected,pre20 %s -std=c++17
+// RUN: %clang_cc1 -verify=expected %s -std=c++20
 
 // A function that is explicitly defaulted shall
 struct A {
-  // -- be a special member function [C++2a: or a comparison operator function],
+  // -- be a special member function [C++20: or a comparison operator function],
   A(int) = default;
 #if __cplusplus <= 201703L
   // expected-error@-2 {{only special member functions may be defaulted}}
@@ -14,13 +14,13 @@ struct A {
   A(A) = default; // expected-error {{must pass its first argument by reference}}
   void f(A) = default; // expected-error-re {{only special member functions{{( and comparison operators)?}} may be defaulted}}
 
-  bool operator==(const A&) const = default; // pre2a-warning {{defaulted comparison operators are a C++20 extension}}
-  bool operator!=(const A&) const = default; // pre2a-warning {{defaulted comparison operators are a C++20 extension}}
-  bool operator<(const A&) const = default; // pre2a-error {{only special member functions may be defaulted}}
-  bool operator>(const A&) const = default; // pre2a-error {{only special member functions may be defaulted}}
-  bool operator<=(const A&) const = default; // pre2a-error {{only special member functions may be defaulted}}
-  bool operator>=(const A&) const = default; // pre2a-error {{only special member functions may be defaulted}}
-  bool operator<=>(const A&) const = default; // pre2a-error 1+{{}} pre2a-warning {{'<=>' is a single token in C++2a}}
+  bool operator==(const A&) const = default; // pre20-warning {{defaulted comparison operators are a C++20 extension}}
+  bool operator!=(const A&) const = default; // pre20-warning {{defaulted comparison operators are a C++20 extension}}
+  bool operator<(const A&) const = default; // pre20-error {{only special member functions may be defaulted}}
+  bool operator>(const A&) const = default; // pre20-error {{only special member functions may be defaulted}}
+  bool operator<=(const A&) const = default; // pre20-error {{only special member functions may be defaulted}}
+  bool operator>=(const A&) const = default; // pre20-error {{only special member functions may be defaulted}}
+  bool operator<=>(const A&) const = default; // pre20-error 1+{{}} pre20-warning {{'<=>' is a single token in C++20}}
 
   A operator+(const A&) const = default; // expected-error-re {{only special member functions{{( and comparison operators)?}} may be defaulted}}
 
diff --git a/clang/test/CXX/drs/dr2xx.cpp b/clang/test/CXX/drs/dr2xx.cpp
index 1f625efe2b5..eb325119b94 100644
--- a/clang/test/CXX/drs/dr2xx.cpp
+++ b/clang/test/CXX/drs/dr2xx.cpp
@@ -2,7 +2,7 @@
 // RUN: %clang_cc1 -std=c++11 %s -verify -fexceptions -fcxx-exceptions -pedantic-errors
 // RUN: %clang_cc1 -std=c++14 %s -verify -fexceptions -fcxx-exceptions -pedantic-errors
 // RUN: %clang_cc1 -std=c++17 %s -verify -fexceptions -fcxx-exceptions -pedantic-errors
-// RUN: %clang_cc1 -std=c++2a %s -verify -fexceptions -fcxx-exceptions -pedantic-errors
+// RUN: %clang_cc1 -std=c++20 %s -verify -fexceptions -fcxx-exceptions -pedantic-errors
 
 // PR13819 -- __SIZE_TYPE__ is incompatible.
 typedef __SIZE_TYPE__ size_t; // expected-error 0-1 {{extension}}
@@ -449,8 +449,8 @@ namespace dr241 { // dr241: yes
     template <class T> void g(T t); // expected-note {{candidate}}
   }
   void h(A::B b) {
-    f<3>(b); // expected-error 0-1{{C++2a extension}} expected-error {{no matching}}
-    g<3>(b); // expected-error 0-1{{C++2a extension}}
+    f<3>(b); // expected-error 0-1{{C++20 extension}} expected-error {{no matching}}
+    g<3>(b); // expected-error 0-1{{C++20 extension}}
     A::f<3>(b); // expected-error {{no matching}}
     A::g<3>(b);
     C::f<3>(b); // expected-error {{no matching}}
diff --git a/clang/test/CXX/drs/dr6xx.cpp b/clang/test/CXX/drs/dr6xx.cpp
index 6ff16254582..03842f2a1de 100644
--- a/clang/test/CXX/drs/dr6xx.cpp
+++ b/clang/test/CXX/drs/dr6xx.cpp
@@ -2,7 +2,7 @@
 // RUN: %clang_cc1 -std=c++11 %s -verify -fexceptions -fcxx-exceptions -pedantic-errors -fno-spell-checking
 // RUN: %clang_cc1 -std=c++14 %s -verify -fexceptions -fcxx-exceptions -pedantic-errors -fno-spell-checking
 // RUN: %clang_cc1 -std=c++17 %s -verify -fexceptions -fcxx-exceptions -pedantic-errors -fno-spell-checking
-// RUN: %clang_cc1 -std=c++2a %s -verify -fexceptions -fcxx-exceptions -pedantic-errors -fno-spell-checking
+// RUN: %clang_cc1 -std=c++20 %s -verify -fexceptions -fcxx-exceptions -pedantic-errors -fno-spell-checking
 
 namespace std {
   struct type_info {};
@@ -506,7 +506,7 @@ namespace dr647 { // dr647: yes
     constexpr C(NonLiteral, int) {} // expected-error {{not a literal type}}
     constexpr C() try {} catch (...) {}
 #if __cplusplus <= 201703L
-    // expected-error@-2 {{function try block in constexpr constructor is a C++2a extension}}
+    // expected-error@-2 {{function try block in constexpr constructor is a C++20 extension}}
 #endif
 #if __cplusplus < 201402L
     // expected-error@-5 {{use of this statement in a constexpr constructor is a C++14 extension}}
@@ -1070,7 +1070,7 @@ namespace dr687 { // dr687 (9 c++20, but the issue is still considered open)
     // This is valid in C++20.
     g<int>(a);
 #if __cplusplus <= 201703L
-    // expected-error@-2 {{C++2a extension}}
+    // expected-error@-2 {{C++20 extension}}
 #endif
 
     // This is not.
diff --git a/clang/test/CXX/expr/expr.prim/expr.prim.lambda/p8.cpp b/clang/test/CXX/expr/expr.prim/expr.prim.lambda/p8.cpp
index 1cc1fd974ca..7c95245da4c 100644
--- a/clang/test/CXX/expr/expr.prim/expr.prim.lambda/p8.cpp
+++ b/clang/test/CXX/expr/expr.prim/expr.prim.lambda/p8.cpp
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -std=c++11 %s -verify -Wno-c++1y-extensions
+// RUN: %clang_cc1 -std=c++11 %s -verify -Wno-c++14-extensions
 
 class X0 {
   void explicit_capture() {
@@ -8,7 +8,7 @@ class X0 {
     (void)[this, this] () {}; // expected-error {{'this' can appear only once}}
     (void)[=, foo] () {}; // expected-error {{'&' must precede a capture when}}
     (void)[=, &foo] () {};
-    (void)[=, this] () {}; // expected-warning {{C++2a extension}}
+    (void)[=, this] () {}; // expected-warning {{C++20 extension}}
     (void)[&, foo] () {};
     (void)[&, &foo] () {}; // expected-error {{'&' cannot precede a capture when}} 
     (void)[&, this] () {};
@@ -23,7 +23,7 @@ struct S2 {
 void S2::f(int i) {
   (void)[&, i]{ };
   (void)[&, &i]{ }; // expected-error{{'&' cannot precede a capture when the capture default is '&'}}
-  (void)[=, this]{ }; // expected-warning{{C++2a extension}}
+  (void)[=, this]{ }; // expected-warning{{C++20 extension}}
   (void)[=]{ this->g(i); };
   (void)[i, i]{ }; // expected-error{{'i' can appear only once in a capture list}}
   (void)[i(0), i(1)]{ }; // expected-error{{'i' can appear only once in a capture list}}
diff --git a/clang/test/Driver/unknown-std.cpp b/clang/test/Driver/unknown-std.cpp
index 2122a7468d0..9ce9507567a 100644
--- a/clang/test/Driver/unknown-std.cpp
+++ b/clang/test/Driver/unknown-std.cpp
@@ -15,8 +15,8 @@
 // CHECK-NEXT: note: use 'gnu++14' for 'ISO C++ 2014 with amendments and GNU extensions' standard
 // CHECK-NEXT: note: use 'c++17' for 'ISO C++ 2017 with amendments' standard
 // CHECK-NEXT: note: use 'gnu++17' for 'ISO C++ 2017 with amendments and GNU extensions' standard
-// CHECK-NEXT: note: use 'c++2a' for 'Working draft for ISO C++ 2020' standard
-// CHECK-NEXT: note: use 'gnu++2a' for 'Working draft for ISO C++ 2020 with GNU extensions' standard
+// CHECK-NEXT: note: use 'c++20' for 'ISO C++ 2020 DIS' standard
+// CHECK-NEXT: note: use 'gnu++20' for 'ISO C++ 2020 DIS with GNU extensions' standard
 // CUDA-NEXT: note: use 'cuda' for 'NVIDIA CUDA(tm)' standard
 
 // Make sure that no other output is present.
diff --git a/clang/test/Lexer/cxx2a-spaceship.cpp b/clang/test/Lexer/cxx2a-spaceship.cpp
index 604575ee976..2163a0bf190 100644
--- a/clang/test/Lexer/cxx2a-spaceship.cpp
+++ b/clang/test/Lexer/cxx2a-spaceship.cpp
@@ -1,9 +1,9 @@
 // RUN: %clang_cc1 -std=c++17 %s -verify
-// RUN: %clang_cc1 -std=c++2a %s -verify
-// RUN: %clang_cc1 -std=c++2a %s -verify -Wc++17-compat -DCOMPAT
+// RUN: %clang_cc1 -std=c++20 %s -verify
+// RUN: %clang_cc1 -std=c++20 %s -verify -Wc++17-compat -DCOMPAT
 //
 // RUN: %clang_cc1 -std=c++17 %s -E -o - | FileCheck %s --check-prefix=CXX17
-// RUN: %clang_cc1 -std=c++2a %s -E -o - | FileCheck %s --check-prefix=CXX20
+// RUN: %clang_cc1 -std=c++20 %s -E -o - | FileCheck %s --check-prefix=CXX20
 
 namespace N {
 
@@ -12,19 +12,19 @@ void operator<=(A, A);
 #if __cplusplus > 201703L
 void operator<=>(A, A);
 #ifdef COMPAT
-// expected-warning@-2 {{'<=>' operator is incompatible with C++ standards before C++2a}}
+// expected-warning@-2 {{'<=>' operator is incompatible with C++ standards before C++20}}
 #endif
 #endif
 
 template<auto> struct X {};
 X<operator<=>
 #if __cplusplus <= 201703L
-  // expected-warning@-2 {{'<=>' is a single token in C++2a; add a space to avoid a change in behavior}}
+  // expected-warning@-2 {{'<=>' is a single token in C++20; add a space to avoid a change in behavior}}
 #else
   >
 #endif
 #ifdef COMPAT
-// expected-warning@-7 {{'<=>' operator is incompatible with C++ standards before C++2a}}
+// expected-warning@-7 {{'<=>' operator is incompatible with C++ standards before C++20}}
 #endif
   x;
 }
diff --git a/clang/test/Lexer/cxx2a_keyword_as_cxx17.cpp b/clang/test/Lexer/cxx2a_keyword_as_cxx17.cpp
index a2e86931e9c..ec42e219494 100644
--- a/clang/test/Lexer/cxx2a_keyword_as_cxx17.cpp
+++ b/clang/test/Lexer/cxx2a_keyword_as_cxx17.cpp
@@ -1,15 +1,15 @@
-// RUN: %clang_cc1 %s -verify -fsyntax-only -Wc++2a-compat -std=c++17
+// RUN: %clang_cc1 %s -verify -fsyntax-only -Wc++20-compat -std=c++17
 
 #define concept constexpr bool
 template<typename T>
 concept x = 0;
 #undef concept
 
-int co_await = 0; // expected-warning {{'co_await' is a keyword in C++2a}}
-int co_return = 0; // expected-warning {{'co_return' is a keyword in C++2a}}
-int co_yield = 0; // expected-warning {{'co_yield' is a keyword in C++2a}}
-int char8_t = 0; // expected-warning {{'char8_t' is a keyword in C++2a}}
-int concept = 0; // expected-warning {{'concept' is a keyword in C++2a}}
-int requires = 0; // expected-warning {{'requires' is a keyword in C++2a}}
-int consteval = 0; // expected-warning {{'consteval' is a keyword in C++2a}}
-int constinit = 0; // expected-warning {{'constinit' is a keyword in C++2a}}
+int co_await = 0; // expected-warning {{'co_await' is a keyword in C++20}}
+int co_return = 0; // expected-warning {{'co_return' is a keyword in C++20}}
+int co_yield = 0; // expected-warning {{'co_yield' is a keyword in C++20}}
+int char8_t = 0; // expected-warning {{'char8_t' is a keyword in C++20}}
+int concept = 0; // expected-warning {{'concept' is a keyword in C++20}}
+int requires = 0; // expected-warning {{'requires' is a keyword in C++20}}
+int consteval = 0; // expected-warning {{'consteval' is a keyword in C++20}}
+int constinit = 0; // expected-warning {{'constinit' is a keyword in C++20}}
diff --git a/clang/test/Parser/cxx1z-decomposition.cpp b/clang/test/Parser/cxx1z-decomposition.cpp
index ccd77064a23..b791870eeda 100644
--- a/clang/test/Parser/cxx1z-decomposition.cpp
+++ b/clang/test/Parser/cxx1z-decomposition.cpp
@@ -1,5 +1,5 @@
-// RUN: %clang_cc1 -std=c++1z %s -verify -fcxx-exceptions
-// RUN: not %clang_cc1 -std=c++1z %s -emit-llvm-only -fcxx-exceptions
+// RUN: %clang_cc1 -std=c++17 %s -verify -fcxx-exceptions
+// RUN: not %clang_cc1 -std=c++17 %s -emit-llvm-only -fcxx-exceptions
 
 struct S { int a, b, c; };
 
@@ -67,8 +67,8 @@ namespace BadSpecifiers {
   struct S { int n; } s;
   void f() {
     // storage-class-specifiers
-    static auto &[a] = n; // expected-warning {{declared 'static' is a C++2a extension}}
-    thread_local auto &[b] = n; // expected-warning {{declared 'thread_local' is a C++2a extension}}
+    static auto &[a] = n; // expected-warning {{declared 'static' is a C++20 extension}}
+    thread_local auto &[b] = n; // expected-warning {{declared 'thread_local' is a C++20 extension}}
     extern auto &[c] = n; // expected-error {{cannot be declared 'extern'}} expected-error {{cannot have an initializer}}
     struct S {
       mutable auto &[d] = n; // expected-error {{not permitted in this context}}
@@ -85,7 +85,7 @@ namespace BadSpecifiers {
   }
 
   static constexpr inline thread_local auto &[j1] = n; // expected-error {{cannot be declared with 'constexpr inline' specifiers}}
-  static thread_local auto &[j2] = n; // expected-warning {{declared with 'static thread_local' specifiers is a C++2a extension}}
+  static thread_local auto &[j2] = n; // expected-warning {{declared with 'static thread_local' specifiers is a C++20 extension}}
 
   inline auto &[k] = n; // expected-error {{cannot be declared 'inline'}}
 
diff --git a/clang/test/Parser/cxx2a-concept-declaration.cpp b/clang/test/Parser/cxx2a-concept-declaration.cpp
index ed88fce17c7..a7c69c29dd6 100644
--- a/clang/test/Parser/cxx2a-concept-declaration.cpp
+++ b/clang/test/Parser/cxx2a-concept-declaration.cpp
@@ -1,6 +1,6 @@
 // Support parsing of concepts
 
-// RUN:  %clang_cc1 -std=c++2a -verify %s
+// RUN:  %clang_cc1 -std=c++20 -verify %s
 template<typename T> concept C1 = true; // expected-note 2{{previous}}
 
 template<typename T> concept C1 = true; // expected-error{{redefinition}}
@@ -50,7 +50,7 @@ template <bool word> concept C6 = integral_constant<bool, wor>::value;
 // expected-note@-2{{'word' declared here}}
 
 template<typename T> concept bool C7 = true;
-// expected-warning@-1{{ISO C++2a does not permit the 'bool' keyword after 'concept'}}
+// expected-warning@-1{{ISO C++20 does not permit the 'bool' keyword after 'concept'}}
 
 template<> concept C8 = false;
 // expected-error@-1{{concept template parameter list must have at least one parameter; explicit specialization of concepts is not allowed}}
diff --git a/clang/test/Parser/cxx2a-inline-nested-namespace-definition.cpp b/clang/test/Parser/cxx2a-inline-nested-namespace-definition.cpp
index 660287c83fc..f37dc8c033c 100644
--- a/clang/test/Parser/cxx2a-inline-nested-namespace-definition.cpp
+++ b/clang/test/Parser/cxx2a-inline-nested-namespace-definition.cpp
@@ -1,6 +1,6 @@
 // RUN: %clang_cc1 -fsyntax-only -verify %s -std=c++14
 // RUN: %clang_cc1 -fsyntax-only -verify %s -std=c++17
-// RUN: %clang_cc1 -fsyntax-only -verify %s -std=c++2a -Wc++17-compat
+// RUN: %clang_cc1 -fsyntax-only -verify %s -std=c++20 -Wc++17-compat
 
 namespace inline foo1::foo2::foo3 { // expected-error {{expected identifier or '{'}} expected-error {{use of undeclared identifier 'foo1'}}
 }
@@ -10,11 +10,11 @@ inline namespace foo4::foo5::foo6 { // expected-error {{nested namespace definit
 
 #if __cplusplus <= 201402L
 // expected-warning@+7 {{nested namespace definition is a C++17 extension; define each namespace separately}}
-// expected-warning@+6 {{inline nested namespace definition is a C++2a extension}}
+// expected-warning@+6 {{inline nested namespace definition is a C++20 extension}}
 #elif __cplusplus <= 201703L
-// expected-warning@+4 {{inline nested namespace definition is a C++2a extension}}
+// expected-warning@+4 {{inline nested namespace definition is a C++20 extension}}
 #else
-// expected-warning@+2 {{inline nested namespace definition is incompatible with C++ standards before C++2a}}
+// expected-warning@+2 {{inline nested namespace definition is incompatible with C++ standards before C++20}}
 #endif
 namespace valid1::valid2::inline valid3::inline valid4::valid5 {}
 // expected-note@-1 2 {{previous definition is here}}
@@ -27,11 +27,11 @@ namespace valid1::valid2::valid3::valid4::valid5 {}
 
 #if __cplusplus <= 201402L
 // expected-warning@+7 {{nested namespace definition is a C++17 extension; define each namespace separately}}
-// expected-warning@+6 {{inline nested namespace definition is a C++2a extension}}
+// expected-warning@+6 {{inline nested namespace definition is a C++20 extension}}
 #elif __cplusplus <= 201703L
-// expected-warning@+4 {{inline nested namespace definition is a C++2a extension}}
+// expected-warning@+4 {{inline nested namespace definition is a C++20 extension}}
 #else
-// expected-warning@+2 {{inline nested namespace definition is incompatible with C++ standards before C++2a}}
+// expected-warning@+2 {{inline nested namespace definition is incompatible with C++ standards before C++20}}
 #endif
 namespace valid1::valid2::inline valid3::inline valid4::valid5 {}
 // expected-note@-1 2 {{previous definition is here}}
diff --git a/clang/test/Parser/explicit-bool.cpp b/clang/test/Parser/explicit-bool.cpp
index bdd91dbbafc..aa700bcfd28 100644
--- a/clang/test/Parser/explicit-bool.cpp
+++ b/clang/test/Parser/explicit-bool.cpp
@@ -1,18 +1,18 @@
-// RUN: %clang_cc1 -std=c++17 -verify=cxx17 -Wc++2a-compat %s
-// RUN: %clang_cc1 -std=c++2a -verify=cxx2a -Wc++17-compat %s
+// RUN: %clang_cc1 -std=c++17 -verify=cxx17 -Wc++20-compat %s
+// RUN: %clang_cc1 -std=c++20 -verify=cxx20 -Wc++17-compat %s
 
 namespace disambig {
 
 // Cases that are valid in C++17 and before, ill-formed in C++20, and that we
 // should not treat as explicit(bool) as an extension.
-struct A { // cxx2a-note +{{}}
+struct A { // cxx20-note +{{}}
   constexpr A() {}
   constexpr operator bool() { return true; }
 
   constexpr explicit (A)(int); // #1
   // cxx17-warning@#1 {{will be parsed as explicit(bool)}}
-  // cxx2a-error@#1 +{{}} cxx2a-note@#1 +{{}}
-  // cxx2a-warning@#1 {{incompatible with C++ standards before C++2a}}
+  // cxx20-error@#1 +{{}} cxx20-note@#1 +{{}}
+  // cxx20-warning@#1 {{incompatible with C++ standards before C++20}}
 
   // This is ill-formed (via a DR change), and shouldn't be recognized as a
   // constructor (the function declarator cannot be parenthesized in a
@@ -21,19 +21,19 @@ struct A { // cxx2a-note +{{}}
   // FIXME: Produce an ExtWarn for this.
   constexpr explicit (A(float)); // #1b
   // cxx17-warning@#1b {{will be parsed as explicit(bool)}}
-  // cxx2a-error@#1b +{{}}
-  // cxx2a-warning@#1b {{incompatible with C++ standards before C++2a}}
+  // cxx20-error@#1b +{{}}
+  // cxx20-warning@#1b {{incompatible with C++ standards before C++20}}
 
   explicit (operator int)(); // #2
   // cxx17-warning@#2 {{will be parsed as explicit(bool)}}
-  // cxx2a-error@#2 +{{}}
-  // cxx2a-warning@#2 {{incompatible with C++ standards before C++2a}}
+  // cxx20-error@#2 +{{}}
+  // cxx20-warning@#2 {{incompatible with C++ standards before C++20}}
 
   explicit (A::operator float)(); // #2b
   // cxx17-warning@#2b {{will be parsed as explicit(bool)}}
   // cxx17-error@#2b {{extra qualification on member}}
-  // cxx2a-error@#2b +{{}}
-  // cxx2a-warning@#2b {{incompatible with C++ standards before C++2a}}
+  // cxx20-error@#2b +{{}}
+  // cxx20-warning@#2b {{incompatible with C++ standards before C++20}}
 };
 
 constexpr bool operator+(A) { return true; }
@@ -45,18 +45,18 @@ constexpr bool C = false;
 struct B {
   // Looks like a constructor, but not the constructor of B.
   explicit (A()) B(); // #3
-  // cxx17-warning@#3 {{C++2a extension}}
-  // cxx2a-warning@#3 {{incompatible with C++ standards before C++2a}}
+  // cxx17-warning@#3 {{C++20 extension}}
+  // cxx20-warning@#3 {{incompatible with C++ standards before C++20}}
 
   // Looks like a 'constructor' of C. Actually a constructor of B.
   explicit (C)(B)(A); // #4
-  // cxx17-warning@#4 {{C++2a extension}}
-  // cxx2a-warning@#4 {{incompatible with C++ standards before C++2a}}
+  // cxx17-warning@#4 {{C++20 extension}}
+  // cxx20-warning@#4 {{incompatible with C++ standards before C++20}}
 
   explicit (operator+(A())) operator int(); // #5
   // cxx17-error@#5 {{requires a type specifier}} cxx17-error@#5 {{expected ';'}}
   // cxx17-warning@#5 {{will be parsed as explicit(bool)}}
-  // cxx2a-warning@#5 {{incompatible with C++ standards before C++2a}}
+  // cxx20-warning@#5 {{incompatible with C++ standards before C++20}}
 };
 
 }
diff --git a/clang/test/Preprocessor/init.c b/clang/test/Preprocessor/init.c
index e25946304d0..6966698549a 100644
--- a/clang/test/Preprocessor/init.c
+++ b/clang/test/Preprocessor/init.c
@@ -9,15 +9,17 @@
 // BLOCKS:#define __block __attribute__((__blocks__(byref)))
 //
 //
+// RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=c++20 -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix CXX2A %s
 // RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=c++2a -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix CXX2A %s
 //
 // CXX2A:#define __GNUG__ 4
 // CXX2A:#define __GXX_EXPERIMENTAL_CXX0X__ 1
 // CXX2A:#define __GXX_RTTI 1
 // CXX2A:#define __GXX_WEAK__ 1
-// CXX2A:#define __cplusplus 201707L
+// CXX2A:#define __cplusplus 202002L
 // CXX2A:#define __private_extern__ extern
 //
+// RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=c++17 -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix CXX1Z %s
 // RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=c++1z -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix CXX1Z %s
 //
 // CXX1Z:#define __GNUG__ 4
@@ -28,6 +30,7 @@
 // CXX1Z:#define __private_extern__ extern
 //
 //
+// RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=c++14 -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix CXX1Y %s
 // RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=c++1y -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix CXX1Y %s
 //
 // CXX1Y:#define __GNUG__ 4
@@ -119,14 +122,16 @@
 // RUN: %clang_cc1 -ffreestanding -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix FREESTANDING %s
 // FREESTANDING:#define __STDC_HOSTED__ 0
 //
+// RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=gnu++20 -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix GXX2A %s
 // RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=gnu++2a -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix GXX2A %s
 //
 // GXX2A:#define __GNUG__ 4
 // GXX2A:#define __GXX_WEAK__ 1
-// GXX2A:#define __cplusplus 201707L
+// GXX2A:#define __cplusplus 202002L
 // GXX2A:#define __private_extern__ extern
 //
 //
+// RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=gnu++17 -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix GXX1Z %s
 // RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=gnu++1z -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix GXX1Z %s
 //
 // GXX1Z:#define __GNUG__ 4
@@ -135,6 +140,7 @@
 // GXX1Z:#define __private_extern__ extern
 //
 //
+// RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=gnu++14 -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix GXX1Y %s
 // RUN: %clang_cc1 -x c++ -fgnuc-version=4.2.1 -std=gnu++1y -E -dM < /dev/null | FileCheck -match-full-lines -check-prefix GXX1Y %s
 //
 // GXX1Y:#define __GNUG__ 4
diff --git a/clang/test/SemaCXX/cxx17-compat.cpp b/clang/test/SemaCXX/cxx17-compat.cpp
index e063b1fc180..b65ed3ea340 100644
--- a/clang/test/SemaCXX/cxx17-compat.cpp
+++ b/clang/test/SemaCXX/cxx17-compat.cpp
@@ -1,30 +1,30 @@
 // RUN: %clang_cc1 -fsyntax-only -std=c++17 -pedantic -verify %s
-// RUN: %clang_cc1 -fsyntax-only -std=c++2a -Wc++17-compat-pedantic -verify %s -Wno-defaulted-function-deleted
+// RUN: %clang_cc1 -fsyntax-only -std=c++20 -Wc++17-compat-pedantic -verify %s -Wno-defaulted-function-deleted
 
 struct A {};
 int (A::*pa)() const&;
 int use_pa = (A().*pa)();
 #if __cplusplus <= 201703L
-  // expected-warning@-2 {{invoking a pointer to a 'const &' member function on an rvalue is a C++2a extension}}
+  // expected-warning@-2 {{invoking a pointer to a 'const &' member function on an rvalue is a C++20 extension}}
 #else
-  // expected-warning@-4 {{invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++2a}}
+  // expected-warning@-4 {{invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20}}
 #endif
 
 struct B {
   void b() {
     (void) [=, this] {};
 #if __cplusplus <= 201703L
-    // expected-warning@-2 {{explicit capture of 'this' with a capture default of '=' is a C++2a extension}}
+    // expected-warning@-2 {{explicit capture of 'this' with a capture default of '=' is a C++20 extension}}
 #else
-    // expected-warning@-4 {{explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a}}
+    // expected-warning@-4 {{explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20}}
 #endif
   }
 
   int n : 5 = 0;
 #if __cplusplus <= 201703L
-    // expected-warning@-2 {{default member initializer for bit-field is a C++2a extension}}
+    // expected-warning@-2 {{default member initializer for bit-field is a C++20 extension}}
 #else
-    // expected-warning@-4 {{default member initializer for bit-field is incompatible with C++ standards before C++2a}}
+    // expected-warning@-4 {{default member initializer for bit-field is incompatible with C++ standards before C++20}}
 #endif
 };
 
@@ -33,14 +33,14 @@ decltype(Lambda) AnotherLambda;
 #if __cplusplus <= 201703L
     // expected-error@-2 {{no matching constructor}} expected-note@-3 2{{candidate}}
 #else
-    // expected-warning@-4 {{default construction of lambda is incompatible with C++ standards before C++2a}}
+    // expected-warning@-4 {{default construction of lambda is incompatible with C++ standards before C++20}}
 #endif
 
 void copy_lambda() { Lambda = Lambda; }
 #if __cplusplus <= 201703L
     // expected-error@-2 {{deleted}} expected-note@-10 {{lambda}}
 #else
-    // expected-warning@-4 {{assignment of lambda is incompatible with C++ standards before C++2a}}
+    // expected-warning@-4 {{assignment of lambda is incompatible with C++ standards before C++20}}
 #endif
 
 struct DefaultDeleteWrongTypeBase {
@@ -51,16 +51,16 @@ struct DefaultDeleteWrongType : DefaultDeleteWrongTypeBase {
 #if __cplusplus <= 201703L
     // expected-error@-2 {{a member or base requires it to be non-const}}
 #else
-    // expected-warning@-4 {{explicitly defaulting this copy constructor with a type different from the implicit type is incompatible with C++ standards before C++2a}}
+    // expected-warning@-4 {{explicitly defaulting this copy constructor with a type different from the implicit type is incompatible with C++ standards before C++20}}
 #endif
 };
 
 void ForRangeInit() {
   for (int arr[3] = {1, 2, 3}; int n : arr) {}
 #if __cplusplus <= 201703L
-    // expected-warning@-2 {{range-based for loop initialization statements are a C++2a extension}}
+    // expected-warning@-2 {{range-based for loop initialization statements are a C++20 extension}}
 #else
-    // expected-warning@-4 {{range-based for loop initialization statements are incompatible with C++ standards before C++2a}}
+    // expected-warning@-4 {{range-based for loop initialization statements are incompatible with C++ standards before C++20}}
 #endif
 }
 
@@ -69,23 +69,23 @@ struct ConstexprVirtual {
 #if __cplusplus <= 201703L
     // expected-error@-2 {{virtual function cannot be constexpr}}
 #else
-    // expected-warning@-4 {{virtual constexpr functions are incompatible with C++ standards before C++2a}}
+    // expected-warning@-4 {{virtual constexpr functions are incompatible with C++ standards before C++20}}
 #endif
 };
 
 struct C { int x, y, z; };
 static auto [cx, cy, cz] = C();
 #if __cplusplus <= 201703L
-    // expected-warning@-2 {{decomposition declaration declared 'static' is a C++2a extension}}
+    // expected-warning@-2 {{decomposition declaration declared 'static' is a C++20 extension}}
 #else
-    // expected-warning@-4 {{decomposition declaration declared 'static' is incompatible with C++ standards before C++2a}}
+    // expected-warning@-4 {{decomposition declaration declared 'static' is incompatible with C++ standards before C++20}}
 #endif
 void f() {
   static thread_local auto [cx, cy, cz] = C();
 #if __cplusplus <= 201703L
-    // expected-warning@-2 {{decomposition declaration declared with 'static thread_local' specifiers is a C++2a extension}}
+    // expected-warning@-2 {{decomposition declaration declared with 'static thread_local' specifiers is a C++20 extension}}
 #else
-    // expected-warning@-4 {{decomposition declaration declared with 'static thread_local' specifiers is incompatible with C++ standards before C++2a}}
+    // expected-warning@-4 {{decomposition declaration declared with 'static thread_local' specifiers is incompatible with C++ standards before C++20}}
 #endif
 }
 
@@ -103,7 +103,7 @@ struct DefaultedComparisons {
 #if __cplusplus <= 201703L
   // expected-error@-2 {{'operator<=' cannot be the name of a variable or data member}} expected-error@-2 0+{{}} expected-warning@-2 {{}}
 #else
-  // expected-warning@-4 {{'<=>' operator is incompatible with C++ standards before C++2a}}
+  // expected-warning@-4 {{'<=>' operator is incompatible with C++ standards before C++20}}
 #endif
   bool operator<(const DefaultedComparisons&) const = default;
   bool operator<=(const DefaultedComparisons&) const = default;
diff --git a/clang/test/SemaCXX/cxx1z-constexpr-lambdas.cpp b/clang/test/SemaCXX/cxx1z-constexpr-lambdas.cpp
index 2e0bbaa31c7..d7ebfdc3133 100644
--- a/clang/test/SemaCXX/cxx1z-constexpr-lambdas.cpp
+++ b/clang/test/SemaCXX/cxx1z-constexpr-lambdas.cpp
@@ -1,5 +1,5 @@
 // RUN: %clang_cc1 -std=c++1z -verify -fsyntax-only -fblocks %s -fcxx-exceptions
-// RUN: %clang_cc1 -std=c++2a -verify -fsyntax-only -fblocks %s -fcxx-exceptions
+// RUN: %clang_cc1 -std=c++20 -verify -fsyntax-only -fblocks %s -fcxx-exceptions
 // RUN: %clang_cc1 -std=c++1z -verify -fsyntax-only -fblocks -fdelayed-template-parsing %s -fcxx-exceptions
 // RUN: %clang_cc1 -std=c++14 -verify -fsyntax-only -fblocks %s -DCPP14_AND_EARLIER -fcxx-exceptions
 
@@ -25,7 +25,7 @@ namespace ns1 {
 namespace ns2 {
   auto L = [](int I) constexpr { if (I == 5) asm("non-constexpr");  };
 #if __cpp_constexpr < 201907L
-  //expected-warning@-2{{use of this statement in a constexpr function is a C++2a extension}}
+  //expected-warning@-2{{use of this statement in a constexpr function is a C++20 extension}}
 #endif
 } // end ns1
 
diff --git a/clang/test/SemaCXX/cxx1z-decomposition.cpp b/clang/test/SemaCXX/cxx1z-decomposition.cpp
index d2dc939beb5..336c103ef0a 100644
--- a/clang/test/SemaCXX/cxx1z-decomposition.cpp
+++ b/clang/test/SemaCXX/cxx1z-decomposition.cpp
@@ -1,4 +1,4 @@
-// RUN: %clang_cc1 -std=c++1z -verify %s
+// RUN: %clang_cc1 -std=c++17 -verify %s
 
 void use_from_own_init() {
   auto [a] = a; // expected-error {{binding 'a' cannot appear in the initializer of its own decomposition declaration}}
@@ -83,7 +83,7 @@ template <class T> void dependent_foreach(T t) {
 
 struct PR37352 {
   int n;
-  void f() { static auto [a] = *this; } // expected-warning {{C++2a extension}}
+  void f() { static auto [a] = *this; } // expected-warning {{C++20 extension}}
 };
 
 namespace instantiate_template {
diff --git a/clang/test/SemaCXX/cxx2a-compat.cpp b/clang/test/SemaCXX/cxx2a-compat.cpp
index c8d22b73107..de9d4442a45 100644
--- a/clang/test/SemaCXX/cxx2a-compat.cpp
+++ b/clang/test/SemaCXX/cxx2a-compat.cpp
@@ -1,5 +1,5 @@
-// RUN: %clang_cc1 -fsyntax-only -std=c++17 -Wc++2a-compat-pedantic -verify %s
-// RUN: %clang_cc1 -fsyntax-only -std=c++2a -pedantic -verify %s
+// RUN: %clang_cc1 -fsyntax-only -std=c++17 -Wc++20-compat-pedantic -verify %s
+// RUN: %clang_cc1 -fsyntax-only -std=c++20 -pedantic -verify %s
 
 struct A { // expected-note 0+{{candidate}}
   A() = default; // expected-note 0+{{candidate}}
@@ -7,7 +7,7 @@ struct A { // expected-note 0+{{candidate}}
 };
 A a1 = {1, 2};
 #if __cplusplus <= 201703L
-  // expected-warning@-2 {{aggregate initialization of type 'A' with user-declared constructors is incompatible with C++2a}}
+  // expected-warning@-2 {{aggregate initialization of type 'A' with user-declared constructors is incompatible with C++20}}
 #else
   // expected-error@-4 {{no matching constructor}}
 #endif
@@ -17,7 +17,7 @@ struct B : A { A a; };
 B b1 = {{}, {}}; // ok
 B b2 = {1, 2, 3, 4};
 #if __cplusplus <= 201703L
-  // expected-warning@-2 2{{aggregate initialization of type 'A' with user-declared constructors is incompatible with C++2a}}
+  // expected-warning@-2 2{{aggregate initialization of type 'A' with user-declared constructors is incompatible with C++20}}
 #else
   // expected-error@-4 2{{no viable conversion from 'int' to 'A'}}
 #endif
@@ -43,7 +43,7 @@ struct C {
   explicit(C)(int);
 };
 #if __cplusplus <= 201703L
-// expected-warning@-3 {{this expression will be parsed as explicit(bool) in C++2a}}
+// expected-warning@-3 {{this expression will be parsed as explicit(bool) in C++20}}
 #if defined(__cpp_conditional_explicit)
 #error "the feature test macro __cpp_conditional_explicit isn't correct"
 #endif
@@ -61,8 +61,8 @@ struct C {
 auto l = []() consteval {};
 int consteval();
 #if __cplusplus <= 201703L
-// expected-warning@-3 {{'consteval' is a keyword in C++2a}}
+// expected-warning@-3 {{'consteval' is a keyword in C++20}}
 // expected-error@-4 {{expected body of lambda expression}}
 #else
 // expected-error@-5 {{expected unqualified-id}}
-#endif
\ No newline at end of file
+#endif
diff --git a/clang/test/SemaCXX/cxx2a-initializer-aggregates.cpp b/clang/test/SemaCXX/cxx2a-initializer-aggregates.cpp
index 7dc2500dbbf..653fcf439c1 100644
--- a/clang/test/SemaCXX/cxx2a-initializer-aggregates.cpp
+++ b/clang/test/SemaCXX/cxx2a-initializer-aggregates.cpp
@@ -1,9 +1,9 @@
-// RUN: %clang_cc1 -std=c++2a %s -verify=cxx20,expected,pedantic,override,reorder -pedantic-errors
-// RUN: %clang_cc1 -std=c++17 %s -verify=expected,pedantic,override,reorder -Wno-c++2a-designator -pedantic-errors
-// RUN: %clang_cc1 -std=c++2a %s -verify=cxx20,expected,pedantic -Werror=c99-designator -Wno-reorder-init-list -Wno-initializer-overrides
-// RUN: %clang_cc1 -std=c++2a %s -verify=cxx20,expected,reorder -Wno-c99-designator -Werror=reorder-init-list -Wno-initializer-overrides
-// RUN: %clang_cc1 -std=c++2a %s -verify=cxx20,expected,override -Wno-c99-designator -Wno-reorder-init-list -Werror=initializer-overrides
-// RUN: %clang_cc1 -std=c++2a %s -verify=cxx20,expected -Wno-c99-designator -Wno-reorder-init-list -Wno-initializer-overrides
+// RUN: %clang_cc1 -std=c++20 %s -verify=cxx20,expected,pedantic,override,reorder -pedantic-errors
+// RUN: %clang_cc1 -std=c++17 %s -verify=expected,pedantic,override,reorder -Wno-c++20-designator -pedantic-errors
+// RUN: %clang_cc1 -std=c++20 %s -verify=cxx20,expected,pedantic -Werror=c99-designator -Wno-reorder-init-list -Wno-initializer-overrides
+// RUN: %clang_cc1 -std=c++20 %s -verify=cxx20,expected,reorder -Wno-c99-designator -Werror=reorder-init-list -Wno-initializer-overrides
+// RUN: %clang_cc1 -std=c++20 %s -verify=cxx20,expected,override -Wno-c99-designator -Wno-reorder-init-list -Werror=initializer-overrides
+// RUN: %clang_cc1 -std=c++20 %s -verify=cxx20,expected -Wno-c99-designator -Wno-reorder-init-list -Wno-initializer-overrides
 
 
 namespace class_with_ctor {
diff --git a/clang/test/SemaCXX/member-init.cpp b/clang/test/SemaCXX/member-init.cpp
index f2c06446265..ff5dadea16e 100644
--- a/clang/test/SemaCXX/member-init.cpp
+++ b/clang/test/SemaCXX/member-init.cpp
@@ -1,7 +1,7 @@
 // RUN: %clang_cc1 -fsyntax-only -fcxx-exceptions -verify -std=c++11 -Wall %s
 
 struct Bitfield {
-  int n : 3 = 7; // expected-warning {{C++2a extension}} expected-warning {{changes value from 7 to -1}}
+  int n : 3 = 7; // expected-warning {{C++20 extension}} expected-warning {{changes value from 7 to -1}}
 };
 
 int a;
diff --git a/clang/www/cxx_status.html b/clang/www/cxx_status.html
index 8186057ba72..2cade9e53ea 100755
--- a/clang/www/cxx_status.html
+++ b/clang/www/cxx_status.html
@@ -825,14 +825,13 @@ code. This issue is expected to be rectified soon.
 </p>
 </details>
 
-<h2 id="cxx20">C++2a implementation status</h2>
+<h2 id="cxx20">C++20 implementation status</h2>
 
-<p>Clang has <b>experimental</b> support for some proposed features of
-the C++ standard following C++17, provisionally named C++2a.
-Note that support for these features may change or be removed without notice,
-as the draft C++2a standard evolves.
+<p>Clang has support for some of the features of the
+ISO C++ 2020 Draft International Standard.
 
-<p>You can use Clang in C++2a mode with the <code>-std=c++2a</code> option.</p>
+<p>You can use Clang in C++20 mode with the <code>-std=c++20</code> option
+(use <code>-std=c++2a</code> in Clang 10 and earlier).</p>
 
 <details open>
 <summary>List of features and minimum Clang version with support</summary>
@@ -840,7 +839,7 @@ as the draft C++2a standard evolves.
 <table width="689" border="1" cellspacing="0">
  <tr>
     <th>Language Feature</th>
-    <th>C++2a Proposal</th>
+    <th>C++20 Proposal</th>
     <th>Available in Clang?</th>
  </tr>
     <!-- Toronto 2017 papers -->
@@ -1167,7 +1166,7 @@ as the draft C++2a standard evolves.
 
 <p>
 <span id="p0482">(11): Prior to Clang 8, this feature is not enabled by
-<tt>-std=c++2a</tt>, but can be enabled with <tt>-fchar8_t</tt>.
+<tt>-std=c++20</tt>, but can be enabled with <tt>-fchar8_t</tt>.
 </span>
 </p>
 </details>
@@ -1260,7 +1259,7 @@ and library features that are not part of standard C++.</p>
       <td class="full" align="center">Clang 5</td>
     </tr>
     <tr>
-      <td><tt>-std=c++2a<br>-stdlib=libc++</tt></td>
+      <td><tt>-std=c++20<br>-stdlib=libc++</tt></td>
       <td class="na" align="center">Superseded by <a href="#p0912">P0912R5</a></td>
     </tr>
     <tr>

commit f004359106cfda578733dff1380560b68f9c3713
Author: Nico Weber <thakis@chromium.org>
Date:   Fri Feb 14 15:15:00 2020 -0500

    [windows] Add /Gw to compiler flags
    
    This is like -fdata-sections, and it's not part of /O2 by default for some reason.
    
    In the cmake build, reduces the size of clang.exe from 70,358,016 bytes to 69,982,720 bytes.
    
    clang-format.exe goes from 3,703,296 bytes to 3,331,072 bytes.
    
    Differential Revision: https://reviews.llvm.org/D74573
    
    (cherry picked from commit 09153ab9d267a86d6e9bce18d5074617de5879a5)

diff --git a/llvm/cmake/modules/HandleLLVMOptions.cmake b/llvm/cmake/modules/HandleLLVMOptions.cmake
index ab219e52f9d..30f04ca34c2 100644
--- a/llvm/cmake/modules/HandleLLVMOptions.cmake
+++ b/llvm/cmake/modules/HandleLLVMOptions.cmake
@@ -788,6 +788,10 @@ if(NOT CYGWIN AND NOT WIN32)
     endif()
     add_flag_if_supported("-fdata-sections" FDATA_SECTIONS)
   endif()
+elseif(MSVC)
+  if( NOT uppercase_CMAKE_BUILD_TYPE STREQUAL "DEBUG" )
+    append("/Gw" CMAKE_C_FLAGS CMAKE_CXX_FLAGS)
+  endif()
 endif()
 
 if(MSVC)
diff --git a/llvm/utils/gn/build/BUILD.gn b/llvm/utils/gn/build/BUILD.gn
index b06ef9ad83e..b74268996f1 100644
--- a/llvm/utils/gn/build/BUILD.gn
+++ b/llvm/utils/gn/build/BUILD.gn
@@ -60,6 +60,7 @@ config("compiler_defaults") {
     if (is_optimized) {
       cflags += [
         "/O2",
+        "/Gw",
         "/Zc:inline",
       ]
       ldflags += [

commit 4bcdac8d762794d822819eb6d207a0630c345d0b
Author: Shiva Chen <shiva@andestech.com>
Date:   Fri Feb 14 15:57:11 2020 +0800

    [RISCV] Correct the CallPreservedMask for the function call in an interrupt handler
    
    CallPreservedMask is used to describe the register liveness after a
    function call. The function call in an interrupt handler should use the same
    CallPreservedMask as normal functions. So that only callee save registers
    can live through the function call.
    
    (cherry picked from commit 1cae2f9d192c69833e22684ca338660942ab464e)

diff --git a/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp b/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
index 1d41994ef1e..207742520ed 100644
--- a/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
+++ b/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
@@ -156,13 +156,6 @@ const uint32_t *
 RISCVRegisterInfo::getCallPreservedMask(const MachineFunction & MF,
                                         CallingConv::ID /*CC*/) const {
   auto &Subtarget = MF.getSubtarget<RISCVSubtarget>();
-  if (MF.getFunction().hasFnAttribute("interrupt")) {
-    if (Subtarget.hasStdExtD())
-      return CSR_XLEN_F64_Interrupt_RegMask;
-    if (Subtarget.hasStdExtF())
-      return CSR_XLEN_F32_Interrupt_RegMask;
-    return CSR_Interrupt_RegMask;
-  }
 
   switch (Subtarget.getTargetABI()) {
   default:
diff --git a/llvm/test/CodeGen/RISCV/interrupt-attr-callee.ll b/llvm/test/CodeGen/RISCV/interrupt-attr-callee.ll
new file mode 100644
index 00000000000..457b8667e10
--- /dev/null
+++ b/llvm/test/CodeGen/RISCV/interrupt-attr-callee.ll
@@ -0,0 +1,70 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple riscv32-unknown-elf -o - %s \
+; RUN: 2>&1 | FileCheck %s -check-prefix CHECK-RV32
+; RUN: llc -mtriple riscv32-unknown-elf -mattr=+f -o - %s \
+; RUN: 2>&1 | FileCheck %s -check-prefix CHECK-RV32-F
+; RUN: llc -mtriple riscv32-unknown-elf -mattr=+f,+d -o - %s \
+; RUN: 2>&1 | FileCheck %s -check-prefix CHECK-RV32-FD
+;
+; The test case check that the function call in an interrupt handler will use
+; the correct CallPreservedMask as normal function. So only callee saved
+; registers could live through the function call.
+
+define dso_local void @handler() nounwind {
+; CHECK-RV32-LABEL: handler:
+; CHECK-RV32:       # %bb.0: # %entry
+; CHECK-RV32-NEXT:    addi sp, sp, -16
+; CHECK-RV32-NEXT:    sw ra, 12(sp)
+; CHECK-RV32-NEXT:    sw s0, 8(sp)
+; CHECK-RV32-NEXT:    lui a0, 2
+; CHECK-RV32-NEXT:    addi a0, a0, 4
+; CHECK-RV32-NEXT:    call read
+; CHECK-RV32-NEXT:    mv s0, a0
+; CHECK-RV32-NEXT:    call callee
+; CHECK-RV32-NEXT:    mv a0, s0
+; CHECK-RV32-NEXT:    lw s0, 8(sp)
+; CHECK-RV32-NEXT:    lw ra, 12(sp)
+; CHECK-RV32-NEXT:    addi sp, sp, 16
+; CHECK-RV32-NEXT:    tail write
+;
+; CHECK-RV32-F-LABEL: handler:
+; CHECK-RV32-F:       # %bb.0: # %entry
+; CHECK-RV32-F-NEXT:    addi sp, sp, -16
+; CHECK-RV32-F-NEXT:    sw ra, 12(sp)
+; CHECK-RV32-F-NEXT:    sw s0, 8(sp)
+; CHECK-RV32-F-NEXT:    lui a0, 2
+; CHECK-RV32-F-NEXT:    addi a0, a0, 4
+; CHECK-RV32-F-NEXT:    call read
+; CHECK-RV32-F-NEXT:    mv s0, a0
+; CHECK-RV32-F-NEXT:    call callee
+; CHECK-RV32-F-NEXT:    mv a0, s0
+; CHECK-RV32-F-NEXT:    lw s0, 8(sp)
+; CHECK-RV32-F-NEXT:    lw ra, 12(sp)
+; CHECK-RV32-F-NEXT:    addi sp, sp, 16
+; CHECK-RV32-F-NEXT:    tail write
+;
+; CHECK-RV32-FD-LABEL: handler:
+; CHECK-RV32-FD:       # %bb.0: # %entry
+; CHECK-RV32-FD-NEXT:    addi sp, sp, -16
+; CHECK-RV32-FD-NEXT:    sw ra, 12(sp)
+; CHECK-RV32-FD-NEXT:    sw s0, 8(sp)
+; CHECK-RV32-FD-NEXT:    lui a0, 2
+; CHECK-RV32-FD-NEXT:    addi a0, a0, 4
+; CHECK-RV32-FD-NEXT:    call read
+; CHECK-RV32-FD-NEXT:    mv s0, a0
+; CHECK-RV32-FD-NEXT:    call callee
+; CHECK-RV32-FD-NEXT:    mv a0, s0
+; CHECK-RV32-FD-NEXT:    lw s0, 8(sp)
+; CHECK-RV32-FD-NEXT:    lw ra, 12(sp)
+; CHECK-RV32-FD-NEXT:    addi sp, sp, 16
+; CHECK-RV32-FD-NEXT:    tail write
+entry:
+  %call = tail call i32 @read(i32 8196)
+  tail call void bitcast (void (...)* @callee to void ()*)()
+  tail call void @write(i32 %call)
+  ret void
+}
+
+declare i32 @read(i32)
+declare void @callee(...)
+declare void @write(i32)

commit a572a8a147c76b9d31585c2d4257a5db566c9a9d
Author: Gokturk Yuksek <gokturk@binghamton.edu>
Date:   Mon Feb 17 18:36:18 2020 +0000

    [CMake] CheckAtomic.cmake: catch false positives in RISC-V
    
    The check for 'HAVE_CXX_ATOMICS_WITHOUT_LIB' may create false
    positives in RISC-V. This is reproducible when compiling LLVM natively
    using GCC on a rv64gc (rv64imafdgc) host. Due to the 'A' (atomic)
    extension, g++ replaces calls to libatomic operations on the
    std::atomic<int> type with the native hardware instructions. As a
    result, the compilation succeeds and the build system thinks it
    doesn't need to pass '-latomic'.
    
    Improve the reliability of the 'HAVE_CXX_ATOMICS_WITHOUT_LIB' test in
    two steps:
    
    1. Force a pre-increment on x (++x), which should force a call to a
    libatomic function;
    
    2. Because step 1 would resolve the increment to 'amoadd.w.aq' under
    the 'A' extension, force the same operation on sub-word types, for
    which there is no hardware support.
    
    Reviewers: jfb, hintonda, smeenai, mgorny, JDevlieghere, jyknight
    Reviewed By: jfb
    Tags: #llvm
    Differential Revision: https://reviews.llvm.org/D68964
    
    (cherry picked from commit cef85193b2cc1817ca43199a0ae9c6f25723997d)

diff --git a/llvm/cmake/modules/CheckAtomic.cmake b/llvm/cmake/modules/CheckAtomic.cmake
index 29f3bdd57f0..34ab8e98de4 100644
--- a/llvm/cmake/modules/CheckAtomic.cmake
+++ b/llvm/cmake/modules/CheckAtomic.cmake
@@ -12,8 +12,12 @@ function(check_working_cxx_atomics varname)
   CHECK_CXX_SOURCE_COMPILES("
 #include <atomic>
 std::atomic<int> x;
+std::atomic<short> y;
+std::atomic<char> z;
 int main() {
-  return x;
+  ++z;
+  ++y;
+  return ++x;
 }
 " ${varname})
   set(CMAKE_REQUIRED_FLAGS ${OLD_CMAKE_REQUIRED_FLAGS})

commit 7a18790ae2f4b92dc26b2be963e588c8837d0076
Author: Eric Fiselier <eric@efcs.ca>
Date:   Wed Feb 19 11:59:37 2020 -0500

    [libc++] Fix ABI break in __bit_reference.
    
    The libc++ __bit_iterator type has weird ABI calling conventions as a
    quirk
    of the implementation. The const bit iterator is trivial, but the
    non-const
    bit iterator is not because it declares a user-defined copy constructor.
    
    Changing this now is an ABI break, so this test ensures that each type
    is trivial/non-trivial as expected.
    
    The definition of 'non-trivial for the purposes of calls':
      A type is considered non-trivial for the purposes of calls if:
          * it has a non-trivial copy constructor, move constructor, or
                destructor, or
                    * all of its copy and move constructors are deleted.
    
    (cherry picked from commit a829443cc7359ecf0f2de8f82519f511795675ec)

diff --git a/libcxx/include/__bit_reference b/libcxx/include/__bit_reference
index 3d4da1cbb68..4a2b82064b3 100644
--- a/libcxx/include/__bit_reference
+++ b/libcxx/include/__bit_reference
@@ -1122,6 +1122,21 @@ public:
     __bit_iterator(const __type_for_copy_to_const& __it) _NOEXCEPT
         : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}
 
+    // The non-const __bit_iterator has historically had a non-trivial
+    // copy constructor (as a quirk of its construction). We need to maintain
+    // this for ABI purposes.
+    using __type_for_abi_non_trivial_copy_ctor =
+      _If<!_IsConst, __bit_iterator, struct __private_nat>;
+
+    _LIBCPP_INLINE_VISIBILITY
+    __bit_iterator(__type_for_abi_non_trivial_copy_ctor const& __it) _NOEXCEPT
+      : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}
+
+    // Always declare the copy assignment operator since the implicit declaration
+    // is deprecated.
+    _LIBCPP_INLINE_VISIBILITY
+    __bit_iterator& operator=(__bit_iterator const&) = default;
+
     _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT
         {return reference(__seg_, __storage_type(1) << __ctz_);}
 
diff --git a/libcxx/test/libcxx/containers/sequences/vector.bool/trivial_for_purposes_of_call.pass.cpp b/libcxx/test/libcxx/containers/sequences/vector.bool/trivial_for_purposes_of_call.pass.cpp
new file mode 100644
index 00000000000..7b0b5c427c6
--- /dev/null
+++ b/libcxx/test/libcxx/containers/sequences/vector.bool/trivial_for_purposes_of_call.pass.cpp
@@ -0,0 +1,57 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// <vector>
+
+// typedef ... iterator;
+// typedef ... const_iterator;
+
+// The libc++ __bit_iterator type has weird ABI calling conventions as a quirk
+// of the implementation. The const bit iterator is trivial, but the non-const
+// bit iterator is not because it declares a user-defined copy constructor.
+//
+// Changing this now is an ABI break, so this test ensures that each type
+// is trivial/non-trivial as expected.
+
+// The definition of 'non-trivial for the purposes of calls':
+//   A type is considered non-trivial for the purposes of calls if:
+//     * it has a non-trivial copy constructor, move constructor, or
+//       destructor, or
+//     * all of its copy and move constructors are deleted.
+
+// UNSUPPORTED: c++98, c++03
+
+#include <vector>
+#include <cassert>
+
+#include "test_macros.h"
+
+template <class T>
+using IsTrivialForCall = std::integral_constant<bool,
+  std::is_trivially_copy_constructible<T>::value &&
+  std::is_trivially_move_constructible<T>::value &&
+  std::is_trivially_destructible<T>::value
+  // Ignore the all-deleted case, it shouldn't occur here.
+  >;
+
+void test_const_iterator() {
+  using It = std::vector<bool>::const_iterator;
+  static_assert(IsTrivialForCall<It>::value, "");
+}
+
+void test_non_const_iterator() {
+  using It = std::vector<bool>::iterator;
+  static_assert(!IsTrivialForCall<It>::value, "");
+}
+
+int main(int, char**) {
+  test_const_iterator();
+  test_non_const_iterator();
+
+  return 0;
+}

commit d75ce45777d9802d43b555993fde8ed6562fb368
Author: Hans Wennborg <hans@chromium.org>
Date:   Thu Feb 20 15:41:26 2020 +0100

    Revert "[CMake] CheckAtomic.cmake: catch false positives in RISC-V"
    
    This reverts commit a572a8a147c76b9d31585c2d4257a5db566c9a9d.
    
    Apparently it was part of a larger series, and I'm not planning on
    merging that; see https://reviews.llvm.org/D68964

diff --git a/llvm/cmake/modules/CheckAtomic.cmake b/llvm/cmake/modules/CheckAtomic.cmake
index 34ab8e98de4..29f3bdd57f0 100644
--- a/llvm/cmake/modules/CheckAtomic.cmake
+++ b/llvm/cmake/modules/CheckAtomic.cmake
@@ -12,12 +12,8 @@ function(check_working_cxx_atomics varname)
   CHECK_CXX_SOURCE_COMPILES("
 #include <atomic>
 std::atomic<int> x;
-std::atomic<short> y;
-std::atomic<char> z;
 int main() {
-  ++z;
-  ++y;
-  return ++x;
+  return x;
 }
 " ${varname})
   set(CMAKE_REQUIRED_FLAGS ${OLD_CMAKE_REQUIRED_FLAGS})

commit da0fe2ade369223ebea2dafd411746e854a801f2
Author: Bill Wendling <isanbard@gmail.com>
Date:   Thu Feb 20 16:22:35 2020 -0800

    Filter callbr insts from critical edge splitting
    
    Similarly to how splitting predecessors with an indirectbr isn't handled
    in the generic way, we also shouldn't split callbrs, for similar
    reasons.
    
    (cherry picked from commit 2fe457690da0fc38bc7f9f1d0aee2ba6a6a16ada)

diff --git a/llvm/lib/Transforms/Scalar/LICM.cpp b/llvm/lib/Transforms/Scalar/LICM.cpp
index 8c33045c238..eb023d49b0a 100644
--- a/llvm/lib/Transforms/Scalar/LICM.cpp
+++ b/llvm/lib/Transforms/Scalar/LICM.cpp
@@ -1537,7 +1537,8 @@ static bool canSplitPredecessors(PHINode *PN, LoopSafetyInfo *SafetyInfo) {
     return false;
   for (pred_iterator PI = pred_begin(BB), E = pred_end(BB); PI != E; ++PI) {
     BasicBlock *BBPred = *PI;
-    if (isa<IndirectBrInst>(BBPred->getTerminator()))
+    if (isa<IndirectBrInst>(BBPred->getTerminator()) ||
+        isa<CallBrInst>(BBPred->getTerminator()))
       return false;
   }
   return true;
diff --git a/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp b/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
index c9eb4abfa21..9a7379e27ed 100644
--- a/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
+++ b/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
@@ -505,7 +505,8 @@ llvm::SplitAllCriticalEdges(Function &F,
   unsigned NumBroken = 0;
   for (BasicBlock &BB : F) {
     Instruction *TI = BB.getTerminator();
-    if (TI->getNumSuccessors() > 1 && !isa<IndirectBrInst>(TI))
+    if (TI->getNumSuccessors() > 1 && !isa<IndirectBrInst>(TI) &&
+        !isa<CallBrInst>(TI))
       for (unsigned i = 0, e = TI->getNumSuccessors(); i != e; ++i)
         if (SplitCriticalEdge(TI, i, Options))
           ++NumBroken;
diff --git a/llvm/test/Transforms/LICM/callbr-crash.ll b/llvm/test/Transforms/LICM/callbr-crash.ll
new file mode 100644
index 00000000000..e5e7215d5b4
--- /dev/null
+++ b/llvm/test/Transforms/LICM/callbr-crash.ll
@@ -0,0 +1,18 @@
+; RUN: opt -licm -disable-output < %s
+
+define i32 @j() {
+entry:
+  br label %for.cond
+
+for.cond:                                         ; preds = %cond.true.i, %entry
+  callbr void asm sideeffect "", "X,~{dirflag},~{fpsr},~{flags}"(i8* blockaddress(@j, %for.end))
+          to label %cond.true.i [label %for.end]
+
+cond.true.i:                                      ; preds = %for.cond
+  %asmresult1.i.i = extractvalue { i8, i32 } zeroinitializer, 1
+  br i1 undef, label %for.end, label %for.cond
+
+for.end:                                          ; preds = %cond.true.i, %for.cond
+  %asmresult1.i.i2 = phi i32 [ %asmresult1.i.i, %cond.true.i ], [ undef, %for.cond ]
+  ret i32 undef
+}

commit 3a91c12e7aa4c84026f2952f7f03857eb9510a52
Author: Raphael Isemann <teemperor@gmail.com>
Date:   Fri Feb 21 12:02:35 2020 +0100

    [docs] Add some LLDB release notes

diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index 20e49b20f95..9c4bb3c33f0 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -254,6 +254,15 @@ Changes to LLDB
 
 * Initial support for debugging Windows ARM and ARM64 binaries
 
+* Improved error messages in the expression evaluator.
+
+* Tab completions for command options now also provide a description for each option.
+
+* Fixed that printing structs/classes with the `expression` command sometimes did not
+  print the members/contents of the class.
+
+* Improved support for using classes with bit-field members in the expression evaluator.
+
 External Open Source Projects Using LLVM 10
 ===========================================
 

commit 7f447b44f4eb73c35e6bc530a61bcaf30f78fc6d
Author: Tyker <tyker1@outlook.com>
Date:   Sat Feb 22 15:17:14 2020 +0100

    [docs] Add -Wmisleading-indentation to clang's release notes.

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index 18edc4ef51e..177bf848f94 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -75,6 +75,10 @@ Improvements to Clang's diagnostics
   warning now offers fixits. Excluding -Wrange-loop-bind-reference it is now
   part of -Wall. To reduce the number of false positives the diagnostic is
   disabled in macros and template instantiations.
+- -Wmisleading-indentation has been added. This warning is similar to the GCC
+  warning of the same name. It warns about statements that are indented as if
+  they were part of a if/else/for/while statement but are not semantically
+  part of that if/else/for/while.
 
 Non-comprehensive list of changes in this release
 -------------------------------------------------

commit c1547fe5bc3696a87b36abebfe8bf9a123cec99b
Author: Hans Wennborg <hans@chromium.org>
Date:   Mon Feb 24 16:44:54 2020 +0100

    ReleaseNotes: OpenMP
    
    By Alexey Bataev!

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index 177bf848f94..53e5d8d357f 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -299,7 +299,25 @@ ABI Changes in Clang
 OpenMP Support in Clang
 -----------------------
 
-- ...
+New features for OpenMP 5.0 were implemented. Use ``-fopenmp-version=50`` option to activate support for OpenMP 5.0.
+
+- Added support for ``device_type`` clause in declare target directive.
+- Non-static and non-ordered loops are nonmonotonic by default.
+- Teams-based directives can be used as a standalone directive.
+- Added support for collapsing of non-rectangular loops.
+- Added support for range-based loops.
+- Added support for collapsing of imperfectly nested loops.
+- Added support for ``master taskloop``, ``parallel master taskloop``, ``master taskloop simd`` and ``parallel master taskloop simd`` directives.
+- Added support for ``if`` clauses in simd-based directives.
+- Added support for unified shared memory for NVPTX target.
+- Added support for nested atomic and simd directives are allowed in sims-based directives.
+- Added support for non temporal clauses in sims-based directives.
+- Added basic support for conditional lastprivate variables
+
+Other improvements:
+
+- Added basic analysis for use of the uninitialized variables in clauses.
+- Bug fixes.
 
 CUDA Support in Clang
 ---------------------

commit 935ad4036ef6f13aedb301691dc86b46fc14369a
Author: Hans Wennborg <hans@chromium.org>
Date:   Mon Feb 24 16:52:12 2020 +0100

    ReleaseNotes: Attributor
    
    By Johannes Doerfert!

diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index 9c4bb3c33f0..0904a5793e7 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -98,7 +98,15 @@ Non-comprehensive list of changes in this release
   which has 3 values: ``none``, ``non-leaf``, and ``all``. The values mean what
   functions should retain frame pointers.
 
-* ...
+* The inter-procedural analysis and optimization capabilities in the Attributor
+  framework and pass have been substantially advanced (initial commit
+  `D59918 <https://reviews.llvm.org/D59918>`_, `LLVM-Dev talk <https://youtu.be/CzWkc_JcfS0>`_).
+  In this release, 19 different attributes are inferred, including 12 LLVM IR
+  attributes and 7 "abstract" attributes, such as liveness. The Attributor is
+  still under heavy development and disabled by default, to enable an early run
+  pass ``-mllvm -attributor-disable=false`` to an invocation of clang.
+
+
 
 Changes to the LLVM IR
 ----------------------

commit f59839930716dca910ba66b413d6bd2cc6a61a61
Author: Hans Wennborg <hans@chromium.org>
Date:   Mon Feb 24 16:59:21 2020 +0100

    ReleaseNotes: ARM and AArch64
    
    By Kristof Beyls!

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index 53e5d8d357f..784766bc9a3 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -183,7 +183,7 @@ New Pragmas in Clang
 Attribute Changes in Clang
 --------------------------
 
-- ...
+- Support was added for function ``__attribute__((target("branch-protection=...")))``
 
 Windows Support
 ---------------
diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index 0904a5793e7..c992bebf47c 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -123,10 +123,19 @@ Changes to building LLVM
 
 ...
 
+Changes to the AArch64 Backend
+------------------------------
+
+- Added support for Cortex-A65, Cortex-A65AE, Neoverse E1 and Neoverse N1 cores.
+- With a few more bugs fixed in the LLVM 10 release, clang-cl can now target windows-on-Arm well, demonstrated by building complex pieces of software such as Chromium and the Electron framework.
+- Support for -fpatchable-function-entry was added.
+
 Changes to the ARM Backend
 --------------------------
 
- During this release ...
+- Optimized Armv8.1-M code generation, including generating Low Overhead Loops.
+- Added auto-vectorization for the Armv8.1-M MVE vector extension.
+- Support was added for inline asm constraints s,j,x,N,O.
 
 
 Changes to the MIPS Target

commit e82d1342bdff11c877ee8fe3f9952704bccd702b
Author: Pavel Labath <pavel@labath.sk>
Date:   Mon Feb 24 17:10:57 2020 +0100

    ReleaseNotes: Mention improved DWARF5 support in lldb
    
    Mainly involves location and range list handling, but other holes have
    been filled too.

diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index c992bebf47c..848ebdb9c2e 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -280,6 +280,8 @@ Changes to LLDB
 
 * Improved support for using classes with bit-field members in the expression evaluator.
 
+* Greatly improved support for DWARF v5.
+
 External Open Source Projects Using LLVM 10
 ===========================================
 

commit be9f8fdfd9af15d70b3b80535f7519588784e939
Author: Amy Huang <akhuang@google.com>
Date:   Mon Feb 24 10:39:54 2020 -0800

    Add -debug-info-kind=constructor to clang release notes

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index 784766bc9a3..91506e1a2b2 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -175,6 +175,10 @@ Modified Compiler Flags
     between vector types.
     Synonym: ``-fno-lax-vector-conversions``.
 
+- ``-debug-info-kind`` now has an option ``-debug-info-kind=constructor``,
+  which is one level below ``-debug-info-kind=limited``. This option causes
+  debug info for classes to be emitted only when a constructor is emitted.
+
 New Pragmas in Clang
 --------------------
 

commit c6f940b745c68f911e06ede1374f155d89fe3540
Author: Hans Wennborg <hans@chromium.org>
Date:   Tue Feb 25 10:59:32 2020 +0100

    Add llvm-cov to LLVM_TOOLCHAIN_TOOLS
    
    See https://github.com/llvm/llvm-project/issues/141
    
    (cherry picked from commit dcd89b3de6de891bfcc59189cda1ea059fbdcdb5)

diff --git a/llvm/cmake/modules/AddLLVM.cmake b/llvm/cmake/modules/AddLLVM.cmake
index fce36ba2125..32798b1b44a 100644
--- a/llvm/cmake/modules/AddLLVM.cmake
+++ b/llvm/cmake/modules/AddLLVM.cmake
@@ -998,6 +998,7 @@ endfunction()
 if(NOT LLVM_TOOLCHAIN_TOOLS)
   set (LLVM_TOOLCHAIN_TOOLS
     llvm-ar
+    llvm-cov
     llvm-cxxfilt
     llvm-ranlib
     llvm-lib

commit 882720b7ce338c81aa24c1c2b2614c47d248920f
Author: Hans Wennborg <hans@chromium.org>
Date:   Tue Feb 25 11:50:03 2020 +0100

    Don't generate libcalls for wide shift on Windows ARM (PR42711)
    
    The previous patch (cff90f07cb5cc3c3bc58277926103af31caef308) didn't
    cover ARM.
    
    (cherry picked from commit decd021facba804b57e8d80b6159c987d3261ab8)

diff --git a/llvm/lib/Target/ARM/ARMISelLowering.cpp b/llvm/lib/Target/ARM/ARMISelLowering.cpp
index 2f836a60a9e..66f3f418d06 100644
--- a/llvm/lib/Target/ARM/ARMISelLowering.cpp
+++ b/llvm/lib/Target/ARM/ARMISelLowering.cpp
@@ -16892,7 +16892,7 @@ bool ARMTargetLowering::isCheapToSpeculateCtlz() const {
 }
 
 bool ARMTargetLowering::shouldExpandShift(SelectionDAG &DAG, SDNode *N) const {
-  return !Subtarget->hasMinSize();
+  return !Subtarget->hasMinSize() || Subtarget->isTargetWindows();
 }
 
 Value *ARMTargetLowering::emitLoadLinked(IRBuilder<> &Builder, Value *Addr,
diff --git a/llvm/test/CodeGen/ARM/shift_minsize.ll b/llvm/test/CodeGen/ARM/shift_minsize.ll
index 4d10c64392d..de7327ed3fc 100644
--- a/llvm/test/CodeGen/ARM/shift_minsize.ll
+++ b/llvm/test/CodeGen/ARM/shift_minsize.ll
@@ -1,4 +1,10 @@
-; RUN: llc -mtriple=arm-eabi %s -o - | FileCheck %s
+; RUN: llc -mtriple=arm-eabi        %s -o - | FileCheck %s
+; RUN: llc -mtriple=thumbv7-windows %s -o - | FileCheck %s -check-prefix=CHECK-WIN
+
+; The Windows runtime doesn't have these.
+; CHECK-WIN-NOT: __ashldi3
+; CHECK-WIN-NOT: __ashrdi3
+; CHECK-WIN-NOT: __lshrdi3
 
 define i64 @f0(i64 %val, i64 %amt) minsize optsize {
 ; CHECK-LABEL:   f0:

commit 3a11c86849c27e1e21d5e8cdf55cfa724164db57
Author: Hans Wennborg <hans@chromium.org>
Date:   Tue Feb 25 12:06:44 2020 +0100

    Add Control Flow Guard in Clang release notes.
    
    By Andrew Paverd!
    
    Differential revision: https://reviews.llvm.org/D75047

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index 91506e1a2b2..67c42870a3d 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -208,6 +208,12 @@ Windows Support
 - Fixed handling of TLS variables that are shared between object files
   in MinGW environments
 
+- The ``-cfguard`` flag now emits Windows Control Flow Guard checks on indirect
+  function calls. The previous behavior is still available with the
+  ``-cfguard-nochecks`` flag. These checks can be disabled for specific
+  functions using the new ``__declspec(guard(nocf))`` modifier.
+
+
 C Language Changes in Clang
 ---------------------------
 

commit bbfdf4b81d60e352224c0c928eb3fa9fbfb7858c
Author: Hans Wennborg <hans@chromium.org>
Date:   Tue Feb 25 12:13:09 2020 +0100

    build_llvm_package.bat: Produce zip files in addition to the installers
    
    Now that the Windows installer no longer does anything besides
    self-extract, maybe it would make sense to distribute the toolchain as a
    plain zip file in addition to the current installer.
    
    Differential revision: https://reviews.llvm.org/D74896
    
    (cherry picked from commit 4486aa03c5f431ba33a1d1ac9991da912e3decd9)

diff --git a/llvm/utils/release/build_llvm_package.bat b/llvm/utils/release/build_llvm_package.bat
index 7556bfa854e..a54fd1f0e62 100755
--- a/llvm/utils/release/build_llvm_package.bat
+++ b/llvm/utils/release/build_llvm_package.bat
@@ -11,7 +11,7 @@ REM
 REM   Visual Studio 2019, CMake, Ninja, GNUWin32, SWIG, Python 3,
 REM   NSIS with the strlen_8192 patch,
 REM   Visual Studio 2019 SDK and Nuget (for the clang-format plugin),
-REM   Perl (for the OpenMP run-time).
+REM   Perl (for the OpenMP run-time), 7Zip.
 REM
 REM
 REM   For LLDB, SWIG version <= 3.0.8 needs to be used to work around
@@ -91,8 +91,14 @@ ninja check-sanitizer || ninja check-sanitizer || ninja check-sanitizer || exit
 ninja check-clang-tools || ninja check-clang-tools || ninja check-clang-tools || exit /b
 ninja check-clangd || ninja check-clangd || ninja check-clangd || exit /b
 ninja package || exit /b
+
+7z x LLVM-%package_version%-win32.exe -orepack
+rmdir /s /q repack\$PLUGINSDIR
+del repack\Uninstall.exe
+7z a LLVM-%package_version%-win32.zip .\repack\* -mx9
 cd ..
 
+
 REM The plug-in is built separately as it uses a statically linked clang-format.exe.
 mkdir build_vsix
 cd build_vsix
@@ -135,4 +141,9 @@ ninja check-sanitizer || ninja check-sanitizer || ninja check-sanitizer || exit
 ninja check-clang-tools || ninja check-clang-tools || ninja check-clang-tools || exit /b
 ninja check-clangd || ninja check-clangd || ninja check-clangd || exit /b
 ninja package || exit /b
+
+7z x LLVM-%package_version%-win64.exe -orepack
+rmdir /s /q repack\$PLUGINSDIR
+del repack\Uninstall.exe
+7z a LLVM-%package_version%-win64.zip .\repack\* -mx9
 cd ..

commit 2905a48c8790b530709305e984451ddab268c8e4
Author: Hans Wennborg <hans@chromium.org>
Date:   Tue Feb 25 15:15:25 2020 +0100

    Fix DfaEmitter::visitDfaState() crash in MSVC x86 debug builds (PR44945)
    
    No functionality change (intended), but this seems to make the code a
    bit clearer for the compiler and maybe for human readers too.
    
    (cherry picked from commit edae4be8e21c5deb9a8ffc24a8c17e70b878bf39)

diff --git a/llvm/utils/TableGen/DFAEmitter.cpp b/llvm/utils/TableGen/DFAEmitter.cpp
index dd3db7c150b..c392651180b 100644
--- a/llvm/utils/TableGen/DFAEmitter.cpp
+++ b/llvm/utils/TableGen/DFAEmitter.cpp
@@ -53,14 +53,14 @@ void DfaEmitter::addTransition(state_type From, state_type To, action_type A) {
   ++NumNfaTransitions;
 }
 
-void DfaEmitter::visitDfaState(DfaState DS) {
+void DfaEmitter::visitDfaState(const DfaState &DS) {
   // For every possible action...
   auto FromId = DfaStates.idFor(DS);
   for (action_type A : Actions) {
     DfaState NewStates;
     DfaTransitionInfo TI;
     // For every represented state, word pair in the original NFA...
-    for (state_type &FromState : DS) {
+    for (state_type FromState : DS) {
       // If this action is possible from this state add the transitioned-to
       // states to NewStates.
       auto I = NfaTransitions.find({FromState, A});
@@ -90,8 +90,11 @@ void DfaEmitter::constructDfa() {
 
   // Note that UniqueVector starts indices at 1, not zero.
   unsigned DfaStateId = 1;
-  while (DfaStateId <= DfaStates.size())
-    visitDfaState(DfaStates[DfaStateId++]);
+  while (DfaStateId <= DfaStates.size()) {
+    DfaState S = DfaStates[DfaStateId];
+    visitDfaState(S);
+    DfaStateId++;
+  }
 }
 
 void DfaEmitter::emit(StringRef Name, raw_ostream &OS) {
diff --git a/llvm/utils/TableGen/DFAEmitter.h b/llvm/utils/TableGen/DFAEmitter.h
index 76de8f72cd8..f7724ce06ba 100644
--- a/llvm/utils/TableGen/DFAEmitter.h
+++ b/llvm/utils/TableGen/DFAEmitter.h
@@ -99,7 +99,7 @@ private:
   void constructDfa();
   /// Visit a single DFA state and construct all possible transitions to new DFA
   /// states.
-  void visitDfaState(DfaState DS);
+  void visitDfaState(const DfaState &DS);
 };
 
 } // namespace llvm

commit 1f6c9becd57af14ee71fb7c1e56b55f556be98fa
Author: Sam McCall <sam.mccall@gmail.com>
Date:   Tue Feb 25 15:48:34 2020 +0100

    [docs] clangd release notes

diff --git a/clang-tools-extra/docs/ReleaseNotes.rst b/clang-tools-extra/docs/ReleaseNotes.rst
index 52e98cb23f5..86ff28cfb0f 100644
--- a/clang-tools-extra/docs/ReleaseNotes.rst
+++ b/clang-tools-extra/docs/ReleaseNotes.rst
@@ -47,7 +47,50 @@ Major New Features
 Improvements to clangd
 ----------------------
 
-The improvements are...
+- Go-to-definition, hover, find-references etc use a new mechanism to identify
+  what is under the cursor, which is (hopefully) more consistent and accurate.
+
+- clangd should be able to reliably locate the standard library/SDK on macOS.
+
+- Shutdown more cleanly on receiving a signal. In particular temporary PCH files
+  should be cleaned up.
+
+- Find references now works on macros.
+
+- clangd can be more easily used remotely or in a docker container.
+
+  The `--path-mappings` flag translates between local and remote paths.
+
+- Experimental support for renaming across files (behind the
+  `--cross-file-rename` flag).
+
+- Hover now exposes more information, including the type of symbols and the
+  value of constant expressions.
+
+- Go to definition now works in dependent code in more cases, by assuming the
+  primary template is used.
+
+- Better recovery and reporting when the compile command for a file can't be
+  fully parsed.
+
+- Switch header/source (an extension) now uses index information in addition
+  to filename heuristics, and is much more robust.
+
+- Semantic selection (expand/contract selection) is supported.
+
+- Semantic highlighting is more robust, highlights more types of tokens, and
+  as an extension provides information about inactive preprocessor regions.
+
+- Code completion results now include an extension field `score`.
+
+  This allows clients to incorporate clangd quality signals when re-ranking code
+  completion after client-side fuzzy-matching.
+
+- New refactorings:
+  define function out-of-line, define function in-line, extract function,
+  remove using namespace directive, localize Objective-C string.
+
+- Bug fixes and performance improvements :-)
 
 Improvements to clang-doc
 -------------------------

commit 668b8a4bcd01170625df7cf4246c05354b9ff625
Author: Dan Gohman <sunfish@mozilla.com>
Date:   Tue Feb 25 15:10:54 2020 -0800

    [docs][WebAssembly] WebAssembly-specific release notes for 10.0.

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index 67c42870a3d..b160588b22c 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -119,6 +119,9 @@ Non-comprehensive list of changes in this release
 * Improved support for ``octeon`` MIPS-family CPU. Added ``octeon+`` to
   the list of of CPUs accepted by the driver.
 
+* For the WebAssembly target, the ``wasm-opt`` tool will now be run if it is
+  found in the PATH, which can reduce code size.
+
 New Compiler Flags
 ------------------
 
diff --git a/lld/docs/ReleaseNotes.rst b/lld/docs/ReleaseNotes.rst
index 4e55f93882f..5be348bb189 100644
--- a/lld/docs/ReleaseNotes.rst
+++ b/lld/docs/ReleaseNotes.rst
@@ -86,3 +86,4 @@ WebAssembly Improvements
   as it's best to keep them internal when possible. They can be
   explicitly exported with `--export=__data_end` and
   `--export=__heap_base`, respectively.
+* wasm-ld now elides .bss sections when the memory is not imported
diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index 848ebdb9c2e..60dd07ddb26 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -234,7 +234,12 @@ Changes to the AVR Target
 Changes to the WebAssembly Target
 ---------------------------------
 
- During this release ...
+* __attribute__((used)) no longer implies that a symbol is exported, for
+  consistency with other targets.
+* Multivalue function signatures are now supported in WebAssembly object files
+* The new `atomic.fence` instruction is now supported
+* Thread-Local Storage (TLS) is now supported.
+* SIMD support is significantly expanded.
 
 Changes to the Windows Target
 -----------------------------

commit 002af0119286297dbd76b08a4a6cc4b6b87d3f26
Author: Michael Kruse <llvm-project@meinersbur.de>
Date:   Tue Feb 25 22:38:05 2020 -0600

    [Polly][docs] Polly release notes.
    
    In release 10.0, Polly is not linked into opt/bugpoint/clang by default
    anymore. Add workarounds in release notes.

diff --git a/polly/docs/ReleaseNotes.rst b/polly/docs/ReleaseNotes.rst
index 1d9aacc9aa6..5f49e619976 100644
--- a/polly/docs/ReleaseNotes.rst
+++ b/polly/docs/ReleaseNotes.rst
@@ -10,4 +10,44 @@ In Polly 10 the following important changes have been incorporated.
   the new features that have recently been committed to our development
   branch.
 
-- Change ...
+Statically Linking of Polly
+===========================
+
+The mechanism that Polly uses to link itself statically into the opt, bugpoint and clang executables has been generalized such that it can be used by other pass plugins. An example plugin "Bye" has been added to illustate the mechanism. A consequence of this change is that Polly, like the "Bye" plugin, by default is not linked statically into aforementioned executables anymore.
+
+If Polly is not available, the executable will report an unkown argument `-polly`, such as
+
+.. code-block:: console
+
+    $ clang -mllvm -polly -x c -
+    clang (LLVM option parsing): Unknown command line argument '-polly'.  Try: 'clang (LLVM option parsing) --help'
+    clang (LLVM option parsing): Did you mean '--color'?
+
+.. code-block:: console
+
+    $ opt -polly
+    opt: for the -o option: may not occur within a group!
+    opt: Unknown command line argument '-polly'.  Try: 'opt --help'
+    opt: Did you mean '-o'?
+
+Polly can be made available using the following methods.
+
+- Configure LLVM/Clang with the CMake options LLVM_POLLY_LINK_INTO_TOOLS=ON and LLVM_ENABLE_PROJECTS=polly.
+
+  .. code-block:: console
+
+    $ cmake -DLLVM_POLLY_LINK_INTO_TOOLS=ON -DLLVM_ENABLE_PROJECTS=clang;polly ...
+
+  In future versions, LLVM_POLLY_LINK_INTO_TOOLS=ON will be default again if Polly has been enabled.
+
+- Use the `-load` option to load the Polly module.
+
+  .. code-block:: console
+
+    $ clang -Xclang -load -Xclang path/to/LLVMPolly.so ...
+
+  .. code-block:: console
+
+    $ opt -load path/to/LLVMPolly.so ...
+
+  The LLVMPolly.so module can be found in the `lib/` directory of the build or install-prefix directory.

commit 0fe369ad5ff69394b9076b1a679502c3993488d1
Author: Kadir Cetinkaya <kadircet@google.com>
Date:   Wed Feb 26 09:03:03 2020 +0100

    Strip preceeding -Xclang when stripping -fcolor-diagnostics or -fdiagnostics-color
    
    Summary: Fixes https://github.com/clangd/clangd/issues/279. We were removing the color options but not the preceeding -Xclang which causes errors since the -Xclang would now apply to the next option in the list of options. Now, when removing a color option, we check if there was a preceeding -Xclang and remove it as well.
    
    Patch By @DaanDeMeyer !
    
    Reviewers: sammccall, kadircet
    
    Reviewed By: sammccall
    
    Subscribers: ilya-biryukov, usaxena95
    
    Differential Revision: https://reviews.llvm.org/D75019
    
    (cherry picked from commit da236f235028c82c2f0e00eea1f6f9c689bcae4a)

diff --git a/clang/lib/Tooling/ArgumentsAdjusters.cpp b/clang/lib/Tooling/ArgumentsAdjusters.cpp
index a609e4ed246..ec15311d4ba 100644
--- a/clang/lib/Tooling/ArgumentsAdjusters.cpp
+++ b/clang/lib/Tooling/ArgumentsAdjusters.cpp
@@ -42,6 +42,12 @@ ArgumentsAdjuster getClangSyntaxOnlyAdjuster() {
       if (!Arg.startswith("-fcolor-diagnostics") &&
           !Arg.startswith("-fdiagnostics-color"))
         AdjustedArgs.push_back(Args[i]);
+      // If we strip a color option, make sure we strip any preceeding `-Xclang`
+      // option as well.
+      // FIXME: This should be added to most argument adjusters!
+      else if (!AdjustedArgs.empty() && AdjustedArgs.back() == "-Xclang")
+        AdjustedArgs.pop_back();
+
       if (Arg == "-fsyntax-only")
         HasSyntaxOnly = true;
     }

commit 8b0df8e1ed6842095388fce08a0a5f761cd905ed
Author: Alina Sbirlea <asbirlea@google.com>
Date:   Thu Feb 13 10:49:44 2020 -0800

    [LoopRotate] Get and update MSSA only if available in legacy pass manager.
    
    Summary:
    Potential fix for: https://bugs.llvm.org/show_bug.cgi?id=44889 and https://bugs.llvm.org/show_bug.cgi?id=44408
    
    In the legacy pass manager, loop rotate need not compute MemorySSA when not being in the same loop pass manager with other loop passes.
    There isn't currently a way to differentiate between the two cases, so this attempts to limit the usage in LoopRotate to only update MemorySSA when the analysis is already available.
    The side-effect of this is that it will split the Loop pipeline.
    
    This issue does not apply to the new pass manager, where we have a flag specifying if all loop passes in that loop pass manager preserve MemorySSA.
    
    Reviewers: dmgreen, fedor.sergeev, nikic
    
    Subscribers: Prazek, hiraditya, george.burgess.iv, llvm-commits
    
    Tags: #llvm
    
    Differential Revision: https://reviews.llvm.org/D74574
    
    (cherry picked from commit 1326a5a4cfe004181f2ec8231d84ecda2b93cb25)

diff --git a/llvm/lib/Transforms/Scalar/LoopRotation.cpp b/llvm/lib/Transforms/Scalar/LoopRotation.cpp
index 0868e742f4e..67c20b2edae 100644
--- a/llvm/lib/Transforms/Scalar/LoopRotation.cpp
+++ b/llvm/lib/Transforms/Scalar/LoopRotation.cpp
@@ -81,10 +81,8 @@ public:
   void getAnalysisUsage(AnalysisUsage &AU) const override {
     AU.addRequired<AssumptionCacheTracker>();
     AU.addRequired<TargetTransformInfoWrapperPass>();
-    if (EnableMSSALoopDependency) {
-      AU.addRequired<MemorySSAWrapperPass>();
+    if (EnableMSSALoopDependency)
       AU.addPreserved<MemorySSAWrapperPass>();
-    }
     getLoopAnalysisUsage(AU);
   }
 
@@ -101,8 +99,11 @@ public:
     const SimplifyQuery SQ = getBestSimplifyQuery(*this, F);
     Optional<MemorySSAUpdater> MSSAU;
     if (EnableMSSALoopDependency) {
-      MemorySSA *MSSA = &getAnalysis<MemorySSAWrapperPass>().getMSSA();
-      MSSAU = MemorySSAUpdater(MSSA);
+      // Not requiring MemorySSA and getting it only if available will split
+      // the loop pass pipeline when LoopRotate is being run first.
+      auto *MSSAA = getAnalysisIfAvailable<MemorySSAWrapperPass>();
+      if (MSSAA)
+        MSSAU = MemorySSAUpdater(&MSSAA->getMSSA());
     }
     return LoopRotation(L, LI, TTI, AC, &DT, &SE,
                         MSSAU.hasValue() ? MSSAU.getPointer() : nullptr, SQ,
diff --git a/llvm/test/Other/opt-O2-pipeline.ll b/llvm/test/Other/opt-O2-pipeline.ll
index 31527e6169b..da0edf105ee 100644
--- a/llvm/test/Other/opt-O2-pipeline.ll
+++ b/llvm/test/Other/opt-O2-pipeline.ll
@@ -100,16 +100,17 @@
 ; CHECK-NEXT:         Simplify the CFG
 ; CHECK-NEXT:         Reassociate expressions
 ; CHECK-NEXT:         Dominator Tree Construction
-; CHECK-NEXT:         Basic Alias Analysis (stateless AA impl)
-; CHECK-NEXT:         Function Alias Analysis Results
-; CHECK-NEXT:         Memory SSA
 ; CHECK-NEXT:         Natural Loop Information
 ; CHECK-NEXT:         Canonicalize natural loops
 ; CHECK-NEXT:         LCSSA Verifier
 ; CHECK-NEXT:         Loop-Closed SSA Form Pass
+; CHECK-NEXT:         Basic Alias Analysis (stateless AA impl)
+; CHECK-NEXT:         Function Alias Analysis Results
 ; CHECK-NEXT:         Scalar Evolution Analysis
 ; CHECK-NEXT:         Loop Pass Manager
 ; CHECK-NEXT:           Rotate Loops
+; CHECK-NEXT:         Memory SSA
+; CHECK-NEXT:         Loop Pass Manager
 ; CHECK-NEXT:           Loop Invariant Code Motion
 ; CHECK-NEXT:           Unswitch loops
 ; CHECK-NEXT:         Simplify the CFG
@@ -200,13 +201,12 @@
 ; CHECK-NEXT:       Float to int
 ; CHECK-NEXT:       Lower constant intrinsics
 ; CHECK-NEXT:       Dominator Tree Construction
-; CHECK-NEXT:       Basic Alias Analysis (stateless AA impl)
-; CHECK-NEXT:       Function Alias Analysis Results
-; CHECK-NEXT:       Memory SSA
 ; CHECK-NEXT:       Natural Loop Information
 ; CHECK-NEXT:       Canonicalize natural loops
 ; CHECK-NEXT:       LCSSA Verifier
 ; CHECK-NEXT:       Loop-Closed SSA Form Pass
+; CHECK-NEXT:       Basic Alias Analysis (stateless AA impl)
+; CHECK-NEXT:       Function Alias Analysis Results
 ; CHECK-NEXT:       Scalar Evolution Analysis
 ; CHECK-NEXT:       Loop Pass Manager
 ; CHECK-NEXT:         Rotate Loops
diff --git a/llvm/test/Other/opt-O3-pipeline.ll b/llvm/test/Other/opt-O3-pipeline.ll
index cb19835e05e..113137a6fd3 100644
--- a/llvm/test/Other/opt-O3-pipeline.ll
+++ b/llvm/test/Other/opt-O3-pipeline.ll
@@ -105,16 +105,17 @@
 ; CHECK-NEXT:         Simplify the CFG
 ; CHECK-NEXT:         Reassociate expressions
 ; CHECK-NEXT:         Dominator Tree Construction
-; CHECK-NEXT:         Basic Alias Analysis (stateless AA impl)
-; CHECK-NEXT:         Function Alias Analysis Results
-; CHECK-NEXT:         Memory SSA
 ; CHECK-NEXT:         Natural Loop Information
 ; CHECK-NEXT:         Canonicalize natural loops
 ; CHECK-NEXT:         LCSSA Verifier
 ; CHECK-NEXT:         Loop-Closed SSA Form Pass
+; CHECK-NEXT:         Basic Alias Analysis (stateless AA impl)
+; CHECK-NEXT:         Function Alias Analysis Results
 ; CHECK-NEXT:         Scalar Evolution Analysis
 ; CHECK-NEXT:         Loop Pass Manager
 ; CHECK-NEXT:           Rotate Loops
+; CHECK-NEXT:         Memory SSA
+; CHECK-NEXT:         Loop Pass Manager
 ; CHECK-NEXT:           Loop Invariant Code Motion
 ; CHECK-NEXT:           Unswitch loops
 ; CHECK-NEXT:         Simplify the CFG
@@ -205,13 +206,12 @@
 ; CHECK-NEXT:       Float to int
 ; CHECK-NEXT:       Lower constant intrinsics
 ; CHECK-NEXT:       Dominator Tree Construction
-; CHECK-NEXT:       Basic Alias Analysis (stateless AA impl)
-; CHECK-NEXT:       Function Alias Analysis Results
-; CHECK-NEXT:       Memory SSA
 ; CHECK-NEXT:       Natural Loop Information
 ; CHECK-NEXT:       Canonicalize natural loops
 ; CHECK-NEXT:       LCSSA Verifier
 ; CHECK-NEXT:       Loop-Closed SSA Form Pass
+; CHECK-NEXT:       Basic Alias Analysis (stateless AA impl)
+; CHECK-NEXT:       Function Alias Analysis Results
 ; CHECK-NEXT:       Scalar Evolution Analysis
 ; CHECK-NEXT:       Loop Pass Manager
 ; CHECK-NEXT:         Rotate Loops
diff --git a/llvm/test/Other/opt-Os-pipeline.ll b/llvm/test/Other/opt-Os-pipeline.ll
index 80a74bd804e..c77f84005fe 100644
--- a/llvm/test/Other/opt-Os-pipeline.ll
+++ b/llvm/test/Other/opt-Os-pipeline.ll
@@ -87,16 +87,17 @@
 ; CHECK-NEXT:         Simplify the CFG
 ; CHECK-NEXT:         Reassociate expressions
 ; CHECK-NEXT:         Dominator Tree Construction
-; CHECK-NEXT:         Basic Alias Analysis (stateless AA impl)
-; CHECK-NEXT:         Function Alias Analysis Results
-; CHECK-NEXT:         Memory SSA
 ; CHECK-NEXT:         Natural Loop Information
 ; CHECK-NEXT:         Canonicalize natural loops
 ; CHECK-NEXT:         LCSSA Verifier
 ; CHECK-NEXT:         Loop-Closed SSA Form Pass
+; CHECK-NEXT:         Basic Alias Analysis (stateless AA impl)
+; CHECK-NEXT:         Function Alias Analysis Results
 ; CHECK-NEXT:         Scalar Evolution Analysis
 ; CHECK-NEXT:         Loop Pass Manager
 ; CHECK-NEXT:           Rotate Loops
+; CHECK-NEXT:         Memory SSA
+; CHECK-NEXT:         Loop Pass Manager
 ; CHECK-NEXT:           Loop Invariant Code Motion
 ; CHECK-NEXT:           Unswitch loops
 ; CHECK-NEXT:         Simplify the CFG
@@ -187,13 +188,12 @@
 ; CHECK-NEXT:       Float to int
 ; CHECK-NEXT:       Lower constant intrinsics
 ; CHECK-NEXT:       Dominator Tree Construction
-; CHECK-NEXT:       Basic Alias Analysis (stateless AA impl)
-; CHECK-NEXT:       Function Alias Analysis Results
-; CHECK-NEXT:       Memory SSA
 ; CHECK-NEXT:       Natural Loop Information
 ; CHECK-NEXT:       Canonicalize natural loops
 ; CHECK-NEXT:       LCSSA Verifier
 ; CHECK-NEXT:       Loop-Closed SSA Form Pass
+; CHECK-NEXT:       Basic Alias Analysis (stateless AA impl)
+; CHECK-NEXT:       Function Alias Analysis Results
 ; CHECK-NEXT:       Scalar Evolution Analysis
 ; CHECK-NEXT:       Loop Pass Manager
 ; CHECK-NEXT:         Rotate Loops
diff --git a/llvm/test/Other/pass-pipelines.ll b/llvm/test/Other/pass-pipelines.ll
index 6853fd9cbab..0b3b5a96060 100644
--- a/llvm/test/Other/pass-pipelines.ll
+++ b/llvm/test/Other/pass-pipelines.ll
@@ -52,6 +52,7 @@
 ; CHECK-O2-NEXT: FunctionPass Manager
 ; CHECK-O2-NOT: Manager
 ; CHECK-O2: Loop Pass Manager
+; CHECK-O2: Loop Pass Manager
 ; CHECK-O2-NOT: Manager
 ; FIXME: We shouldn't be pulling out to simplify-cfg and instcombine and
 ; causing new loop pass managers.

commit 6f4f4f2c8ce1ad17bdec9fe2071d3fe439eca9eb
Author: Rong Xu <xur@google.com>
Date:   Tue Feb 25 08:04:01 2020 -0800

    [remark][diagnostics] [codegen] Fix PR44896
    
    This patch fixes PR44896. For IR input files, option fdiscard-value-names
    should be ignored as we need named values in loadModule().
    Commit 60d3947922 sets this option after loadModule() where valued names
    already created. This creates an inconsistent state in setNameImpl()
    that leads to a seg fault.
    This patch forces fdiscard-value-names to be false for IR input files.
    
    This patch also emits a warning of "ignoring -fdiscard-value-names" if
    option fdiscard-value-names is explictly enabled in the commandline for
    IR input files.
    
    Differential Revision: https://reviews.llvm.org/D74878
    
    (cherry picked from commit 11857d49948b845dcfd7c7f78595095e3add012d)

diff --git a/clang/include/clang/Basic/DiagnosticDriverKinds.td b/clang/include/clang/Basic/DiagnosticDriverKinds.td
index ecd871e36ee..48ece91d3c4 100644
--- a/clang/include/clang/Basic/DiagnosticDriverKinds.td
+++ b/clang/include/clang/Basic/DiagnosticDriverKinds.td
@@ -271,6 +271,9 @@ def warn_drv_unsupported_debug_info_opt_for_target : Warning<
   InGroup<UnsupportedTargetOpt>;
 def warn_c_kext : Warning<
   "ignoring -fapple-kext which is valid for C++ and Objective-C++ only">;
+def warn_ignoring_fdiscard_for_bitcode : Warning<
+  "ignoring -fdiscard-value-names for LLVM Bitcode">,
+  InGroup<UnusedCommandLineArgument>;
 def warn_drv_input_file_unused : Warning<
   "%0: '%1' input unused%select{ when '%3' is present|}2">,
   InGroup<UnusedCommandLineArgument>;
diff --git a/clang/lib/CodeGen/CodeGenAction.cpp b/clang/lib/CodeGen/CodeGenAction.cpp
index 7065e78f19a..20ebaf3578d 100644
--- a/clang/lib/CodeGen/CodeGenAction.cpp
+++ b/clang/lib/CodeGen/CodeGenAction.cpp
@@ -1146,6 +1146,9 @@ void CodeGenAction::ExecuteAction() {
                            CI.getTargetOpts(), CI.getLangOpts(),
                            CI.getFrontendOpts().ShowTimers,
                            std::move(LinkModules), *VMContext, nullptr);
+    // PR44896: Force DiscardValueNames as false. DiscardValueNames cannot be
+    // true here because the valued names are needed for reading textual IR.
+    Ctx.setDiscardValueNames(false);
     Ctx.setDiagnosticHandler(
         std::make_unique<ClangDiagnosticHandler>(CodeGenOpts, &Result));
 
diff --git a/clang/lib/Driver/ToolChains/Clang.cpp b/clang/lib/Driver/ToolChains/Clang.cpp
index aec1971214c..fa025be14e4 100644
--- a/clang/lib/Driver/ToolChains/Clang.cpp
+++ b/clang/lib/Driver/ToolChains/Clang.cpp
@@ -4266,8 +4266,16 @@ void Clang::ConstructJob(Compilation &C, const JobAction &JA,
 
   // Discard value names in assert builds unless otherwise specified.
   if (Args.hasFlag(options::OPT_fdiscard_value_names,
-                   options::OPT_fno_discard_value_names, !IsAssertBuild))
+                   options::OPT_fno_discard_value_names, !IsAssertBuild)) {
+    if (Args.hasArg(options::OPT_fdiscard_value_names) &&
+        (std::any_of(Inputs.begin(), Inputs.end(),
+                     [](const clang::driver::InputInfo &II) {
+                       return types::isLLVMIR(II.getType());
+                     }))) {
+      D.Diag(diag::warn_ignoring_fdiscard_for_bitcode);
+    }
     CmdArgs.push_back("-discard-value-names");
+  }
 
   // Set the main file name, so that debug info works even with
   // -save-temps.
diff --git a/clang/test/CodeGen/PR44896.ll b/clang/test/CodeGen/PR44896.ll
new file mode 100644
index 00000000000..a4d34457987
--- /dev/null
+++ b/clang/test/CodeGen/PR44896.ll
@@ -0,0 +1,15 @@
+; RUN: %clang -fdiscard-value-names -S %s -o /dev/null 2>&1 | FileCheck --check-prefix=WARNING %s
+; RUN: %clang -S %s -o /dev/null 2>&1 | FileCheck --check-prefix=NOWARNING %s
+; RUN: %clang_cc1 -S -emit-llvm %s -discard-value-names -o /dev/null
+; PR 44896
+
+; WARNING: ignoring -fdiscard-value-names for LLVM Bitcode
+; NOWARNING-NOT: ignoring -fdiscard-value-names for LLVM Bitcode
+
+target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64--linux-gnu"
+
+define linkonce i8* @b(i8* %a) {
+  ret i8* %a
+}
+

commit 57a064f8dc8301ce8b017c84782286816dc58911
Author: Hans Wennborg <hans@chromium.org>
Date:   Wed Feb 26 13:31:58 2020 +0100

    Revert "[compiler-rt] Add a critical section when flushing gcov counters"
    
    See the discussion on PR44792.
    
    This reverts commit 02ce9d8ef5a84bc884de4105eae5f8736ef67634.

diff --git a/compiler-rt/lib/profile/GCDAProfiling.c b/compiler-rt/lib/profile/GCDAProfiling.c
index 81f2cdd2645..498c05900bf 100644
--- a/compiler-rt/lib/profile/GCDAProfiling.c
+++ b/compiler-rt/lib/profile/GCDAProfiling.c
@@ -62,27 +62,8 @@ typedef unsigned long long uint64_t;
 #include "InstrProfiling.h"
 #include "InstrProfilingUtil.h"
 
-#ifndef _WIN32
-#include <pthread.h>
-static pthread_mutex_t gcov_flush_mutex = PTHREAD_MUTEX_INITIALIZER;
-static __inline void gcov_flush_lock() {
-  pthread_mutex_lock(&gcov_flush_mutex);
-}
-static __inline void gcov_flush_unlock() {
-  pthread_mutex_unlock(&gcov_flush_mutex);
-}
-#else
-#include <windows.h>
-static SRWLOCK gcov_flush_mutex = SRWLOCK_INIT;
-static __inline void gcov_flush_lock() {
-  AcquireSRWLockExclusive(&gcov_flush_mutex);
-}
-static __inline void gcov_flush_unlock() {
-  ReleaseSRWLockExclusive(&gcov_flush_mutex);
-}
-#endif
-
 /* #define DEBUG_GCDAPROFILING */
+
 /*
  * --- GCOV file format I/O primitives ---
  */
@@ -639,16 +620,12 @@ void llvm_register_flush_function(fn_ptr fn) {
 }
 
 void __gcov_flush() {
-  gcov_flush_lock();
-
   struct fn_node* curr = flush_fn_list.head;
 
   while (curr) {
     curr->fn();
     curr = curr->next;
   }
-
-  gcov_flush_unlock();
 }
 
 COMPILER_RT_VISIBILITY

commit 3abd9cd486d9c45867458f64d1294db698c39b4e
Author: Roman Lebedev <lebedev.ri@gmail.com>
Date:   Tue Feb 25 20:08:58 2020 +0300

    [Codegen] Revert rL354676/rL354677 and followups - introduced PR43446 miscompile
    
    This reverts https://reviews.llvm.org/D58468
    (rL354676, 44037d7a6377ec8e5542cced73583283334b516b),
    and all and any follow-ups to that code block.
    
    https://bugs.llvm.org/show_bug.cgi?id=43446
    
    (cherry picked from commit d20907d1de89bf63b589fadd8c096d4895e47fba)

diff --git a/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp b/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
index e5bc08b9280..8ff04797c8d 100644
--- a/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
+++ b/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp
@@ -16510,33 +16510,6 @@ SDValue DAGCombiner::visitSTORE(SDNode *N) {
           CombineTo(ST1, ST1->getChain());
           return SDValue();
         }
-
-        // If ST stores to a subset of preceding store's write set, we may be
-        // able to fold ST's value into the preceding stored value. As we know
-        // the other uses of ST1's chain are unconcerned with ST, this folding
-        // will not affect those nodes.
-        int64_t BitOffset;
-        if (ChainBase.contains(DAG, ChainBitSize, STBase, STBitSize,
-                               BitOffset)) {
-          SDValue ChainValue = ST1->getValue();
-          if (auto *C1 = dyn_cast<ConstantSDNode>(ChainValue)) {
-            if (auto *C = dyn_cast<ConstantSDNode>(Value)) {
-              APInt Val = C1->getAPIntValue();
-              APInt InsertVal = C->getAPIntValue().zextOrTrunc(STBitSize);
-              // FIXME: Handle Big-endian mode.
-              if (!DAG.getDataLayout().isBigEndian()) {
-                Val.insertBits(InsertVal, BitOffset);
-                SDValue NewSDVal =
-                    DAG.getConstant(Val, SDLoc(C), ChainValue.getValueType(),
-                                    C1->isTargetOpcode(), C1->isOpaque());
-                SDNode *NewST1 = DAG.UpdateNodeOperands(
-                    ST1, ST1->getChain(), NewSDVal, ST1->getOperand(2),
-                    ST1->getOperand(3));
-                return CombineTo(ST, SDValue(NewST1, 0));
-              }
-            }
-          }
-        } // End ST subset of ST1 case.
       }
     }
   }
diff --git a/llvm/test/CodeGen/AArch64/ldst-paired-aliasing.ll b/llvm/test/CodeGen/AArch64/ldst-paired-aliasing.ll
index f36131223b0..697ba4615dc 100644
--- a/llvm/test/CodeGen/AArch64/ldst-paired-aliasing.ll
+++ b/llvm/test/CodeGen/AArch64/ldst-paired-aliasing.ll
@@ -1,3 +1,4 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
 ; RUN: llc -mcpu cortex-a53 < %s | FileCheck %s
 target datalayout = "e-m:e-i64:64-i128:128-n8:16:32:64-S128"
 target triple = "aarch64--linux-gnu"
@@ -10,11 +11,33 @@ declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i1) #3
 define i32 @main() local_unnamed_addr #1 {
 ; Make sure the stores happen in the correct order (the exact instructions could change).
 ; CHECK-LABEL: main:
+; CHECK:       // %bb.0: // %for.body.lr.ph.i.i.i.i.i.i63
+; CHECK-NEXT:    sub sp, sp, #112 // =112
+; CHECK-NEXT:    str x30, [sp, #96] // 8-byte Folded Spill
+; CHECK-NEXT:    .cfi_def_cfa_offset 112
+; CHECK-NEXT:    .cfi_offset w30, -16
+; CHECK-NEXT:    bl _Z5setupv
+; CHECK-NEXT:    movi v0.4s, #1
+; CHECK-NEXT:    mov w9, #1
+; CHECK-NEXT:    add x0, sp, #48 // =48
+; CHECK-NEXT:    mov x1, sp
+; CHECK-NEXT:    str xzr, [sp, #80]
+; CHECK-NEXT:    str w9, [sp, #80]
+; CHECK-NEXT:    stp q0, q0, [sp, #48]
+; CHECK-NEXT:    ldr w8, [sp, #48]
+; CHECK-NEXT:    cmp w8, #1 // =1
+; CHECK-NEXT:    b.ne .LBB0_2
+; CHECK-NEXT:  // %bb.1: // %for.inc
+; CHECK-NEXT:    bl f
+; CHECK-NEXT:    b .LBB0_3
+; CHECK-NEXT:  .LBB0_2: // %if.then
+; CHECK-NEXT:    bl f2
+; CHECK-NEXT:  .LBB0_3: // %for.inc
+; CHECK-NEXT:    ldr x30, [sp, #96] // 8-byte Folded Reload
+; CHECK-NEXT:    mov w0, wzr
+; CHECK-NEXT:    add sp, sp, #112 // =112
+; CHECK-NEXT:    ret
 
-; CHECK: mov w9, #1
-; CHECK: str x9, [sp, #80]
-; CHECK: stp q0, q0, [sp, #48]
-; CHECK: ldr w8, [sp, #48]
 
 for.body.lr.ph.i.i.i.i.i.i63:
   %b1 = alloca [10 x i32], align 16
diff --git a/llvm/test/CodeGen/PowerPC/constant-combines.ll b/llvm/test/CodeGen/PowerPC/constant-combines.ll
index dd40b75d58f..05f23051d40 100644
--- a/llvm/test/CodeGen/PowerPC/constant-combines.ll
+++ b/llvm/test/CodeGen/PowerPC/constant-combines.ll
@@ -13,8 +13,10 @@ define void @fold_constant_stores_loaddr(i8* %i8_ptr) {
 ;
 ; LE-LABEL: fold_constant_stores_loaddr:
 ; LE:       # %bb.0: # %entry
-; LE-NEXT:    li 4, 170
+; LE-NEXT:    li 4, 0
+; LE-NEXT:    li 5, -86
 ; LE-NEXT:    std 4, 0(3)
+; LE-NEXT:    stb 5, 0(3)
 ; LE-NEXT:    blr
 entry:
   %i64_ptr = bitcast i8* %i8_ptr to i64*
@@ -35,8 +37,10 @@ define void @fold_constant_stores_hiaddr(i8* %i8_ptr) {
 ;
 ; LE-LABEL: fold_constant_stores_hiaddr:
 ; LE:       # %bb.0: # %entry
-; LE-NEXT:    li 4, 170
+; LE-NEXT:    li 4, 0
+; LE-NEXT:    li 5, -86
 ; LE-NEXT:    std 4, 0(3)
+; LE-NEXT:    stb 5, 0(3)
 ; LE-NEXT:    blr
 entry:
   %i64_ptr = bitcast i8* %i8_ptr to i64*
diff --git a/llvm/test/CodeGen/X86/constant-combines.ll b/llvm/test/CodeGen/X86/constant-combines.ll
index 45bc635bb67..736aea6b598 100644
--- a/llvm/test/CodeGen/X86/constant-combines.ll
+++ b/llvm/test/CodeGen/X86/constant-combines.ll
@@ -7,7 +7,8 @@ target triple = "x86_64-unknown-unknown"
 define void @bitstore_fold() {
 ; CHECK-LABEL: bitstore_fold:
 ; CHECK:       # %bb.0: # %BB
-; CHECK-NEXT:    movl $-2, 0
+; CHECK-NEXT:    movl $-1, 0
+; CHECK-NEXT:    movb $0, 0
 ; CHECK-NEXT:    retq
 BB:
    store i32 -1, i32* null
diff --git a/llvm/test/CodeGen/X86/lifetime-alias.ll b/llvm/test/CodeGen/X86/lifetime-alias.ll
index b8fe2ea73e8..010dc33b505 100644
--- a/llvm/test/CodeGen/X86/lifetime-alias.ll
+++ b/llvm/test/CodeGen/X86/lifetime-alias.ll
@@ -23,7 +23,7 @@ target triple = "x86_64-unknown-linux-gnu"
 @__PRETTY_FUNCTION__.main = private unnamed_addr constant [11 x i8] c"int main()\00", align 1
 
 ; Function Attrs: norecurse uwtable
-define dso_local i8 @main() local_unnamed_addr #0 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
+define i8 @main() local_unnamed_addr #0 personality i8* bitcast (i32 (...)* @__gxx_personality_v0 to i8*) {
 ; CHECK-LABEL: main:
 ; CHECK:       # %bb.0: # %_ZNSt3__312basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev.exit50
 ; CHECK-NEXT:    pushq %rax
@@ -35,6 +35,8 @@ define dso_local i8 @main() local_unnamed_addr #0 personality i8* bitcast (i32 (
 ; CHECK-NEXT:    movw $5632, {{[0-9]+}}(%rsp) # imm = 0x1600
 ; CHECK-NEXT:    xorps %xmm0, %xmm0
 ; CHECK-NEXT:    movaps %xmm0, -{{[0-9]+}}(%rsp)
+; CHECK-NEXT:    movq $0, -{{[0-9]+}}(%rsp)
+; CHECK-NEXT:    movb $11, -{{[0-9]+}}(%rsp)
 ; CHECK-NEXT:    movabsq $8389209137051166804, %rax # imm = 0x746C754320656854
 ; CHECK-NEXT:    movq %rax, -{{[0-9]+}}(%rsp)
 ; CHECK-NEXT:    movl $1701999988, -{{[0-9]+}}(%rsp) # imm = 0x65727574
@@ -47,7 +49,7 @@ define dso_local i8 @main() local_unnamed_addr #0 personality i8* bitcast (i32 (
 ; CHECK-NEXT:    movups {{.*}}(%rip), %xmm1
 ; CHECK-NEXT:    movaps %xmm1, -{{[0-9]+}}(%rsp)
 ; CHECK-NEXT:    movb $0, -{{[0-9]+}}(%rsp)
-; CHECK-NEXT:    movabsq $792633534417207296, %rax # imm = 0xB00000000000000
+; CHECK-NEXT:    movq -{{[0-9]+}}(%rsp), %rax
 ; CHECK-NEXT:    movq %rax, -{{[0-9]+}}(%rsp)
 ; CHECK-NEXT:    movq -{{[0-9]+}}(%rsp), %rax
 ; CHECK-NEXT:    movq %rax, -{{[0-9]+}}(%rsp)
@@ -68,9 +70,9 @@ define dso_local i8 @main() local_unnamed_addr #0 personality i8* bitcast (i32 (
 ; CHECK-NEXT:    movaps %xmm0, -{{[0-9]+}}(%rsp)
 ; CHECK-NEXT:    movq $0, -{{[0-9]+}}(%rsp)
 ; CHECK-NEXT:    leaq -{{[0-9]+}}(%rsp), %rax
-; CHECK-NEXT:    movq %rax, {{.*}}(%rip)
+; CHECK-NEXT:    movq %rax, do_not_optimize{{.*}}(%rip)
 ; CHECK-NEXT:    leaq -{{[0-9]+}}(%rsp), %rax
-; CHECK-NEXT:    movq %rax, {{.*}}(%rip)
+; CHECK-NEXT:    movq %rax, do_not_optimize{{.*}}(%rip)
 ; CHECK-NEXT:    cmpb $0, -{{[0-9]+}}(%rsp)
 ; CHECK-NEXT:    jns .LBB0_1
 ; CHECK-NEXT:  # %bb.2: # %_ZNSt3__312basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev.exit50
diff --git a/llvm/test/CodeGen/X86/pr40631_deadstore_elision.ll b/llvm/test/CodeGen/X86/pr40631_deadstore_elision.ll
index f330e0f1578..c742ce4bd94 100644
--- a/llvm/test/CodeGen/X86/pr40631_deadstore_elision.ll
+++ b/llvm/test/CodeGen/X86/pr40631_deadstore_elision.ll
@@ -12,12 +12,13 @@ define i32 @ipt_do_table(%struct.sk_buff* noalias nocapture readonly) {
 ; CHECK-NEXT:    movq (%rdi), %rax
 ; CHECK-NEXT:    xorps %xmm0, %xmm0
 ; CHECK-NEXT:    movaps %xmm0, {{[0-9]+}}(%rsp)
-; CHECK-NEXT:    movq $170, {{[0-9]+}}(%rsp)
+; CHECK-NEXT:    movq $0, {{[0-9]+}}(%rsp)
 ; CHECK-NEXT:    movaps {{.*#+}} xmm0 = [12297829382473034410,12297829382473034410]
 ; CHECK-NEXT:    movaps %xmm0, (%rsp)
 ; CHECK-NEXT:    movabsq $-6148914691236517206, %rcx # imm = 0xAAAAAAAAAAAAAAAA
 ; CHECK-NEXT:    movq %rcx, {{[0-9]+}}(%rsp)
 ; CHECK-NEXT:    movq %rcx, {{[0-9]+}}(%rsp)
+; CHECK-NEXT:    movb $-86, {{[0-9]+}}(%rsp)
 ; CHECK-NEXT:    movzwl 2(%rax), %ecx
 ; CHECK-NEXT:    andl $8191, %ecx # imm = 0x1FFF
 ; CHECK-NEXT:    movl %ecx, {{[0-9]+}}(%rsp)
diff --git a/llvm/test/CodeGen/X86/stores-merging.ll b/llvm/test/CodeGen/X86/stores-merging.ll
index 25c93c3e7a2..6420ac7dc3e 100644
--- a/llvm/test/CodeGen/X86/stores-merging.ll
+++ b/llvm/test/CodeGen/X86/stores-merging.ll
@@ -26,8 +26,9 @@ define void @redundant_stores_merging() {
 define void @redundant_stores_merging_reverse() {
 ; CHECK-LABEL: redundant_stores_merging_reverse:
 ; CHECK:       # %bb.0:
-; CHECK-NEXT:    movabsq $1958505086977, %rax # imm = 0x1C800000001
+; CHECK-NEXT:    movabsq $528280977409, %rax # imm = 0x7B00000001
 ; CHECK-NEXT:    movq %rax, e+{{.*}}(%rip)
+; CHECK-NEXT:    movl $456, e+{{.*}}(%rip) # imm = 0x1C8
 ; CHECK-NEXT:    retq
   store i32 123, i32* getelementptr inbounds (%structTy, %structTy* @e, i64 0, i32 2), align 4
   store i32 456, i32* getelementptr inbounds (%structTy, %structTy* @e, i64 0, i32 2), align 4
@@ -219,3 +220,25 @@ define void @extract_vector_store_32_consecutive_bytes(<4 x i64> %v, i8* %ptr) #
   ret void
 }
 
+; https://bugs.llvm.org/show_bug.cgi?id=43446
+define void @pr43446_0(i64 %x) {
+; CHECK-LABEL: pr43446_0:
+; CHECK:       # %bb.0:
+; CHECK-NEXT:    movb $1, (%rdi)
+; CHECK-NEXT:    retq
+  %a = inttoptr i64 %x to i8*
+  store i8 -2, i8* %a, align 1
+  %b = inttoptr i64 %x to i1*
+  store i1 true, i1* %b, align 1
+  ret void
+}
+define void @pr43446_1(i8* %a) {
+; CHECK-LABEL: pr43446_1:
+; CHECK:       # %bb.0:
+; CHECK-NEXT:    movb $1, (%rdi)
+; CHECK-NEXT:    retq
+  store i8 -2, i8* %a, align 1
+  %b = bitcast i8* %a to i1*
+  store i1 true, i1* %b, align 1
+  ret void
+}

commit f87cc45dffa0a83b9db1aff143829d3f5c04c52f
Author: Hans Wennborg <hans@chromium.org>
Date:   Tue Feb 25 16:58:36 2020 +0100

    Put microsoft template parameter shadow warning behind separate flag (PR44794)
    
    Differential revision: https://reviews.llvm.org/D75121
    
    (cherry picked from commit 41a6612ea8afc5254e4de3aca55628d37f0be433)

diff --git a/clang/include/clang/Basic/DiagnosticGroups.td b/clang/include/clang/Basic/DiagnosticGroups.td
index 67885ac14ab..8e43052f30e 100644
--- a/clang/include/clang/Basic/DiagnosticGroups.td
+++ b/clang/include/clang/Basic/DiagnosticGroups.td
@@ -1014,7 +1014,8 @@ def MicrosoftExplicitConstructorCall : DiagGroup<
 def MicrosoftEnumValue : DiagGroup<"microsoft-enum-value">;
 def MicrosoftDefaultArgRedefinition :
     DiagGroup<"microsoft-default-arg-redefinition">;
-def MicrosoftTemplate : DiagGroup<"microsoft-template">;
+def MicrosoftTemplateShadow : DiagGroup<"microsoft-template-shadow">;
+def MicrosoftTemplate : DiagGroup<"microsoft-template", [MicrosoftTemplateShadow]>;
 def MicrosoftInconsistentDllImport : DiagGroup<"inconsistent-dllimport">;
 def MicrosoftRedeclareStatic : DiagGroup<"microsoft-redeclare-static">;
 def MicrosoftEnumForwardReference :
diff --git a/clang/include/clang/Basic/DiagnosticSemaKinds.td b/clang/include/clang/Basic/DiagnosticSemaKinds.td
index f643739eaac..91737742050 100644
--- a/clang/include/clang/Basic/DiagnosticSemaKinds.td
+++ b/clang/include/clang/Basic/DiagnosticSemaKinds.td
@@ -4210,7 +4210,7 @@ def err_ovl_no_viable_literal_operator : Error<
 def err_template_param_shadow : Error<
   "declaration of %0 shadows template parameter">;
 def ext_template_param_shadow : ExtWarn<
-  err_template_param_shadow.Text>, InGroup<MicrosoftTemplate>;
+  err_template_param_shadow.Text>, InGroup<MicrosoftTemplateShadow>;
 def note_template_param_here : Note<"template parameter is declared here">;
 def warn_template_export_unsupported : Warning<
   "exported templates are unsupported">;
diff --git a/clang/test/SemaCXX/microsoft-template-shadow.cpp b/clang/test/SemaCXX/microsoft-template-shadow.cpp
new file mode 100644
index 00000000000..ab2ffdefdd8
--- /dev/null
+++ b/clang/test/SemaCXX/microsoft-template-shadow.cpp
@@ -0,0 +1,11 @@
+// RUN: %clang_cc1 %s -triple i686-pc-win32 -fsyntax-only -verify -fms-compatibility -Wno-microsoft -Wmicrosoft-template-shadow
+
+template <typename T> // expected-note {{template parameter is declared here}}
+struct Outmost {
+  template <typename T> // expected-warning {{declaration of 'T' shadows template parameter}}
+  struct Inner {
+    void f() {
+      T *var;
+    }
+  };
+};

commit 48d24465668b268ec0aa39b62cabab5ee50e961d
Author: Philip Reames <listmail@philipreames.com>
Date:   Tue Feb 25 08:56:53 2020 -0800

    Revert "[LICM] Support hosting of dynamic allocas out of loops"
    
    This reverts commit 8d22100f66c4170510c6ff028c60672acfe1cff9.
    
    There was a functional regression reported (https://bugs.llvm.org/show_bug.cgi?id=44996).  I'm not actually sure the patch is wrong, but I don't have time to investigate currently, and this line of work isn't something I'm likely to get back to quickly.
    
    (cherry picked from commit 14845b2c459021e3dbf2ead52d707d4a7db40cbb)

diff --git a/llvm/lib/Transforms/Scalar/LICM.cpp b/llvm/lib/Transforms/Scalar/LICM.cpp
index eb023d49b0a..a1c012fddde 100644
--- a/llvm/lib/Transforms/Scalar/LICM.cpp
+++ b/llvm/lib/Transforms/Scalar/LICM.cpp
@@ -790,41 +790,6 @@ public:
 };
 } // namespace
 
-
-/// Return true if we know how to rewrite all uses of the given alloca after
-/// hoisting it out of the loop.  The main concerns are a) potential captures
-/// and b) invariant.start markers which don't capture, but are no longer
-/// valid w/o a corresponding invariant.end.
-static bool canRewriteUsesOfAlloca(AllocaInst &AI) {
-  // TODO: This looks a lot like capture tracking, but we need to remove any
-  // invariant starts if we extend the lifetime of the alloca by hoisting it.
-  // We should probably refactor capture tracking into a form which allows us
-  // to reuse the relevant bits and remove the duplicated logic here.
-
-  SmallVector<Use *, 16> Worklist;
-  for (Use &U : AI.uses())
-    Worklist.push_back(&U);
-  
-  unsigned NumUsesExplored = 0;
-  while (!Worklist.empty()) {
-    Use *U = Worklist.pop_back_val();
-    Instruction *I = cast<Instruction>(U->getUser());
-    NumUsesExplored++;
-    if (NumUsesExplored > DefaultMaxUsesToExplore)
-      return false;
-    // Non capturing, terminating uses
-    if (isa<LoadInst>(I) ||
-        (isa<StoreInst>(I) && U->getOperandNo() == 1))
-      continue;
-    // Non capturing, non-terminating
-    if (!isa<BitCastInst>(I) && !isa<GetElementPtrInst>(I))
-      return false;
-    for (Use &U : I->uses())
-      Worklist.push_back(&U);
-  }
-  return true;
-}
-
 /// Walk the specified region of the CFG (defined by all blocks dominated by
 /// the specified block, and that are in the current loop) in depth first
 /// order w.r.t the DominatorTree.  This allows us to visit definitions before
@@ -945,16 +910,6 @@ bool llvm::hoistRegion(DomTreeNode *N, AliasAnalysis *AA, LoopInfo *LI,
         continue;
       }
 
-      if (isa<AllocaInst>(&I) &&
-          SafetyInfo->isGuaranteedToExecute(I, DT, CurLoop) &&
-          canRewriteUsesOfAlloca(cast<AllocaInst>(I))) {
-        hoist(I, DT, CurLoop, CFH.getOrCreateHoistedBlock(BB), SafetyInfo,
-              MSSAU, SE, ORE);
-        HoistedInstructions.push_back(&I);
-        Changed = true;
-        continue;
-      }
-
       if (PHINode *PN = dyn_cast<PHINode>(&I)) {
         if (CFH.canHoistPHI(PN)) {
           // Redirect incoming blocks first to ensure that we create hoisted
diff --git a/llvm/test/Transforms/LICM/hoist-alloca.ll b/llvm/test/Transforms/LICM/hoist-alloca.ll
deleted file mode 100644
index 8e4debac283..00000000000
--- a/llvm/test/Transforms/LICM/hoist-alloca.ll
+++ /dev/null
@@ -1,168 +0,0 @@
-; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
-; RUN: opt -S -licm < %s | FileCheck %s
-
-@G = external global i64
-
-define void @test(i64 %n) {
-; CHECK-LABEL: @test(
-; CHECK-NEXT:  entry:
-; CHECK-NEXT:    [[A:%.*]] = alloca i64
-; CHECK-NEXT:    [[VAL:%.*]] = load i64, i64* [[A]]
-; CHECK-NEXT:    store i64 [[VAL]], i64* @G
-; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
-; CHECK:       for.body:
-; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ]
-; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
-; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ult i64 [[IV]], [[N:%.*]]
-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[EXIT:%.*]]
-; CHECK:       exit:
-; CHECK-NEXT:    ret void
-;
-entry:
-  br label %for.body
-
-for.body:
-  %iv = phi i64 [ %iv.next, %for.body ], [ 0, %entry ]
-  %a = alloca i64
-  %val = load i64, i64* %a
-  store i64 %val, i64* @G
-  %iv.next = add nuw nsw i64 %iv, 1
-  %exitcond = icmp ult i64 %iv, %n
-  br i1 %exitcond, label %for.body, label %exit
-exit:
-  ret void
-}
-
-define void @test2(i64 %n) {
-; CHECK-LABEL: @test2(
-; CHECK-NEXT:  entry:
-; CHECK-NEXT:    [[A:%.*]] = alloca i64
-; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
-; CHECK:       for.body:
-; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ]
-; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
-; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ult i64 [[IV]], [[N:%.*]]
-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[EXIT:%.*]]
-; CHECK:       exit:
-; CHECK-NEXT:    [[IV_LCSSA:%.*]] = phi i64 [ [[IV]], [[FOR_BODY]] ]
-; CHECK-NEXT:    store i64 [[IV_LCSSA]], i64* [[A]], align 4
-; CHECK-NEXT:    ret void
-;
-entry:
-  br label %for.body
-
-for.body:
-  %iv = phi i64 [ %iv.next, %for.body ], [ 0, %entry ]
-  %a = alloca i64
-  store i64 %iv, i64* %a
-  %iv.next = add nuw nsw i64 %iv, 1
-  %exitcond = icmp ult i64 %iv, %n
-  br i1 %exitcond, label %for.body, label %exit
-exit:
-  ret void
-}
-
-
-define void @test3(i64 %n) {
-; CHECK-LABEL: @test3(
-; CHECK-NEXT:  entry:
-; CHECK-NEXT:    [[A:%.*]] = alloca i64
-; CHECK-NEXT:    [[A_I8:%.*]] = bitcast i64* [[A]] to i8*
-; CHECK-NEXT:    [[A_OFFSET:%.*]] = getelementptr i8, i8* [[A_I8]], i64 4
-; CHECK-NEXT:    store i8 0, i8* [[A_OFFSET]]
-; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
-; CHECK:       for.body:
-; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ]
-; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
-; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ult i64 [[IV]], [[N:%.*]]
-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[EXIT:%.*]]
-; CHECK:       exit:
-; CHECK-NEXT:    ret void
-;
-entry:
-  br label %for.body
-
-for.body:
-  %iv = phi i64 [ %iv.next, %for.body ], [ 0, %entry ]
-  %a = alloca i64
-  %a.i8 = bitcast i64* %a to i8*
-  %a.offset = getelementptr i8, i8* %a.i8, i64 4
-  store i8 0, i8* %a.offset
-  %iv.next = add nuw nsw i64 %iv, 1
-  %exitcond = icmp ult i64 %iv, %n
-  br i1 %exitcond, label %for.body, label %exit
-exit:
-  ret void
-}
-
-; This example is subtle.  Because the dynamic alloca isn't reclaimed until
-; end of function scope, the captured value can legally point to a dynamic
-; alloca stack region from a previous iteration.
-define void @test4(i64 %n) {
-; CHECK-LABEL: @test4(
-; CHECK-NEXT:  entry:
-; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
-; CHECK:       for.body:
-; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ]
-; CHECK-NEXT:    [[A:%.*]] = alloca i64
-; CHECK-NEXT:    store i64 [[IV]], i64* [[A]]
-; CHECK-NEXT:    call void @capture(i64* [[A]])
-; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
-; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ult i64 [[IV]], [[N:%.*]]
-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[EXIT:%.*]]
-; CHECK:       exit:
-; CHECK-NEXT:    ret void
-;
-entry:
-  br label %for.body
-
-for.body:
-  %iv = phi i64 [ %iv.next, %for.body ], [ 0, %entry ]
-  %a = alloca i64
-  store i64 %iv, i64* %a
-  %a.i8 = bitcast i64* %a to i8*
-  call void @capture(i64* %a)
-  %iv.next = add nuw nsw i64 %iv, 1
-  %exitcond = icmp ult i64 %iv, %n
-  br i1 %exitcond, label %for.body, label %exit
-exit:
-  ret void
-}
-declare void @capture(i64* %a)
-
-
-; TODO: not yet handled
-define void @test5(i64 %n) {
-; CHECK-LABEL: @test5(
-; CHECK-NEXT:  entry:
-; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
-; CHECK:       for.body:
-; CHECK-NEXT:    [[IV:%.*]] = phi i64 [ [[IV_NEXT:%.*]], [[FOR_BODY]] ], [ 0, [[ENTRY:%.*]] ]
-; CHECK-NEXT:    [[A:%.*]] = alloca i64
-; CHECK-NEXT:    store i64 [[IV]], i64* [[A]]
-; CHECK-NEXT:    [[A_I8:%.*]] = bitcast i64* [[A]] to i8*
-; CHECK-NEXT:    [[TMP0:%.*]] = call {}* @llvm.invariant.start.p0i8(i64 8, i8* [[A_I8]])
-; CHECK-NEXT:    [[IV_NEXT]] = add nuw nsw i64 [[IV]], 1
-; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp ult i64 [[IV]], [[N:%.*]]
-; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_BODY]], label [[EXIT:%.*]]
-; CHECK:       exit:
-; CHECK-NEXT:    ret void
-;
-entry:
-  br label %for.body
-
-for.body:
-  %iv = phi i64 [ %iv.next, %for.body ], [ 0, %entry ]
-  %a = alloca i64
-  store i64 %iv, i64* %a
-  %a.i8 = bitcast i64* %a to i8*
-  call {}* @llvm.invariant.start.p0i8(i64 8, i8* %a.i8)
-  %iv.next = add nuw nsw i64 %iv, 1
-  %exitcond = icmp ult i64 %iv, %n
-  br i1 %exitcond, label %for.body, label %exit
-exit:
-  ret void
-}
-
-declare {}* @llvm.invariant.start.p0i8(i64, i8* nocapture) nounwind readonly
-

commit 456e9c2e14bc936100f1d84e7637122b306d8c4c
Author: Florian Hahn <flo@fhahn.com>
Date:   Wed Feb 26 16:54:49 2020 +0000

    [ReleaseNotes] Mention new matrix intrinsics.
    
    Reviewers: anemet, Gerolf
    
    Reviewed By: anemet
    
    Differential Revision: https://reviews.llvm.org/D75161

diff --git a/llvm/docs/LangRef.rst b/llvm/docs/LangRef.rst
index 0ae374de4b6..190c282eacc 100644
--- a/llvm/docs/LangRef.rst
+++ b/llvm/docs/LangRef.rst
@@ -14553,6 +14553,9 @@ Arguments:
 """"""""""
 The argument to this intrinsic must be a vector of floating-point values.
 
+
+.. _i_matrixintrinsics:
+
 Matrix Intrinsics
 -----------------
 
diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index 60dd07ddb26..6ade99ab174 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -106,6 +106,12 @@ Non-comprehensive list of changes in this release
   still under heavy development and disabled by default, to enable an early run
   pass ``-mllvm -attributor-disable=false`` to an invocation of clang.
 
+* New matrix math intrinsics have been added to LLVM
+  (see :ref:`LLVM Language Reference Manual <i_matrixintrinsics>`), together
+  with the LowerMatrixIntrinsics pass. The pass lowers matrix intrinsics
+  to a set of efficient vector instructions. The lowering pass is off
+  by default and can be enabled by passing ``-mllvm -enable-matrix`` to an
+  invocation of clang.
 
 
 Changes to the LLVM IR

commit 5cfd30add460640264c7d88c4d837a2d4e0ae7b1
Author: Sam Elliott <selliott@lowrisc.org>
Date:   Wed Feb 26 18:19:07 2020 +0000

    [RISCV] Add Clang and LLVM Release Notes

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index b160588b22c..c9d0461b65a 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -122,6 +122,9 @@ Non-comprehensive list of changes in this release
 * For the WebAssembly target, the ``wasm-opt`` tool will now be run if it is
   found in the PATH, which can reduce code size.
 
+* For the RISC-V target, floating point registers can now be used in inline
+  assembly constraints.
+
 New Compiler Flags
 ------------------
 
@@ -141,6 +144,13 @@ New Compiler Flags
   please let us know if you encounter a situation where you need to specify this
   flag for correct program behavior.
 
+- The `-ffixed-xX` flags now work on RISC-V. These reserve the corresponding
+  general-purpose registers.
+
+- RISC-V has added `-mcmodel=medany` and `-mcmodel=medlow` as aliases for
+  `-mcmodel=small` and `-mcmodel=medium` respectively. Preprocessor definitions
+  for `__riscv_cmodel_medlow` and `__riscv_cmodel_medany` have been corrected.
+
 Deprecated Compiler Flags
 -------------------------
 
@@ -182,6 +192,12 @@ Modified Compiler Flags
   which is one level below ``-debug-info-kind=limited``. This option causes
   debug info for classes to be emitted only when a constructor is emitted.
 
+- RISC-V now chooses a slightly different sysroot path and defaults to using
+  compiler-rt if no GCC installation is detected.
+
+- RISC-V now supports multilibs in baremetal environments. This support does not
+  extend to supporting multilib aliases.
+
 New Pragmas in Clang
 --------------------
 
@@ -309,6 +325,11 @@ ABI Changes in Clang
   `-mabi=` when compiling for RISC-V, due to how extensible this architecture
   is.
 
+- RISC-V now uses `target-abi` module metadata to encode the chosen psABI. This
+  ensures that the correct lowering will be done by LLVM when LTO is enabled.
+
+- An issue with lowering return types in the RISC-V ILP32D psABI has been fixed.
+
 OpenMP Support in Clang
 -----------------------
 
diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index 6ade99ab174..69a055aeef6 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -252,6 +252,65 @@ Changes to the Windows Target
 
 * Fixed section relative relocations in .debug_frame in DWARF debug info
 
+Changes to the RISC-V Target
+----------------------------
+
+New Features:
+* The Machine Outliner has been enabled.
+* Shrink-wrapping has been enabled.
+* The Machine Scheduler has been enabled and scheduler descriptions for the
+  Rocket micro-architecture have been added, covering both 32- and 64-bit Rocket
+  cores.
+* This release lays the groundwork for enabling LTO in a future LLVM release.
+  In particular, LLVM now uses a new `target-abi` module metadata item to
+  represent the chosen RISC-V psABI variant. Frontends should add this module
+  flag to prevent ABI lowering problems when LTO is enabled in a future LLVM
+  release.
+* Support has been added for assembling RVC HINT instructions.
+* Added code lowering for half-precision floats.
+* The `fscsr` and `frcsr` (`fssr`, `frsr`) obsolete aliases have been added to
+  the assembler for use in legacy code.
+* The stack can now be realigned even when there are variable-sized objects in
+  the same frame.
+* fastcc is now supported.
+* llvm-objdump now supports `-M no-aliases` and `-M numeric` for altering the
+  dumped assembly. These match the behaviour of GNU objdump.
+
+Improvements:
+* Trap and Debugtrap now lower to RISC-V-specific trap instructions.
+* LLVM IR Inline assembly now supports using ABI register names and using
+  floating point registers in constraints.
+* Stack Pointer adjustments have been changed to better match RISC-V's immediates.
+* `ra` (`x1`) can now be used as a callee-saved register.
+* The assembler now suggests spelling corrections for unknown assembly
+  mnemonics.
+* Stack offsets of greater than 32-bits are now accepted on RV64.
+* Some variadic functions can now be tail-call optimised.
+* We now custom-lower 32-bit arithmetic operations on RV64 to reduce
+  sign-extensions.
+
+
+Bug Fixes:
+
+* There was an issue with register preservation after calls in interrupt
+  handlers, where some registers were marked as preserved even though they were
+  not being preserved by the call. This has been corrected, and now only
+  callee-saved registers are live over a function call in an interrupt handler
+  (just like calls in regular functions).
+* Atomic instructions now only accept GPRs (plus an offset) in memory operands.
+* Fixed some issues with evalutaion of relocations and fixups.
+* The error messages around missing RISC-V extensions in the assembler have been
+  improved.
+* The error messages around unsupported relocations have been improved.
+* Non-PIC code no longer forces Local Exec TLS.
+* There have been some small changes to the code generation for atomic
+  operations.
+* RISC-V no longer emits incorrect CFI directives in function prologs and
+  epilogs.
+* RV64 no longer clears the upper bits when returning complex types from
+  libcalls using the LP64 psABI.
+
+
 
 Changes to the OCaml bindings
 -----------------------------

commit d7afdb596e865c11b853d8c5df7d96d594170e1c
Author: Michael Kruse <llvm-project@meinersbur.de>
Date:   Mon Feb 24 11:51:00 2020 -0600

    [CMake] Default to static linking for subprojects.
    
    Pass plugins introduced in D61446 do not support dynamic linking on
    Windows, hence the option LLVM_${name_upper}_LINK_INTO_TOOLS can only
    work being set to "ON". Currently, it defaults to "OFF" such that such
    plugins are inoperable by default on Windows. Change the default for
    subprojects to follow LLVM_ENABLE_PROJECTS.
    
    Reviewed By: serge-sans-paille, MaskRay
    
    Differential Revision: https://reviews.llvm.org/D72372
    
    (cherry picked from commit 6369b9bf31188bdd472299252deb6db3f650864b)
    
    This is for PR45001.

diff --git a/llvm/cmake/modules/AddLLVM.cmake b/llvm/cmake/modules/AddLLVM.cmake
index 32798b1b44a..8d674f93542 100644
--- a/llvm/cmake/modules/AddLLVM.cmake
+++ b/llvm/cmake/modules/AddLLVM.cmake
@@ -854,14 +854,25 @@ endmacro(add_llvm_executable name)
 #
 #   If NO_MODULE is specified, when option LLVM_${name_upper}_LINK_INTO_TOOLS is set to OFF,
 #   only an object library is built, and no module is built. This is specific to the Polly use case.
+#
+#   The SUBPROJECT argument contains the LLVM project the plugin belongs
+#   to. If set, the plugin will link statically by default it if the 
+#   project was enabled.
 function(add_llvm_pass_plugin name)
   cmake_parse_arguments(ARG
-    "NO_MODULE" "" ""
+    "NO_MODULE" "SUBPROJECT" ""
     ${ARGN})
 
   string(TOUPPER ${name} name_upper)
 
-  option(LLVM_${name_upper}_LINK_INTO_TOOLS "Statically link ${name} into tools (if available)" OFF)
+  # Enable the plugin by default if it was explicitly enabled by the user.
+  # Note: If was set to "all", LLVM's CMakeLists.txt replaces it with a
+  # list of all projects, counting as explicitly enabled.
+  set(link_into_tools_default OFF)
+  if (ARG_SUBPROJECT AND LLVM_TOOL_${name_upper}_BUILD)
+    set(link_into_tools_default ON)
+  endif()
+  option(LLVM_${name_upper}_LINK_INTO_TOOLS "Statically link ${name} into tools (if available)" ${link_into_tools_default})
 
   if(LLVM_${name_upper}_LINK_INTO_TOOLS)
     list(REMOVE_ITEM ARG_UNPARSED_ARGUMENTS BUILDTREE_ONLY)
diff --git a/polly/lib/CMakeLists.txt b/polly/lib/CMakeLists.txt
index ee0834cc8e3..35614973a5d 100644
--- a/polly/lib/CMakeLists.txt
+++ b/polly/lib/CMakeLists.txt
@@ -25,6 +25,7 @@ endif ()
 # the sources them to be recompiled for each of them.
 add_llvm_pass_plugin(Polly
   NO_MODULE
+  SUBPROJECT Polly
   Analysis/DependenceInfo.cpp
   Analysis/PolyhedralInfo.cpp
   Analysis/ScopDetection.cpp

commit 00f4618182ada5316650eebedac3702b73819ec0
Author: Hans Wennborg <hans@chromium.org>
Date:   Wed Feb 26 19:40:47 2020 +0100

    Revert "[Polly][docs] Polly release notes."
    
    It no longer applies after d7afdb596e865c11b853d8c5df7d96d594170e1c.
    
    This reverts commit 002af0119286297dbd76b08a4a6cc4b6b87d3f26.

diff --git a/polly/docs/ReleaseNotes.rst b/polly/docs/ReleaseNotes.rst
index 5f49e619976..1d9aacc9aa6 100644
--- a/polly/docs/ReleaseNotes.rst
+++ b/polly/docs/ReleaseNotes.rst
@@ -10,44 +10,4 @@ In Polly 10 the following important changes have been incorporated.
   the new features that have recently been committed to our development
   branch.
 
-Statically Linking of Polly
-===========================
-
-The mechanism that Polly uses to link itself statically into the opt, bugpoint and clang executables has been generalized such that it can be used by other pass plugins. An example plugin "Bye" has been added to illustate the mechanism. A consequence of this change is that Polly, like the "Bye" plugin, by default is not linked statically into aforementioned executables anymore.
-
-If Polly is not available, the executable will report an unkown argument `-polly`, such as
-
-.. code-block:: console
-
-    $ clang -mllvm -polly -x c -
-    clang (LLVM option parsing): Unknown command line argument '-polly'.  Try: 'clang (LLVM option parsing) --help'
-    clang (LLVM option parsing): Did you mean '--color'?
-
-.. code-block:: console
-
-    $ opt -polly
-    opt: for the -o option: may not occur within a group!
-    opt: Unknown command line argument '-polly'.  Try: 'opt --help'
-    opt: Did you mean '-o'?
-
-Polly can be made available using the following methods.
-
-- Configure LLVM/Clang with the CMake options LLVM_POLLY_LINK_INTO_TOOLS=ON and LLVM_ENABLE_PROJECTS=polly.
-
-  .. code-block:: console
-
-    $ cmake -DLLVM_POLLY_LINK_INTO_TOOLS=ON -DLLVM_ENABLE_PROJECTS=clang;polly ...
-
-  In future versions, LLVM_POLLY_LINK_INTO_TOOLS=ON will be default again if Polly has been enabled.
-
-- Use the `-load` option to load the Polly module.
-
-  .. code-block:: console
-
-    $ clang -Xclang -load -Xclang path/to/LLVMPolly.so ...
-
-  .. code-block:: console
-
-    $ opt -load path/to/LLVMPolly.so ...
-
-  The LLVMPolly.so module can be found in the `lib/` directory of the build or install-prefix directory.
+- Change ...

commit 593a0dda7a683df9b3744c6391bb2f8de9ed5908
Author: Nikita Popov <nikita.ppv@gmail.com>
Date:   Wed Feb 12 22:25:27 2020 +0100

    [MemorySSA] Don't verify MemorySSA unless VerifyMemorySSA enabled
    
    MemorySSA is often taking up an unreasonable fraction of runtime in
    assertion enabled builds. Turns out that there is one code-path that
    runs verifyMemorySSA() even if VerifyMemorySSA is not enabled. This
    patch makes it conditional as well.
    
    Differential Revision: https://reviews.llvm.org/D74505
    
    (cherry picked from commit f0b57d8071853ec2ab459c0492854c67ea4fa93c)

diff --git a/llvm/lib/Analysis/MemorySSA.cpp b/llvm/lib/Analysis/MemorySSA.cpp
index bf8dc94bfbf..77f4125b5d4 100644
--- a/llvm/lib/Analysis/MemorySSA.cpp
+++ b/llvm/lib/Analysis/MemorySSA.cpp
@@ -2298,7 +2298,10 @@ bool MemorySSAWrapperPass::runOnFunction(Function &F) {
   return false;
 }
 
-void MemorySSAWrapperPass::verifyAnalysis() const { MSSA->verifyMemorySSA(); }
+void MemorySSAWrapperPass::verifyAnalysis() const {
+  if (VerifyMemorySSA)
+    MSSA->verifyMemorySSA();
+}
 
 void MemorySSAWrapperPass::print(raw_ostream &OS, const Module *M) const {
   MSSA->print(OS);

commit 058a8cd73f33ae7be7bef469c1b7c2d5fdaa4b24
Author: Hans Wennborg <hans@chromium.org>
Date:   Thu Feb 27 12:35:10 2020 +0100

    [MC][ARM] Resolve some pcrel fixups at assembly time (PR44929)
    
    MC currently does not emit these relocation types, and lld does not
    handle them. Add FKF_Constant as a work-around of some ARM code after
    D72197. Eventually we probably should implement these relocation types.
    
    By Fangrui Song!
    
    Differential revision: https://reviews.llvm.org/D72892
    
    (cherry picked from commit 2e24219d3cbfcb8c824c58872f97de0a2e94a7c8)

diff --git a/llvm/include/llvm/MC/MCFixupKindInfo.h b/llvm/include/llvm/MC/MCFixupKindInfo.h
index 0d57441ce0d..ecf85fa5693 100644
--- a/llvm/include/llvm/MC/MCFixupKindInfo.h
+++ b/llvm/include/llvm/MC/MCFixupKindInfo.h
@@ -22,7 +22,12 @@ struct MCFixupKindInfo {
     FKF_IsAlignedDownTo32Bits = (1 << 1),
 
     /// Should this fixup be evaluated in a target dependent manner?
-    FKF_IsTarget = (1 << 2)
+    FKF_IsTarget = (1 << 2),
+
+    /// This fixup kind should be resolved if defined.
+    /// FIXME This is a workaround because we don't support certain ARM
+    /// relocation types. This flag should eventually be removed.
+    FKF_Constant = 1 << 3,
   };
 
   /// A target specific name for the fixup kind. The names will be unique for
diff --git a/llvm/lib/MC/MCAssembler.cpp b/llvm/lib/MC/MCAssembler.cpp
index 75ec2797556..6f897edb5d6 100644
--- a/llvm/lib/MC/MCAssembler.cpp
+++ b/llvm/lib/MC/MCAssembler.cpp
@@ -224,6 +224,7 @@ bool MCAssembler::evaluateFixup(const MCAsmLayout &Layout,
     return getBackend().evaluateTargetFixup(*this, Layout, Fixup, DF, Target,
                                             Value, WasForced);
 
+  unsigned FixupFlags = getBackendPtr()->getFixupKindInfo(Fixup.getKind()).Flags;
   bool IsPCRel = getBackendPtr()->getFixupKindInfo(Fixup.getKind()).Flags &
                  MCFixupKindInfo::FKF_IsPCRel;
 
@@ -239,8 +240,9 @@ bool MCAssembler::evaluateFixup(const MCAsmLayout &Layout,
       if (A->getKind() != MCSymbolRefExpr::VK_None || SA.isUndefined()) {
         IsResolved = false;
       } else if (auto *Writer = getWriterPtr()) {
-        IsResolved = Writer->isSymbolRefDifferenceFullyResolvedImpl(
-            *this, SA, *DF, false, true);
+        IsResolved = (FixupFlags & MCFixupKindInfo::FKF_Constant) ||
+                     Writer->isSymbolRefDifferenceFullyResolvedImpl(
+                         *this, SA, *DF, false, true);
       }
     }
   } else {
diff --git a/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp b/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp
index 6196881a9b8..062d1d36c43 100644
--- a/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp
+++ b/llvm/lib/Target/ARM/MCTargetDesc/ARMAsmBackend.cpp
@@ -55,31 +55,29 @@ Optional<MCFixupKind> ARMAsmBackend::getFixupKind(StringRef Name) const {
 }
 
 const MCFixupKindInfo &ARMAsmBackend::getFixupKindInfo(MCFixupKind Kind) const {
+  unsigned IsPCRelConstant =
+      MCFixupKindInfo::FKF_IsPCRel | MCFixupKindInfo::FKF_Constant;
   const static MCFixupKindInfo InfosLE[ARM::NumTargetFixupKinds] = {
       // This table *must* be in the order that the fixup_* kinds are defined in
       // ARMFixupKinds.h.
       //
       // Name                      Offset (bits) Size (bits)     Flags
-      {"fixup_arm_ldst_pcrel_12", 0, 32, MCFixupKindInfo::FKF_IsPCRel},
+      {"fixup_arm_ldst_pcrel_12", 0, 32, IsPCRelConstant},
       {"fixup_t2_ldst_pcrel_12", 0, 32,
-       MCFixupKindInfo::FKF_IsPCRel |
-           MCFixupKindInfo::FKF_IsAlignedDownTo32Bits},
-      {"fixup_arm_pcrel_10_unscaled", 0, 32, MCFixupKindInfo::FKF_IsPCRel},
-      {"fixup_arm_pcrel_10", 0, 32, MCFixupKindInfo::FKF_IsPCRel},
+       IsPCRelConstant | MCFixupKindInfo::FKF_IsAlignedDownTo32Bits},
+      {"fixup_arm_pcrel_10_unscaled", 0, 32, IsPCRelConstant},
+      {"fixup_arm_pcrel_10", 0, 32, IsPCRelConstant},
       {"fixup_t2_pcrel_10", 0, 32,
        MCFixupKindInfo::FKF_IsPCRel |
            MCFixupKindInfo::FKF_IsAlignedDownTo32Bits},
       {"fixup_arm_pcrel_9", 0, 32, MCFixupKindInfo::FKF_IsPCRel},
       {"fixup_t2_pcrel_9", 0, 32,
-       MCFixupKindInfo::FKF_IsPCRel |
-           MCFixupKindInfo::FKF_IsAlignedDownTo32Bits},
+       IsPCRelConstant | MCFixupKindInfo::FKF_IsAlignedDownTo32Bits},
       {"fixup_thumb_adr_pcrel_10", 0, 8,
-       MCFixupKindInfo::FKF_IsPCRel |
-           MCFixupKindInfo::FKF_IsAlignedDownTo32Bits},
-      {"fixup_arm_adr_pcrel_12", 0, 32, MCFixupKindInfo::FKF_IsPCRel},
+       IsPCRelConstant | MCFixupKindInfo::FKF_IsAlignedDownTo32Bits},
+      {"fixup_arm_adr_pcrel_12", 0, 32, IsPCRelConstant},
       {"fixup_t2_adr_pcrel_12", 0, 32,
-       MCFixupKindInfo::FKF_IsPCRel |
-           MCFixupKindInfo::FKF_IsAlignedDownTo32Bits},
+       IsPCRelConstant | MCFixupKindInfo::FKF_IsAlignedDownTo32Bits},
       {"fixup_arm_condbranch", 0, 24, MCFixupKindInfo::FKF_IsPCRel},
       {"fixup_arm_uncondbranch", 0, 24, MCFixupKindInfo::FKF_IsPCRel},
       {"fixup_t2_condbranch", 0, 32, MCFixupKindInfo::FKF_IsPCRel},
diff --git a/llvm/test/MC/ARM/Windows/invalid-relocation.s b/llvm/test/MC/ARM/Windows/invalid-relocation.s
index c3e74e97634..183fc29e701 100644
--- a/llvm/test/MC/ARM/Windows/invalid-relocation.s
+++ b/llvm/test/MC/ARM/Windows/invalid-relocation.s
@@ -7,7 +7,6 @@
 	.endef
 	.global invalid_relocation
 	.thumb_func
-invalid_relocation:
 	adr r0, invalid_relocation+1
 
 # CHECK: LLVM ERROR: unsupported relocation type: fixup_t2_adr_pcrel_12
diff --git a/llvm/test/MC/ARM/pcrel-global.s b/llvm/test/MC/ARM/pcrel-global.s
new file mode 100644
index 00000000000..cec6c1cb52f
--- /dev/null
+++ b/llvm/test/MC/ARM/pcrel-global.s
@@ -0,0 +1,21 @@
+@ RUN: llvm-mc -filetype=obj -triple=armv7 %s -o %t
+@ RUN: llvm-readelf -r %t | FileCheck %s
+
+@ CHECK: There are no relocations in this file.
+.syntax unified
+
+.globl foo
+foo:
+ldrd r0, r1, foo @ arm_pcrel_10_unscaled
+vldr d0, foo     @ arm_pcrel_10
+adr r2, foo      @ arm_adr_pcrel_12
+ldr r0, foo      @ arm_ldst_pcrel_12
+
+.thumb
+.thumb_func
+
+.globl bar
+bar:
+adr r0, bar      @ thumb_adr_pcrel_10
+adr.w r0, bar    @ t2_adr_pcrel_12
+ldr.w pc, bar    @ t2_ldst_pcrel_12
diff --git a/llvm/test/MC/MachO/ARM/bad-darwin-ARM-reloc.s b/llvm/test/MC/MachO/ARM/bad-darwin-ARM-reloc.s
index ae4bc225dc5..c60f8a853b6 100644
--- a/llvm/test/MC/MachO/ARM/bad-darwin-ARM-reloc.s
+++ b/llvm/test/MC/MachO/ARM/bad-darwin-ARM-reloc.s
@@ -6,7 +6,6 @@
 .section myseg, mysect
 L___fcommon: 
     .word 0
-@ CHECK-ERROR: unsupported relocation on symbol
 
 c:
   .word a - b

commit 8f2858eb07085e13544316abfd3c0e90cef3eb93
Author: Nathan James <n.james93@hotmail.co.uk>
Date:   Wed Feb 26 22:06:38 2020 +0000

    [ASTMatchers] HasNameMatcher handles `extern "C"`
    
    Summary: Fixes [[ https://bugs.llvm.org/show_bug.cgi?id=42193 | hasName AST matcher is confused by extern "C" in namespace. ]]
    
    Reviewers: klimek, aaron.ballman, gribozavr2
    
    Reviewed By: aaron.ballman
    
    Subscribers: cfe-commits
    
    Tags: #clang
    
    Differential Revision: https://reviews.llvm.org/D75202
    
    (cherry picked from commit 16cabf278fc8c14d415e677ce0bc40d46a6de30d)

diff --git a/clang/lib/ASTMatchers/ASTMatchersInternal.cpp b/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
index 199a6d839e2..ae127d77584 100644
--- a/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
+++ b/clang/lib/ASTMatchers/ASTMatchersInternal.cpp
@@ -523,7 +523,13 @@ bool HasNameMatcher::matchesNodeFullFast(const NamedDecl &Node) const {
   if (Ctx->isFunctionOrMethod())
     return Patterns.foundMatch(/*AllowFullyQualified=*/false);
 
-  for (; Ctx && isa<NamedDecl>(Ctx); Ctx = Ctx->getParent()) {
+  for (; Ctx; Ctx = Ctx->getParent()) {
+    // Linkage Spec can just be ignored
+    // FIXME: Any other DeclContext kinds that can be safely disregarded
+    if (isa<LinkageSpecDecl>(Ctx))
+      continue;
+    if (!isa<NamedDecl>(Ctx))
+      break;
     if (Patterns.foundMatch(/*AllowFullyQualified=*/false))
       return true;
 
diff --git a/clang/unittests/ASTMatchers/ASTMatchersNarrowingTest.cpp b/clang/unittests/ASTMatchers/ASTMatchersNarrowingTest.cpp
index 92678a30919..bb8aecfe8b8 100644
--- a/clang/unittests/ASTMatchers/ASTMatchersNarrowingTest.cpp
+++ b/clang/unittests/ASTMatchers/ASTMatchersNarrowingTest.cpp
@@ -1520,6 +1520,21 @@ TEST(Matcher, HasNameSupportsFunctionScope) {
   EXPECT_TRUE(matches(code, fieldDecl(hasName("::a::F(int)::S::m"))));
 }
 
+TEST(Matcher, HasNameQualifiedSupportsLinkage) {
+  // https://bugs.llvm.org/show_bug.cgi?id=42193
+  std::string code = R"cpp(namespace foo { extern "C" void test(); })cpp";
+  EXPECT_TRUE(matches(code, functionDecl(hasName("test"))));
+  EXPECT_TRUE(matches(code, functionDecl(hasName("foo::test"))));
+  EXPECT_TRUE(matches(code, functionDecl(hasName("::foo::test"))));
+  EXPECT_TRUE(notMatches(code, functionDecl(hasName("::test"))));
+
+  code = R"cpp(namespace foo { extern "C" { void test(); } })cpp";
+  EXPECT_TRUE(matches(code, functionDecl(hasName("test"))));
+  EXPECT_TRUE(matches(code, functionDecl(hasName("foo::test"))));
+  EXPECT_TRUE(matches(code, functionDecl(hasName("::foo::test"))));
+  EXPECT_TRUE(notMatches(code, functionDecl(hasName("::test"))));
+}
+
 TEST(Matcher, HasAnyName) {
   const std::string Code = "namespace a { namespace b { class C; } }";
 

commit 3b6f4c544be48dcfa663cfb62da3fd4e779954a5
Author: Juneyoung Lee <aqjune@gmail.com>
Date:   Thu Feb 27 14:14:40 2020 +0900

    [ReleaseNotes] Mention freeze instruction
    
    Reviewers: hans, nlopes, regehr
    
    Subscribers: llvm-commits
    
    Tags: #llvm
    
    Differential Revision: https://reviews.llvm.org/D75226

diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index 69a055aeef6..a788f8f6004 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -86,8 +86,8 @@ Non-comprehensive list of changes in this release
 
 
 * Windows Control Flow Guard: the ``-cfguard`` option now emits CFG checks on
-  indirect function calls. The previous behavior is still available with the 
-  ``-cfguard-nochecks`` option. Note that this feature should always be used 
+  indirect function calls. The previous behavior is still available with the
+  ``-cfguard-nochecks`` option. Note that this feature should always be used
   with optimizations enabled.
 
 * ``Callbacks`` have been added to ``CommandLine Options``.  These can
@@ -123,6 +123,10 @@ Changes to the LLVM IR
   that correctly converted 80-90% of Clang tests. Some manual work will almost
   certainly still be needed.
 
+* A new `freeze` instruction is added. The `freeze` instruction is used to stop
+  IR-level propagation of undef and poison values. Currently its support is
+  preliminary; a freeze-equivalent operation for SelDag/MIR needs to be added.
+
 
 Changes to building LLVM
 ------------------------

commit 77e448c0d3a87e7944381d7d53e55c997c8b936a
Author: Roman Lebedev <lebedev.ri@gmail.com>
Date:   Tue Feb 25 16:06:13 2020 +0300

    [NFC][InstCombine] Add shift amount reassociation miscompile example from PR44802
    
    https://bugs.llvm.org/show_bug.cgi?id=44802
    (cherry picked from commit 425ef999385058143bb927aefe81daddcd43f623)

diff --git a/llvm/test/Transforms/InstCombine/shift-amount-reassociation.ll b/llvm/test/Transforms/InstCombine/shift-amount-reassociation.ll
index 6e54133bacc..0b8187d0417 100644
--- a/llvm/test/Transforms/InstCombine/shift-amount-reassociation.ll
+++ b/llvm/test/Transforms/InstCombine/shift-amount-reassociation.ll
@@ -319,3 +319,18 @@ define i32 @n20(i32 %x, i32 %y) {
   %t3 = shl i32 %t1, %t2
   ret i32 %t3
 }
+
+; FIXME: this is a miscompile. We should not transform this.
+; See https://bugs.llvm.org/show_bug.cgi?id=44802
+define i3 @pr44802(i3 %t0) {
+; CHECK-LABEL: @pr44802(
+; CHECK-NEXT:    [[T1:%.*]] = sub i3 0, [[T0:%.*]]
+; CHECK-NEXT:    ret i3 [[T1]]
+;
+  %t1 = sub i3 0, %t0
+  %t2 = icmp ne i3 %t0, 0
+  %t3 = zext i1 %t2 to i3
+  %t4 = lshr i3 %t1, %t3
+  %t5 = lshr i3 %t4, %t3
+  ret i3 %t5
+}

commit f115a88191c3dc80c5140fbbf63f74ca77fcc74b
Author: Roman Lebedev <lebedev.ri@gmail.com>
Date:   Tue Feb 25 16:48:36 2020 +0300

    [InstCombine] reassociateShiftAmtsOfTwoSameDirectionShifts(): fix miscompile (PR44802)
    
    As input, we have the following pattern:
      Sh0 (Sh1 X, Q), K
    We want to rewrite that as:
      Sh x, (Q+K)  iff (Q+K) u< bitwidth(x)
    While we know that originally (Q+K) would not overflow
    (because  2 * (N-1) u<= iN -1), we may have looked past extensions of
    shift amounts. so it may now overflow in smaller bitwidth.
    
    To ensure that does not happen, we need to ensure that the total maximal
    shift amount is still representable in that smaller bitwidth.
    If the overflow would happen, (Q+K) u< bitwidth(x) check would be bogus.
    
    https://bugs.llvm.org/show_bug.cgi?id=44802
    (cherry picked from commit 781d077afb0ed9771c513d064c40170c1ccd21c9)

diff --git a/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp b/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
index fbff5dd4a8c..739579e2d38 100644
--- a/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
@@ -23,8 +23,11 @@ using namespace PatternMatch;
 // Given pattern:
 //   (x shiftopcode Q) shiftopcode K
 // we should rewrite it as
-//   x shiftopcode (Q+K)  iff (Q+K) u< bitwidth(x)
-// This is valid for any shift, but they must be identical.
+//   x shiftopcode (Q+K)  iff (Q+K) u< bitwidth(x) and
+//
+// This is valid for any shift, but they must be identical, and we must be
+// careful in case we have (zext(Q)+zext(K)) and look past extensions,
+// (Q+K) must not overflow or else (Q+K) u< bitwidth(x) is bogus.
 //
 // AnalyzeForSignBitExtraction indicates that we will only analyze whether this
 // pattern has any 2 right-shifts that sum to 1 less than original bit width.
@@ -58,6 +61,23 @@ Value *InstCombiner::reassociateShiftAmtsOfTwoSameDirectionShifts(
   if (ShAmt0->getType() != ShAmt1->getType())
     return nullptr;
 
+  // As input, we have the following pattern:
+  //   Sh0 (Sh1 X, Q), K
+  // We want to rewrite that as:
+  //   Sh x, (Q+K)  iff (Q+K) u< bitwidth(x)
+  // While we know that originally (Q+K) would not overflow
+  // (because  2 * (N-1) u<= iN -1), we have looked past extensions of
+  // shift amounts. so it may now overflow in smaller bitwidth.
+  // To ensure that does not happen, we need to ensure that the total maximal
+  // shift amount is still representable in that smaller bit width.
+  unsigned MaximalPossibleTotalShiftAmount =
+      (Sh0->getType()->getScalarSizeInBits() - 1) +
+      (Sh1->getType()->getScalarSizeInBits() - 1);
+  APInt MaximalRepresentableShiftAmount =
+      APInt::getAllOnesValue(ShAmt0->getType()->getScalarSizeInBits());
+  if (MaximalRepresentableShiftAmount.ult(MaximalPossibleTotalShiftAmount))
+    return nullptr;
+
   // We are only looking for signbit extraction if we have two right shifts.
   bool HadTwoRightShifts = match(Sh0, m_Shr(m_Value(), m_Value())) &&
                            match(Sh1, m_Shr(m_Value(), m_Value()));
diff --git a/llvm/test/Transforms/InstCombine/shift-amount-reassociation.ll b/llvm/test/Transforms/InstCombine/shift-amount-reassociation.ll
index 0b8187d0417..96461691e70 100644
--- a/llvm/test/Transforms/InstCombine/shift-amount-reassociation.ll
+++ b/llvm/test/Transforms/InstCombine/shift-amount-reassociation.ll
@@ -320,12 +320,15 @@ define i32 @n20(i32 %x, i32 %y) {
   ret i32 %t3
 }
 
-; FIXME: this is a miscompile. We should not transform this.
 ; See https://bugs.llvm.org/show_bug.cgi?id=44802
 define i3 @pr44802(i3 %t0) {
 ; CHECK-LABEL: @pr44802(
 ; CHECK-NEXT:    [[T1:%.*]] = sub i3 0, [[T0:%.*]]
-; CHECK-NEXT:    ret i3 [[T1]]
+; CHECK-NEXT:    [[T2:%.*]] = icmp ne i3 [[T0]], 0
+; CHECK-NEXT:    [[T3:%.*]] = zext i1 [[T2]] to i3
+; CHECK-NEXT:    [[T4:%.*]] = lshr i3 [[T1]], [[T3]]
+; CHECK-NEXT:    [[T5:%.*]] = lshr i3 [[T4]], [[T3]]
+; CHECK-NEXT:    ret i3 [[T5]]
 ;
   %t1 = sub i3 0, %t0
   %t2 = icmp ne i3 %t0, 0

commit ac293ede5e62cfc569f2d5d8f4667e6188afced0
Author: Roman Lebedev <lebedev.ri@gmail.com>
Date:   Tue Feb 25 17:14:43 2020 +0300

    [NFC][InstCombine] Add shift amount reassociation in bittest miscompile example from PR44802
    
    https://bugs.llvm.org/show_bug.cgi?id=44802
    (cherry picked from commit 6f807ca00d951d3e74f7ea4fe1daa8e3560f4c0d)

diff --git a/llvm/test/Transforms/InstCombine/shift-amount-reassociation-in-bittest.ll b/llvm/test/Transforms/InstCombine/shift-amount-reassociation-in-bittest.ll
index 27224705929..0386d8042f9 100644
--- a/llvm/test/Transforms/InstCombine/shift-amount-reassociation-in-bittest.ll
+++ b/llvm/test/Transforms/InstCombine/shift-amount-reassociation-in-bittest.ll
@@ -687,3 +687,20 @@ entry:
   %tobool = icmp ne i16 %and, 0
   ret i1 %tobool
 }
+
+; FIXME: this is a miscompile. We should not transform this.
+; See https://bugs.llvm.org/show_bug.cgi?id=44802
+define i1 @pr44802(i3 %a, i3 %x, i3 %y) {
+; CHECK-LABEL: @pr44802(
+; CHECK-NEXT:    [[TMP1:%.*]] = and i3 [[X:%.*]], [[Y:%.*]]
+; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i3 [[TMP1]], 0
+; CHECK-NEXT:    ret i1 [[TMP2]]
+;
+  %t0 = icmp ne i3 %a, 0
+  %t1 = zext i1 %t0 to i3
+  %t2 = lshr i3 %x, %t1
+  %t3 = shl i3 %y, %t1
+  %t4 = and i3 %t2, %t3
+  %t5 = icmp ne i3 %t4, 0
+  ret i1 %t5
+}

commit b2b41bc3b51a083fb9e36e50d0131dfbd79e00ce
Author: Roman Lebedev <lebedev.ri@gmail.com>
Date:   Tue Feb 25 17:24:27 2020 +0300

    [InstCombine] foldShiftIntoShiftInAnotherHandOfAndInICmp(): fix miscompile (PR44802)
    
    Much like with reassociateShiftAmtsOfTwoSameDirectionShifts(),
    as input, we have the following pattern:
      icmp eq/ne (and ((x shift Q), (y oppositeshift K))), 0
    We want to rewrite that as:
      icmp eq/ne (and (x shift (Q+K)), y), 0  iff (Q+K) u< bitwidth(x)
    
    While we know that originally (Q+K) would not overflow
    (because  2 * (N-1) u<= iN -1), we may have looked past extensions of
    shift amounts. so it may now overflow in smaller bitwidth.
    
    To ensure that does not happen, we need to ensure that the total maximal
    shift amount is still representable in that smaller bitwidth.
    If the overflow would happen, (Q+K) u< bitwidth(x) check would be bogus.
    
    https://bugs.llvm.org/show_bug.cgi?id=44802
    (cherry picked from commit 2855c8fed9326ec44526767f1596a4fe4e55dc70)

diff --git a/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp b/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
index f38dc436722..e49e6cec65c 100644
--- a/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
@@ -3494,7 +3494,8 @@ foldShiftIntoShiftInAnotherHandOfAndInICmp(ICmpInst &I, const SimplifyQuery SQ,
   Instruction *NarrowestShift = XShift;
 
   Type *WidestTy = WidestShift->getType();
-  assert(NarrowestShift->getType() == I.getOperand(0)->getType() &&
+  Type *NarrowestTy = NarrowestShift->getType();
+  assert(NarrowestTy == I.getOperand(0)->getType() &&
          "We did not look past any shifts while matching XShift though.");
   bool HadTrunc = WidestTy != I.getOperand(0)->getType();
 
@@ -3533,6 +3534,23 @@ foldShiftIntoShiftInAnotherHandOfAndInICmp(ICmpInst &I, const SimplifyQuery SQ,
   if (XShAmt->getType() != YShAmt->getType())
     return nullptr;
 
+  // As input, we have the following pattern:
+  //   icmp eq/ne (and ((x shift Q), (y oppositeshift K))), 0
+  // We want to rewrite that as:
+  //   icmp eq/ne (and (x shift (Q+K)), y), 0  iff (Q+K) u< bitwidth(x)
+  // While we know that originally (Q+K) would not overflow
+  // (because  2 * (N-1) u<= iN -1), we have looked past extensions of
+  // shift amounts. so it may now overflow in smaller bitwidth.
+  // To ensure that does not happen, we need to ensure that the total maximal
+  // shift amount is still representable in that smaller bit width.
+  unsigned MaximalPossibleTotalShiftAmount =
+      (WidestTy->getScalarSizeInBits() - 1) +
+      (NarrowestTy->getScalarSizeInBits() - 1);
+  APInt MaximalRepresentableShiftAmount =
+      APInt::getAllOnesValue(XShAmt->getType()->getScalarSizeInBits());
+  if (MaximalRepresentableShiftAmount.ult(MaximalPossibleTotalShiftAmount))
+    return nullptr;
+
   // Can we fold (XShAmt+YShAmt) ?
   auto *NewShAmt = dyn_cast_or_null<Constant>(
       SimplifyAddInst(XShAmt, YShAmt, /*isNSW=*/false,
diff --git a/llvm/test/Transforms/InstCombine/shift-amount-reassociation-in-bittest.ll b/llvm/test/Transforms/InstCombine/shift-amount-reassociation-in-bittest.ll
index 0386d8042f9..97506e193e6 100644
--- a/llvm/test/Transforms/InstCombine/shift-amount-reassociation-in-bittest.ll
+++ b/llvm/test/Transforms/InstCombine/shift-amount-reassociation-in-bittest.ll
@@ -688,13 +688,16 @@ entry:
   ret i1 %tobool
 }
 
-; FIXME: this is a miscompile. We should not transform this.
 ; See https://bugs.llvm.org/show_bug.cgi?id=44802
 define i1 @pr44802(i3 %a, i3 %x, i3 %y) {
 ; CHECK-LABEL: @pr44802(
-; CHECK-NEXT:    [[TMP1:%.*]] = and i3 [[X:%.*]], [[Y:%.*]]
-; CHECK-NEXT:    [[TMP2:%.*]] = icmp ne i3 [[TMP1]], 0
-; CHECK-NEXT:    ret i1 [[TMP2]]
+; CHECK-NEXT:    [[T0:%.*]] = icmp ne i3 [[A:%.*]], 0
+; CHECK-NEXT:    [[T1:%.*]] = zext i1 [[T0]] to i3
+; CHECK-NEXT:    [[T2:%.*]] = lshr i3 [[X:%.*]], [[T1]]
+; CHECK-NEXT:    [[T3:%.*]] = shl i3 [[Y:%.*]], [[T1]]
+; CHECK-NEXT:    [[T4:%.*]] = and i3 [[T2]], [[T3]]
+; CHECK-NEXT:    [[T5:%.*]] = icmp ne i3 [[T4]], 0
+; CHECK-NEXT:    ret i1 [[T5]]
 ;
   %t0 = icmp ne i3 %a, 0
   %t1 = zext i1 %t0 to i3

commit 38ee10d08cb5982bfc02dc4eea9a22743dccc6b6
Author: Hans Wennborg <hans@chromium.org>
Date:   Thu Feb 27 13:48:26 2020 +0100

    [driver][darwin] Don't use -platform_version flag by default (PR44813)
    
    The code in llvmorg-10-init-12188-g25ce33a6e4f is a breaking change for
    users of older linkers who don't pass a version parameter, which
    prevents a drop-in clang upgrade. Old tools can't know about what future
    tools will do, so as a general principle the burden should be new tools
    to be compatible by default. Also, for comparison, none of the other
    tests of Version within AddLinkArgs add any new behaviors unless the
    version is explicitly specified. Therefore, this patch changes the
    -platform_version behavior from opt-out to opt-in.
    
    Patch by David Major!
    
    Differential revision: https://reviews.llvm.org/D74784
    
    (cherry picked from commit 5122e828701c88f8d53ee881bc68f3904454d154)

diff --git a/clang/lib/Driver/ToolChains/Darwin.cpp b/clang/lib/Driver/ToolChains/Darwin.cpp
index 344a14fe1ea..220bc8f9835 100644
--- a/clang/lib/Driver/ToolChains/Darwin.cpp
+++ b/clang/lib/Driver/ToolChains/Darwin.cpp
@@ -335,7 +335,7 @@ void darwin::Linker::AddLinkArgs(Compilation &C, const ArgList &Args,
   Args.AddAllArgs(CmdArgs, options::OPT_init);
 
   // Add the deployment target.
-  if (!Version[0] || Version[0] >= 520)
+  if (Version[0] >= 520)
     MachOTC.addPlatformVersionArgs(Args, CmdArgs);
   else
     MachOTC.addMinVersionArgs(Args, CmdArgs);
diff --git a/clang/test/Driver/darwin-ld-platform-version-ios.c b/clang/test/Driver/darwin-ld-platform-version-ios.c
index 2255d3f990d..05698032a32 100644
--- a/clang/test/Driver/darwin-ld-platform-version-ios.c
+++ b/clang/test/Driver/darwin-ld-platform-version-ios.c
@@ -1,9 +1,14 @@
 // RUN: touch %t.o
 
+// RUN: %clang -target arm64-apple-ios12.3 -isysroot %S/Inputs/iPhoneOS13.0.sdk -mlinker-version=0 -### %t.o 2>&1 \
+// RUN:   | FileCheck --check-prefix=LINKER-OLD %s
+// RUN: %clang -target arm64-apple-ios12.3 -isysroot %S/Inputs/iPhoneOS13.0.sdk -mlinker-version=400 -### %t.o 2>&1 \
+// RUN:   | FileCheck --check-prefix=LINKER-OLD %s
 // RUN: %clang -target arm64-apple-ios12.3 -isysroot %S/Inputs/iPhoneOS13.0.sdk -mlinker-version=520 -### %t.o 2>&1 \
-// RUN:   | FileCheck %s
+// RUN:   | FileCheck --check-prefix=LINKER-NEW  %s
 // RUN: %clang -target x86_64-apple-ios13-simulator -isysroot %S/Inputs/iPhoneOS13.0.sdk -mlinker-version=520 -### %t.o 2>&1 \
 // RUN:   | FileCheck --check-prefix=SIMUL %s
 
-// CHECK: "-platform_version" "ios" "12.3.0" "13.0"
+// LINKER-OLD: "-iphoneos_version_min" "12.3.0"
+// LINKER-NEW: "-platform_version" "ios" "12.3.0" "13.0"
 // SIMUL: "-platform_version" "ios-simulator" "13.0.0" "13.0"
diff --git a/clang/test/Driver/darwin-ld-platform-version-macos.c b/clang/test/Driver/darwin-ld-platform-version-macos.c
index 1b849a6d2df..c1b940a3f35 100644
--- a/clang/test/Driver/darwin-ld-platform-version-macos.c
+++ b/clang/test/Driver/darwin-ld-platform-version-macos.c
@@ -1,11 +1,14 @@
 // RUN: touch %t.o
 
 // RUN: %clang -target x86_64-apple-macos10.13 -isysroot %S/Inputs/MacOSX10.14.sdk -mlinker-version=0 -### %t.o 2>&1 \
-// RUN:   | FileCheck %s
+// RUN:   | FileCheck --check-prefix=LINKER-OLD %s
+// RUN: %clang -target x86_64-apple-macos10.13 -isysroot %S/Inputs/MacOSX10.14.sdk -mlinker-version=400 -### %t.o 2>&1 \
+// RUN:   | FileCheck --check-prefix=LINKER-OLD %s
 // RUN: env SDKROOT=%S/Inputs/MacOSX10.14.sdk %clang -target x86_64-apple-macos10.13.0.1 -mlinker-version=520 -### %t.o 2>&1 \
-// RUN:   | FileCheck %s
+// RUN:   | FileCheck --check-prefix=LINKER-NEW %s
 
-// CHECK: "-platform_version" "macos" "10.13.0" "10.14"
+// LINKER-OLD: "-macosx_version_min" "10.13.0"
+// LINKER-NEW: "-platform_version" "macos" "10.13.0" "10.14"
 
 // RUN: %clang -target x86_64-apple-macos10.13  -mlinker-version=520 -### %t.o 2>&1 \
 // RUN:   | FileCheck --check-prefix=NOSDK %s
diff --git a/clang/test/Driver/darwin-ld-platform-version-tvos.c b/clang/test/Driver/darwin-ld-platform-version-tvos.c
index 1ef6a0b6000..39a2020cbb2 100644
--- a/clang/test/Driver/darwin-ld-platform-version-tvos.c
+++ b/clang/test/Driver/darwin-ld-platform-version-tvos.c
@@ -1,9 +1,14 @@
 // RUN: touch %t.o
 
+// RUN: %clang -target arm64-apple-tvos12.3 -isysroot %S/Inputs/iPhoneOS13.0.sdk -mlinker-version=0 -### %t.o 2>&1 \
+// RUN:   | FileCheck --check-prefix=LINKER-OLD %s
+// RUN: %clang -target arm64-apple-tvos12.3 -isysroot %S/Inputs/iPhoneOS13.0.sdk -mlinker-version=400 -### %t.o 2>&1 \
+// RUN:   | FileCheck --check-prefix=LINKER-OLD %s
 // RUN: %clang -target arm64-apple-tvos12.3 -isysroot %S/Inputs/iPhoneOS13.0.sdk -mlinker-version=520 -### %t.o 2>&1 \
-// RUN:   | FileCheck %s
+// RUN:   | FileCheck --check-prefix=LINKER-NEW %s
 // RUN: %clang -target x86_64-apple-tvos13-simulator -isysroot %S/Inputs/iPhoneOS13.0.sdk -mlinker-version=520 -### %t.o 2>&1 \
 // RUN:   | FileCheck --check-prefix=SIMUL %s
 
-// CHECK: "-platform_version" "tvos" "12.3.0" "13.0"
+// LINKER-OLD: "-tvos_version_min" "12.3.0"
+// LINKER-NEW: "-platform_version" "tvos" "12.3.0" "13.0"
 // SIMUL: "-platform_version" "tvos-simulator" "13.0.0" "13.0"
diff --git a/clang/test/Driver/darwin-ld-platform-version-watchos.c b/clang/test/Driver/darwin-ld-platform-version-watchos.c
index 9663fc61381..db565ddbb59 100644
--- a/clang/test/Driver/darwin-ld-platform-version-watchos.c
+++ b/clang/test/Driver/darwin-ld-platform-version-watchos.c
@@ -1,9 +1,14 @@
 // RUN: touch %t.o
 
+// RUN: %clang -target arm64_32-apple-watchos5.2 -isysroot %S/Inputs/WatchOS6.0.sdk -mlinker-version=0 -### %t.o 2>&1 \
+// RUN:   | FileCheck --check-prefix=LINKER-OLD %s
+// RUN: %clang -target arm64_32-apple-watchos5.2 -isysroot %S/Inputs/WatchOS6.0.sdk -mlinker-version=400 -### %t.o 2>&1 \
+// RUN:   | FileCheck --check-prefix=LINKER-OLD %s
 // RUN: %clang -target arm64_32-apple-watchos5.2 -isysroot %S/Inputs/WatchOS6.0.sdk -mlinker-version=520 -### %t.o 2>&1 \
-// RUN:   | FileCheck %s
+// RUN:   | FileCheck --check-prefix=LINKER-NEW %s
 // RUN: %clang -target x86_64-apple-watchos6-simulator -isysroot %S/Inputs/WatchOS6.0.sdk -mlinker-version=520 -### %t.o 2>&1 \
 // RUN:   | FileCheck --check-prefix=SIMUL %s
 
-// CHECK: "-platform_version" "watchos" "5.2.0" "6.0.0"
+// LINKER-OLD: "-watchos_version_min" "5.2.0"
+// LINKER-NEW: "-platform_version" "watchos" "5.2.0" "6.0.0"
 // SIMUL: "-platform_version" "watchos-simulator" "6.0.0" "6.0.0"

commit 7e3ebf34eb03ddc5fefe8d4fb2ed62a195bcee0e
Author: Sam Elliott <selliott@lowrisc.org>
Date:   Thu Feb 27 13:14:14 2020 +0000

    [RISCV] Update RISC-V Release Notes for LLVM
    
    This corrects some typos and clarifies some points.

diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index a788f8f6004..7ca74e37858 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -260,8 +260,8 @@ Changes to the RISC-V Target
 ----------------------------
 
 New Features:
-* The Machine Outliner has been enabled.
-* Shrink-wrapping has been enabled.
+* The Machine Outliner is now supported, but not enabled by default.
+* Shrink-wrapping is now supported.
 * The Machine Scheduler has been enabled and scheduler descriptions for the
   Rocket micro-architecture have been added, covering both 32- and 64-bit Rocket
   cores.
@@ -276,9 +276,12 @@ New Features:
   the assembler for use in legacy code.
 * The stack can now be realigned even when there are variable-sized objects in
   the same frame.
-* fastcc is now supported.
+* fastcc is now supported. This is a more efficient, unstandardised, calling
+  convention for calls to private leaf functions in the same IR module.
 * llvm-objdump now supports `-M no-aliases` and `-M numeric` for altering the
-  dumped assembly. These match the behaviour of GNU objdump.
+  dumped assembly. These match the behaviour of GNU objdump, respectively
+  disabling instruction aliases and printing the numeric register names rather
+  than the ABI register names.
 
 Improvements:
 * Trap and Debugtrap now lower to RISC-V-specific trap instructions.
@@ -289,20 +292,19 @@ Improvements:
 * The assembler now suggests spelling corrections for unknown assembly
   mnemonics.
 * Stack offsets of greater than 32-bits are now accepted on RV64.
-* Some variadic functions can now be tail-call optimised.
-* We now custom-lower 32-bit arithmetic operations on RV64 to reduce
-  sign-extensions.
-
+* Variadic functions can now be tail-call optimised, as long as they do not use
+  stack memory for passing arguments.
+* Code generation has been changed for 32-bit arithmetic operations on RV64 to
+  reduce sign-extensions.
 
 Bug Fixes:
-
 * There was an issue with register preservation after calls in interrupt
   handlers, where some registers were marked as preserved even though they were
   not being preserved by the call. This has been corrected, and now only
   callee-saved registers are live over a function call in an interrupt handler
   (just like calls in regular functions).
 * Atomic instructions now only accept GPRs (plus an offset) in memory operands.
-* Fixed some issues with evalutaion of relocations and fixups.
+* Fixed some issues with evaluation of relocations and fixups.
 * The error messages around missing RISC-V extensions in the assembler have been
   improved.
 * The error messages around unsupported relocations have been improved.
@@ -314,7 +316,10 @@ Bug Fixes:
 * RV64 no longer clears the upper bits when returning complex types from
   libcalls using the LP64 psABI.
 
-
+Compiler-RT:
+* RISC-V (both 64-bit and 32-bit) is now supported by compiler-rt, allowing
+  crtbegin and crtend to be built.
+* The Sanitizers now support 64-bit RISC-V on linux.
 
 Changes to the OCaml bindings
 -----------------------------

commit a8684e93a347b5a7ecbb07bad40301f1699a813a
Author: Hans Wennborg <hans@chromium.org>
Date:   Thu Feb 27 14:33:43 2020 +0100

    Revert "make -fmodules-codegen and -fmodules-debuginfo work also with PCHs"
    
    This caused PR44953. See also the discussion on D74846.
    
    This reverts commit cbc9d22e49b434b6ceb2eb94b67079d02e0a7b74.
    
    (cherry picked from commit 7ea9a6e0220da36ff2fd1fbc29c2755be23e5166)

diff --git a/clang/lib/Serialization/ASTReader.cpp b/clang/lib/Serialization/ASTReader.cpp
index 8e8b04451fb..652b772f37c 100644
--- a/clang/lib/Serialization/ASTReader.cpp
+++ b/clang/lib/Serialization/ASTReader.cpp
@@ -3224,8 +3224,7 @@ ASTReader::ReadASTBlock(ModuleFile &F, unsigned ClientLoadCapabilities) {
     case MODULAR_CODEGEN_DECLS:
       // FIXME: Skip reading this record if our ASTConsumer doesn't care about
       // them (ie: if we're not codegenerating this module).
-      if (F.Kind == MK_MainFile ||
-          getContext().getLangOpts().BuildingPCHWithObjectFile)
+      if (F.Kind == MK_MainFile)
         for (unsigned I = 0, N = Record.size(); I != N; ++I)
           EagerlyDeserializedDecls.push_back(getGlobalDeclID(F, Record[I]));
       break;
diff --git a/clang/lib/Serialization/ASTReaderDecl.cpp b/clang/lib/Serialization/ASTReaderDecl.cpp
index 362b5a564ab..b7000a6956d 100644
--- a/clang/lib/Serialization/ASTReaderDecl.cpp
+++ b/clang/lib/Serialization/ASTReaderDecl.cpp
@@ -502,12 +502,8 @@ uint64_t ASTDeclReader::GetCurrentCursorOffset() {
 }
 
 void ASTDeclReader::ReadFunctionDefinition(FunctionDecl *FD) {
-  if (Record.readInt()) {
+  if (Record.readInt())
     Reader.DefinitionSource[FD] = Loc.F->Kind == ModuleKind::MK_MainFile;
-    if (Reader.getContext().getLangOpts().BuildingPCHWithObjectFile &&
-        Reader.DeclIsFromPCHWithObjectFile(FD))
-      Reader.DefinitionSource[FD] = true;
-  }
   if (auto *CD = dyn_cast<CXXConstructorDecl>(FD)) {
     CD->setNumCtorInitializers(Record.readInt());
     if (CD->getNumCtorInitializers())
@@ -1422,12 +1418,8 @@ ASTDeclReader::RedeclarableResult ASTDeclReader::VisitVarDeclImpl(VarDecl *VD) {
       Reader.getContext().setBlockVarCopyInit(VD, CopyExpr, Record.readInt());
   }
 
-  if (VD->getStorageDuration() == SD_Static && Record.readInt()) {
+  if (VD->getStorageDuration() == SD_Static && Record.readInt())
     Reader.DefinitionSource[VD] = Loc.F->Kind == ModuleKind::MK_MainFile;
-    if (Reader.getContext().getLangOpts().BuildingPCHWithObjectFile &&
-        Reader.DeclIsFromPCHWithObjectFile(VD))
-      Reader.DefinitionSource[VD] = true;
-  }
 
   enum VarKind {
     VarNotTemplate = 0, VarTemplate, StaticDataMemberSpecialization
@@ -1686,12 +1678,8 @@ void ASTDeclReader::ReadCXXDefinitionData(
   Data.ODRHash = Record.readInt();
   Data.HasODRHash = true;
 
-  if (Record.readInt()) {
+  if (Record.readInt())
     Reader.DefinitionSource[D] = Loc.F->Kind == ModuleKind::MK_MainFile;
-    if (Reader.getContext().getLangOpts().BuildingPCHWithObjectFile &&
-        Reader.DeclIsFromPCHWithObjectFile(D))
-      Reader.DefinitionSource[D] = true;
-  }
 
   Data.NumBases = Record.readInt();
   if (Data.NumBases)
diff --git a/clang/lib/Serialization/ASTWriter.cpp b/clang/lib/Serialization/ASTWriter.cpp
index 252853aad1f..7626827b441 100644
--- a/clang/lib/Serialization/ASTWriter.cpp
+++ b/clang/lib/Serialization/ASTWriter.cpp
@@ -5596,8 +5596,8 @@ void ASTRecordWriter::AddCXXDefinitionData(const CXXRecordDecl *D) {
 
   // getODRHash will compute the ODRHash if it has not been previously computed.
   Record->push_back(D->getODRHash());
-  bool ModulesDebugInfo =
-      Writer->Context->getLangOpts().ModulesDebugInfo && !D->isDependentType();
+  bool ModulesDebugInfo = Writer->Context->getLangOpts().ModulesDebugInfo &&
+                          Writer->WritingModule && !D->isDependentType();
   Record->push_back(ModulesDebugInfo);
   if (ModulesDebugInfo)
     Writer->ModularCodegenDecls.push_back(Writer->GetDeclRef(D));
diff --git a/clang/lib/Serialization/ASTWriterDecl.cpp b/clang/lib/Serialization/ASTWriterDecl.cpp
index 472136d99a1..92d566fc785 100644
--- a/clang/lib/Serialization/ASTWriterDecl.cpp
+++ b/clang/lib/Serialization/ASTWriterDecl.cpp
@@ -1011,16 +1011,15 @@ void ASTDeclWriter::VisitVarDecl(VarDecl *D) {
 
   if (D->getStorageDuration() == SD_Static) {
     bool ModulesCodegen = false;
-    if (!D->getDescribedVarTemplate() && !D->getMemberSpecializationInfo() &&
+    if (Writer.WritingModule &&
+        !D->getDescribedVarTemplate() && !D->getMemberSpecializationInfo() &&
         !isa<VarTemplateSpecializationDecl>(D)) {
       // When building a C++ Modules TS module interface unit, a strong
       // definition in the module interface is provided by the compilation of
       // that module interface unit, not by its users. (Inline variables are
       // still emitted in module users.)
       ModulesCodegen =
-          (((Writer.WritingModule &&
-             Writer.WritingModule->Kind == Module::ModuleInterfaceUnit) ||
-            Writer.Context->getLangOpts().BuildingPCHWithObjectFile) &&
+          (Writer.WritingModule->Kind == Module::ModuleInterfaceUnit &&
            Writer.Context->GetGVALinkageForVariable(D) == GVA_StrongExternal);
     }
     Record.push_back(ModulesCodegen);
@@ -2449,11 +2448,9 @@ void ASTRecordWriter::AddFunctionDefinition(const FunctionDecl *FD) {
 
   assert(FD->doesThisDeclarationHaveABody());
   bool ModulesCodegen = false;
-  if (!FD->isDependentContext()) {
+  if (Writer->WritingModule && !FD->isDependentContext()) {
     Optional<GVALinkage> Linkage;
-    if ((Writer->WritingModule &&
-         Writer->WritingModule->Kind == Module::ModuleInterfaceUnit) ||
-        Writer->Context->getLangOpts().BuildingPCHWithObjectFile) {
+    if (Writer->WritingModule->Kind == Module::ModuleInterfaceUnit) {
       // When building a C++ Modules TS module interface unit, a strong
       // definition in the module interface is provided by the compilation of
       // that module interface unit, not by its users. (Inline functions are
diff --git a/clang/test/Modules/Inputs/codegen-flags/foo.h b/clang/test/Modules/Inputs/codegen-flags/foo.h
index 74cfab1771f..7b9c1cd8e08 100644
--- a/clang/test/Modules/Inputs/codegen-flags/foo.h
+++ b/clang/test/Modules/Inputs/codegen-flags/foo.h
@@ -1,7 +1,4 @@
-#ifndef FOO_H
-#define FOO_H
 struct foo {
 };
 inline void f1() {
 }
-#endif
diff --git a/clang/test/PCH/codegen.cpp b/clang/test/PCH/codegen.cpp
deleted file mode 100644
index 120db0e82b9..00000000000
--- a/clang/test/PCH/codegen.cpp
+++ /dev/null
@@ -1,30 +0,0 @@
-// This test is the PCH version of Modules/codegen-flags.test . It uses its inputs.
-// The purpose of this test is just verify that the codegen options work with PCH as well.
-// All the codegen functionality should be tested in Modules/.
-
-// RUN: rm -rf %t
-// RUN: mkdir -p %t
-// REQUIRES: x86-registered-target
-
-// RUN: %clang_cc1 -triple=x86_64-linux-gnu -fmodules-codegen -x c++-header -building-pch-with-obj -emit-pch %S/../Modules/Inputs/codegen-flags/foo.h -o %t/foo-cg.pch
-// RUN: %clang_cc1 -triple=x86_64-linux-gnu -fmodules-debuginfo -x c++-header -building-pch-with-obj -emit-pch %S/../Modules/Inputs/codegen-flags/foo.h -o %t/foo-di.pch
-
-// RUN: %clang_cc1 -triple x86_64-linux-gnu -emit-llvm -debug-info-kind=limited -o - %s -include-pch %t/foo-cg.pch -building-pch-with-obj -fmodules-codegen | FileCheck --check-prefix=CG %s
-// RUN: %clang_cc1 -triple x86_64-linux-gnu -emit-llvm -debug-info-kind=limited -o - %s -include-pch %t/foo-di.pch -building-pch-with-obj -fmodules-debuginfo | FileCheck --check-prefix=DI %s
-
-// RUN: %clang_cc1 -triple x86_64-linux-gnu -emit-llvm -debug-info-kind=limited -o - -include-pch %t/foo-cg.pch %S/../Modules/Inputs/codegen-flags/use.cpp | FileCheck --check-prefix=CG-USE %s
-// RUN: %clang_cc1 -triple x86_64-linux-gnu -emit-llvm -debug-info-kind=limited -o - -include-pch %t/foo-di.pch %S/../Modules/Inputs/codegen-flags/use.cpp | FileCheck --check-prefix=DI-USE %s
-
-// CG: define weak_odr void @_Z2f1v
-// CG: DICompileUnit
-// CG-NOT: DICompositeType
-
-// CG-USE: declare void @_Z2f1v
-// CG-USE: DICompileUnit
-// CG-USE: distinct !DICompositeType(tag: DW_TAG_structure_type, name: "foo"
-
-// DI-NOT: define
-// DI: distinct !DICompositeType(tag: DW_TAG_structure_type, name: "foo"
-
-// DI-USE: define linkonce_odr void @_Z2f1v
-// DI-USE: = !DICompositeType(tag: DW_TAG_structure_type, name: "foo", {{.*}}, flags: DIFlagFwdDecl

commit 6ff25fbe749efca9faf1fc0a9d30e51272ce0653
Author: Peter Wu <peter@lekensteyn.nl>
Date:   Sat Feb 22 20:20:40 2020 +0100

    [ReleaseNotes] Mention -fmacro-prefix-map and -ffile-prefix-map.
    
    Differential revision: https://reviews.llvm.org/D75012

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index c9d0461b65a..d959791d75b 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -151,6 +151,12 @@ New Compiler Flags
   `-mcmodel=small` and `-mcmodel=medium` respectively. Preprocessor definitions
   for `__riscv_cmodel_medlow` and `__riscv_cmodel_medany` have been corrected.
 
+- ``-fmacro-prefix-map=OLD=NEW`` substitutes directory prefix ``OLD`` for
+  ``NEW`` in predefined preprocessor macros such as ``__FILE__``. This helps
+  with reproducible builds that are location independent. The new
+  ``-ffile-prefix-map`` option is equivalent to specifying both
+  ``-fdebug-prefix-map`` and ``-fmacro-prefix-map``.
+
 Deprecated Compiler Flags
 -------------------------
 

commit b65707e4818e3b5694786b90e6ebdaa17910b016
Author: Sven van Haastregt <sven.vanhaastregt@arm.com>
Date:   Thu Feb 27 14:42:46 2020 +0000

    [ReleaseNotes] Fix typos

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index d959791d75b..c3097bcba8d 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -292,7 +292,7 @@ Objective-C Language Changes in Clang
 
   One particular issue you may run into is attempting to use a class
   as a key in a dictionary literal. This will now result in an error,
-  because ``Class`` is not convertable to ``id<NSCopying>``. (Note that
+  because ``Class`` is not convertible to ``id<NSCopying>``. (Note that
   this was already a warning in Objective-C mode.) While an arbitrary
   ``Class`` object is not guaranteed to implement ``NSCopying``, the
   default metaclass implementation does. Therefore, the recommended
@@ -500,7 +500,7 @@ Static Analyzer
 
 - ``deadcode.DeadStores`` now warns about nested dead stores.
 
-- Condition values that are relevant to the occurance of a bug are far better
+- Condition values that are relevant to the occurrence of a bug are far better
   explained in bug reports.
 
 - Despite still being at an alpha stage, checkers implementing taint analyses

commit e5cb70267e70a363eea8c47ac6a154ec15078235
Author: Sven van Haastregt <sven.vanhaastregt@arm.com>
Date:   Thu Feb 27 14:43:04 2020 +0000

    [ReleaseNotes] Add OpenCL release notes
    
    Differential Revision: https://reviews.llvm.org/D75125

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index c3097bcba8d..63d83ac1c1d 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -309,10 +309,33 @@ Objective-C Language Changes in Clang
     // Fix: add an explicit cast to 'id'.
     NSDictionary* d = @{(id)cls : @"Hello"};
 
-OpenCL C Language Changes in Clang
-----------------------------------
+OpenCL Kernel Language Changes in Clang
+---------------------------------------
+
+Generic changes:
+
+- Made ``__private`` to be appear explicitly in diagnostics, AST, etc.
+- Fixed diagnostics of ``enqueue_kernel``.
+
+OpenCL builtin functions:
+
+- The majority of the OpenCL builtin functions are now available through
+  the experimental `TableGen` driven ``-fdeclare-opencl-builtins`` option.
+- Align the ``enqueue_marker`` declaration in standard ``opencl-c.h`` to the
+  OpenCL spec.
+- Avoid a void pointer cast in the ``CLK_NULL_EVENT`` definition.
+- Aligned OpenCL with c11 atomic fetch max/min.
+
+Changes in C++ for OpenCL:
+
+- Fixed language mode predefined macros for C++ mode.
+- Allow OpenCL C style compound vector initialization.
+- Improved destructor support.
+- Implemented address space deduction for pointers/references
+  to arrays and auto variables.
+- Added address spaces support for lambdas and ``constexpr``.
+- Fixed misc address spaces usages in classes.
 
-...
 
 ABI Changes in Clang
 --------------------

commit 7af6fea2ddcbc6bc71e8ecb22f6bfb06121f2eee
Author: Fangrui Song <maskray@google.com>
Date:   Thu Feb 27 10:54:27 2020 -0800

    [ReleaseNotes] Add some items for clang

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index 63d83ac1c1d..b5415a03354 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -79,6 +79,7 @@ Improvements to Clang's diagnostics
   warning of the same name. It warns about statements that are indented as if
   they were part of a if/else/for/while statement but are not semantically
   part of that if/else/for/while.
+- -Wbitwise-op-parentheses and -Wlogical-op-parentheses are disabled by default.
 
 Non-comprehensive list of changes in this release
 -------------------------------------------------
@@ -157,6 +158,13 @@ New Compiler Flags
   ``-ffile-prefix-map`` option is equivalent to specifying both
   ``-fdebug-prefix-map`` and ``-fmacro-prefix-map``.
 
+- ``-fpatchable-function-entry=N[,M]`` is added to generate M NOPs before the
+  function entry and N-M NOPs after the function entry. This is used by AArch64
+  ftrace in the Linux kernel.
+
+- ``-mbranches-within-32B-boundaries`` is added as an x86 assembler mitigation
+  for Intel's Jump Condition Code Erratum.
+
 Deprecated Compiler Flags
 -------------------------
 

commit e705da06e22b12ee5d75076a2a1ae7b479a566e1
Author: Fangrui Song <maskray@google.com>
Date:   Wed Feb 26 14:17:23 2020 -0800

    [lld][ELF] Add some release notes
    
    Reviewed By: hans
    
    Differential Revision: https://reviews.llvm.org/D75216

diff --git a/lld/docs/ReleaseNotes.rst b/lld/docs/ReleaseNotes.rst
index 5be348bb189..7d8599cf173 100644
--- a/lld/docs/ReleaseNotes.rst
+++ b/lld/docs/ReleaseNotes.rst
@@ -35,8 +35,60 @@ ELF Improvements
 
 * Relax MIPS ``jalr``and ``jr`` instructions marked by the ``R_MIPS_JALR``
   relocation.
+* For certain "undefined symbol" errors, a definition with a close spelling will be suggested.
+  (`D67039 <https://reviews.llvm.org/D67039>`_)
+* ``extern "C"`` is suggested if an undefined reference is mangled(unmangled) while there
+  is a likely unmangled(mangled) definition.
+  (`D69592 <https://reviews.llvm.org/D69592>`_ `D69650 <https://reviews.llvm.org/D69650>`_)
+* New ``-z noseparate-code``, ``-z separate-code`` and ``-z separate-loadable-segments``.
+  ``-z noseparate-code`` is the default, which can reduce sizes of linked binaries by up to
+  3 times maxpagesize.
+  (`D64903 <https://reviews.llvm.org/D64903>`_ `D67481 <https://reviews.llvm.org/D67481>`_)
+* ``-z force-bti`` and ``-z pac-plt`` are added for AArch64 Branch Target Identification and Pointer Authentication.
+  (`D62609 <https://reviews.llvm.org/D62609>`_)
+* ``--fix-cortex-a8`` is added to fix erratum 657417.
+  (`D67284 <https://reviews.llvm.org/D67284>`_)
+* ``-z force-ibt`` and ``-z shstk`` are added for Intel Control-flow Enforcement Technology.
+  (`D59780 <https://reviews.llvm.org/D59780>`_)
+* ``PT_GNU_PROPERTY`` is added to help loaders locate the ``.note.gnu.property`` section.
+  It may be used by a future Linux kernel.
+  (`D70961 <https://reviews.llvm.org/D70961>`_)
+* For ``--compress-debug-sections=zlib``, ``-O0`` and ``-O1`` enable compression level 1
+  while ``-O2`` enables compression level 6. ``-O1`` (default) is faster than before.
+  (`D70658 <https://reviews.llvm.org/D70658>`_)
+* Range extension thunks with addends are implemented for AArch64, PowerPC32 and PowerPC64.
+  (`D70637 <https://reviews.llvm.org/D70637>`_ `D70937 <https://reviews.llvm.org/D70937>`_
+  `D73424 <https://reviews.llvm.org/D73424>`_)
+* ``R_RISCV_ALIGN`` will be errored because linker relaxation for RISC-V is not supported.
+  Pass ``-mno-relax`` to disable ``R_RISCV_ALIGN``.
+  (`D71820 <https://reviews.llvm.org/D71820>`_)
+* The ARM port will no longer insert interworking thunks for non STT_FUNC symbols.
+  (`D73474 <https://reviews.llvm.org/D73474>`_)
+* The quality of PowerPC32 port has been greatly improved (canonical PLT, copy
+  relocations, non-preemptible IFUNC, range extension thunks with addends).
+  It can link FreeBSD 13.0 userland.
+* The PowerPC64 port supports non-preemptible IFUNC.
+  (`D71509 <https://reviews.llvm.org/D71509>`_)
+* lld creates a RO PT_LOAD and a RX PT_LOAD without a linker script.
+  lld creates a unified RX PT_LOAD with a linker script.
+  A future release will eliminate this difference and use a RO PT_LOAD and a RX PT_LOAD by default.
+  The linker script case will require ``--no-rosegment`` to restore the current behavior.
+* GNU style compressed debug sections ``.zdebug`` (obsoleted by ``SHF_COMPRESSED``)
+  are supported for input files, but not for the output.
+  A future release may drop ``.zdebug`` support.
+
+Breaking changes
+----------------
 
-* Reduced size of linked MIPS binaries.
+* ``-Ttext=$base`` (base is usually 0) is no longer supported.
+  If PT_PHDR is needed, use ``--image-base=$base`` instead.
+  If PT_PHDR is not needed, use a linker script with `.text 0 : { *(.text*) }` as the first
+  output section description.
+  See https://bugs.llvm.org/show_bug.cgi?id=44715 for more information.
+  (`D67325 <https://reviews.llvm.org/D67325>`_)
+* ``-Ttext-segment`` is no longer supported. Its meaning was different from GNU ld's and
+  could cause subtle bugs.
+  (`D70468 <https://reviews.llvm.org/D70468>`_)
 
 COFF Improvements
 -----------------

commit daae05af2a5d1170de6940569128dcf071db32ef
Author: Hans Wennborg <hans@chromium.org>
Date:   Fri Feb 28 09:59:24 2020 +0100

    llvm-ar: Fix MinGW compilation
    
    llvm-ar is using CompareStringOrdinal which is available
    only starting with Windows Vista (WINVER 0x600).
    
    Fix this by hoising WindowsSupport.h, which sets _WIN32_WINNT
    to 0x0601, up to llvm/include/llvm/Support and use it in llvm-ar.
    
    Patch by Cristian Adam!
    
    Differential revision: https://reviews.llvm.org/D74599
    
    (cherry picked from commit 01f9abbb50b11dd26b9ccb7cb565cc955d2b9c74)
    
    This is for https://bugs.llvm.org/show_bug.cgi?id=44907

diff --git a/llvm/lib/Support/Windows/WindowsSupport.h b/llvm/include/llvm/Support/Windows/WindowsSupport.h
similarity index 100%
rename from llvm/lib/Support/Windows/WindowsSupport.h
rename to llvm/include/llvm/Support/Windows/WindowsSupport.h
diff --git a/llvm/lib/Support/CrashRecoveryContext.cpp b/llvm/lib/Support/CrashRecoveryContext.cpp
index 35683560983..ec7d7d641dc 100644
--- a/llvm/lib/Support/CrashRecoveryContext.cpp
+++ b/llvm/lib/Support/CrashRecoveryContext.cpp
@@ -254,7 +254,7 @@ bool CrashRecoveryContext::RunSafely(function_ref<void()> Fn) {
 // XP, so if support for older versions of Windows is required,
 // it will have to be added.
 
-#include "Windows/WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 
 static LONG CALLBACK ExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo)
 {
diff --git a/llvm/lib/Support/InitLLVM.cpp b/llvm/lib/Support/InitLLVM.cpp
index bb9b569d2de..5c56b773ea6 100644
--- a/llvm/lib/Support/InitLLVM.cpp
+++ b/llvm/lib/Support/InitLLVM.cpp
@@ -15,7 +15,7 @@
 #include <string>
 
 #ifdef _WIN32
-#include "Windows/WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 #endif
 
 using namespace llvm;
diff --git a/llvm/lib/Support/RandomNumberGenerator.cpp b/llvm/lib/Support/RandomNumberGenerator.cpp
index 09fad197998..f9c41ee5eaa 100644
--- a/llvm/lib/Support/RandomNumberGenerator.cpp
+++ b/llvm/lib/Support/RandomNumberGenerator.cpp
@@ -17,7 +17,7 @@
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/raw_ostream.h"
 #ifdef _WIN32
-#include "Windows/WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 #else
 #include "Unix/Unix.h"
 #endif
diff --git a/llvm/lib/Support/Windows/DynamicLibrary.inc b/llvm/lib/Support/Windows/DynamicLibrary.inc
index 71b206c4cf9..a3f78fb0d6b 100644
--- a/llvm/lib/Support/Windows/DynamicLibrary.inc
+++ b/llvm/lib/Support/Windows/DynamicLibrary.inc
@@ -10,7 +10,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 #include "llvm/Support/ConvertUTF.h"
 #include "llvm/Support/raw_ostream.h"
 
diff --git a/llvm/lib/Support/Windows/Host.inc b/llvm/lib/Support/Windows/Host.inc
index 21b947f26df..5583db90904 100644
--- a/llvm/lib/Support/Windows/Host.inc
+++ b/llvm/lib/Support/Windows/Host.inc
@@ -10,7 +10,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 #include <cstdio>
 #include <string>
 
diff --git a/llvm/lib/Support/Windows/Memory.inc b/llvm/lib/Support/Windows/Memory.inc
index c5566f9910a..1b2de1915ec 100644
--- a/llvm/lib/Support/Windows/Memory.inc
+++ b/llvm/lib/Support/Windows/Memory.inc
@@ -17,7 +17,7 @@
 #include "llvm/Support/WindowsError.h"
 
 // The Windows.h header must be the last one included.
-#include "WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 
 static DWORD getWindowsProtectionFlags(unsigned Flags) {
   switch (Flags & llvm::sys::Memory::MF_RWE_MASK) {
diff --git a/llvm/lib/Support/Windows/Path.inc b/llvm/lib/Support/Windows/Path.inc
index c3b13abef5d..d634c123fbd 100644
--- a/llvm/lib/Support/Windows/Path.inc
+++ b/llvm/lib/Support/Windows/Path.inc
@@ -25,7 +25,7 @@
 
 // These two headers must be included last, and make sure shlobj is required
 // after Windows.h to make sure it picks up our definition of _WIN32_WINNT
-#include "WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 #include <shellapi.h>
 #include <shlobj.h>
 
diff --git a/llvm/lib/Support/Windows/Process.inc b/llvm/lib/Support/Windows/Process.inc
index 3526e3dee6f..518ecdb9889 100644
--- a/llvm/lib/Support/Windows/Process.inc
+++ b/llvm/lib/Support/Windows/Process.inc
@@ -19,7 +19,7 @@
 #include <malloc.h>
 
 // The Windows.h header must be after LLVM and standard headers.
-#include "WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 
 #include <direct.h>
 #include <io.h>
diff --git a/llvm/lib/Support/Windows/Program.inc b/llvm/lib/Support/Windows/Program.inc
index a1482bf17c6..c4285d5d656 100644
--- a/llvm/lib/Support/Windows/Program.inc
+++ b/llvm/lib/Support/Windows/Program.inc
@@ -10,7 +10,7 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 #include "llvm/ADT/StringExtras.h"
 #include "llvm/Support/ConvertUTF.h"
 #include "llvm/Support/Errc.h"
diff --git a/llvm/lib/Support/Windows/Signals.inc b/llvm/lib/Support/Windows/Signals.inc
index 09e19ae41f1..c7301742119 100644
--- a/llvm/lib/Support/Windows/Signals.inc
+++ b/llvm/lib/Support/Windows/Signals.inc
@@ -23,7 +23,7 @@
 #include "llvm/Support/raw_ostream.h"
 
 // The Windows.h header must be after LLVM and standard headers.
-#include "WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 
 #ifdef __MINGW32__
  #include <imagehlp.h>
diff --git a/llvm/lib/Support/Windows/ThreadLocal.inc b/llvm/lib/Support/Windows/ThreadLocal.inc
index 1e0ed955e9a..696e5c843ea 100644
--- a/llvm/lib/Support/Windows/ThreadLocal.inc
+++ b/llvm/lib/Support/Windows/ThreadLocal.inc
@@ -15,7 +15,7 @@
 //===          is guaranteed to work on *all* Win32 variants.
 //===----------------------------------------------------------------------===//
 
-#include "WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 #include "llvm/Support/ThreadLocal.h"
 
 namespace llvm {
diff --git a/llvm/lib/Support/Windows/Threading.inc b/llvm/lib/Support/Windows/Threading.inc
index 9456efa686f..efa4bc6cf73 100644
--- a/llvm/lib/Support/Windows/Threading.inc
+++ b/llvm/lib/Support/Windows/Threading.inc
@@ -13,7 +13,7 @@
 #include "llvm/ADT/SmallString.h"
 #include "llvm/ADT/Twine.h"
 
-#include "WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 #include <process.h>
 
 // Windows will at times define MemoryFence.
diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
index 4bb315f824a..13b0203ac95 100644
--- a/llvm/lib/Support/raw_ostream.cpp
+++ b/llvm/lib/Support/raw_ostream.cpp
@@ -60,7 +60,7 @@
 
 #ifdef _WIN32
 #include "llvm/Support/ConvertUTF.h"
-#include "Windows/WindowsSupport.h"
+#include "llvm/Support/Windows/WindowsSupport.h"
 #endif
 
 using namespace llvm;
diff --git a/llvm/tools/llvm-ar/llvm-ar.cpp b/llvm/tools/llvm-ar/llvm-ar.cpp
index c339dfe1f33..516cc2626b5 100644
--- a/llvm/tools/llvm-ar/llvm-ar.cpp
+++ b/llvm/tools/llvm-ar/llvm-ar.cpp
@@ -45,8 +45,7 @@
 #endif
 
 #ifdef _WIN32
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
+#include "llvm/Support/Windows/WindowsSupport.h"
 #endif
 
 using namespace llvm;

commit 7cb6829291280a2adcc260346a7a56b8bddd43db
Author: Hans Wennborg <hans@chromium.org>
Date:   Thu Feb 27 17:01:09 2020 +0100

    SROA: Don't drop atomic load/store alignments (PR45010)
    
    SROA will drop the explicit alignment on allocas when the ABI guarantees
    enough alignment. Because the alignment on new load/store instructions
    are set based on the alloca's alignment, that means SROA would end up
    dropping the alignment from atomic loads and stores, which is not
    allowed (see bug). For those, make sure to always carry over the
    alignment from the previous instruction.
    
    Differential revision: https://reviews.llvm.org/D75266
    
    (cherry picked from commit d48c981697a49653efff9dd14fa692d99e6fa868)

diff --git a/llvm/lib/Transforms/Scalar/SROA.cpp b/llvm/lib/Transforms/Scalar/SROA.cpp
index 89916e43fce..1bdd806f15a 100644
--- a/llvm/lib/Transforms/Scalar/SROA.cpp
+++ b/llvm/lib/Transforms/Scalar/SROA.cpp
@@ -2519,6 +2519,8 @@ private:
         NewLI->setAAMetadata(AATags);
       if (LI.isVolatile())
         NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());
+      if (NewLI->isAtomic())
+        NewLI->setAlignment(LI.getAlign());
 
       // Any !nonnull metadata or !range metadata on the old load is also valid
       // on the new load. This is even true in some cases even when the loads
@@ -2709,6 +2711,8 @@ private:
       NewSI->setAAMetadata(AATags);
     if (SI.isVolatile())
       NewSI->setAtomic(SI.getOrdering(), SI.getSyncScopeID());
+    if (NewSI->isAtomic())
+      NewSI->setAlignment(SI.getAlign());
     Pass.DeadInsts.insert(&SI);
     deleteIfTriviallyDead(OldOp);
 
diff --git a/llvm/test/Transforms/SROA/alignment.ll b/llvm/test/Transforms/SROA/alignment.ll
index 81f8f2a00ba..674f45fb166 100644
--- a/llvm/test/Transforms/SROA/alignment.ll
+++ b/llvm/test/Transforms/SROA/alignment.ll
@@ -228,4 +228,19 @@ define void @test10() {
   ret void
 }
 
+%struct = type { i32, i32 }
+define dso_local i32 @pr45010(%struct* %A) {
+; CHECK-LABEL: @pr45010
+; CHECK: load atomic volatile i32, {{.*}}, align 4
+
+  %B = alloca %struct, align 4
+  %A.i = getelementptr inbounds %struct, %struct* %A, i32 0, i32 0
+  %B.i = getelementptr inbounds %struct, %struct* %B, i32 0, i32 0
+  %1 = load i32, i32* %A.i, align 4
+  store atomic volatile i32 %1, i32* %B.i release, align 4
+  %2 = bitcast %struct* %B to i32*
+  %x = load atomic volatile i32, i32* %2 acquire, align 4
+  ret i32 %x
+}
+
 declare void @populate(i8*)

commit cd0926d087a85c5ee1222ca80980b4440214a822
Author: serge-sans-paille <sguelton@redhat.com>
Date:   Fri Feb 21 15:51:19 2020 +0100

    No longer generate calls to *_finite
    
    According to Joseph Myers, a libm maintainer
    
    > They were only ever an ABI (selected by use of -ffinite-math-only or
    > options implying it, which resulted in the headers using "asm" to redirect
    > calls to some libm functions), not an API. The change means that ABI has
    > turned into compat symbols (only available for existing binaries, not for
    > anything newly linked, not included in static libm at all, not included in
    > shared libm for future glibc ports such as RV32), so, yes, in any case
    > where tools generate direct calls to those functions (rather than just
    > following the "asm" annotations on function declarations in the headers),
    > they need to stop doing so.
    
    As a consequence, we should no longer assume these symbols are available on the
    target system.
    
    Still keep the TargetLibraryInfo for constant folding.
    
    Differential Revision: https://reviews.llvm.org/D74712
    
    (cherry picked from commit 6d15c4deab51498b70825fb6cefbbfe8f3d9bdcf)
    
    For https://bugs.llvm.org/show_bug.cgi?id=45034

diff --git a/llvm/lib/Analysis/TargetLibraryInfo.cpp b/llvm/lib/Analysis/TargetLibraryInfo.cpp
index c7238db43aa..1a32adf4723 100644
--- a/llvm/lib/Analysis/TargetLibraryInfo.cpp
+++ b/llvm/lib/Analysis/TargetLibraryInfo.cpp
@@ -470,6 +470,9 @@ static void initialize(TargetLibraryInfoImpl &TLI, const Triple &T,
     TLI.setUnavailable(LibFunc_tmpfile64);
 
     // Relaxed math functions are included in math-finite.h on Linux (GLIBC).
+    // Note that math-finite.h is no longer supported by top-of-tree GLIBC,
+    // so we keep these functions around just so that they're recognized by
+    // the ConstantFolder.
     TLI.setUnavailable(LibFunc_acos_finite);
     TLI.setUnavailable(LibFunc_acosf_finite);
     TLI.setUnavailable(LibFunc_acosl_finite);
diff --git a/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp b/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp
index 80ac8b95e4e..91404ee7728 100644
--- a/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp
+++ b/llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp
@@ -3867,7 +3867,6 @@ void SelectionDAGLegalize::ConvertNodeToLibcall(SDNode *Node) {
   SmallVector<SDValue, 8> Results;
   SDLoc dl(Node);
   // FIXME: Check flags on the node to see if we can use a finite call.
-  bool CanUseFiniteLibCall = TM.Options.NoInfsFPMath && TM.Options.NoNaNsFPMath;
   unsigned Opc = Node->getOpcode();
   switch (Opc) {
   case ISD::ATOMIC_FENCE: {
@@ -3976,68 +3975,28 @@ void SelectionDAGLegalize::ConvertNodeToLibcall(SDNode *Node) {
     break;
   case ISD::FLOG:
   case ISD::STRICT_FLOG:
-    if (CanUseFiniteLibCall && DAG.getLibInfo().has(LibFunc_log_finite))
-      ExpandFPLibCall(Node, RTLIB::LOG_FINITE_F32,
-                      RTLIB::LOG_FINITE_F64,
-                      RTLIB::LOG_FINITE_F80,
-                      RTLIB::LOG_FINITE_F128,
-                      RTLIB::LOG_FINITE_PPCF128, Results);
-    else
-      ExpandFPLibCall(Node, RTLIB::LOG_F32, RTLIB::LOG_F64,
-                      RTLIB::LOG_F80, RTLIB::LOG_F128,
-                      RTLIB::LOG_PPCF128, Results);
+    ExpandFPLibCall(Node, RTLIB::LOG_F32, RTLIB::LOG_F64, RTLIB::LOG_F80,
+                    RTLIB::LOG_F128, RTLIB::LOG_PPCF128, Results);
     break;
   case ISD::FLOG2:
   case ISD::STRICT_FLOG2:
-    if (CanUseFiniteLibCall && DAG.getLibInfo().has(LibFunc_log2_finite))
-      ExpandFPLibCall(Node, RTLIB::LOG2_FINITE_F32,
-                      RTLIB::LOG2_FINITE_F64,
-                      RTLIB::LOG2_FINITE_F80,
-                      RTLIB::LOG2_FINITE_F128,
-                      RTLIB::LOG2_FINITE_PPCF128, Results);
-    else
-      ExpandFPLibCall(Node, RTLIB::LOG2_F32, RTLIB::LOG2_F64,
-                      RTLIB::LOG2_F80, RTLIB::LOG2_F128,
-                      RTLIB::LOG2_PPCF128, Results);
+    ExpandFPLibCall(Node, RTLIB::LOG2_F32, RTLIB::LOG2_F64, RTLIB::LOG2_F80,
+                    RTLIB::LOG2_F128, RTLIB::LOG2_PPCF128, Results);
     break;
   case ISD::FLOG10:
   case ISD::STRICT_FLOG10:
-    if (CanUseFiniteLibCall && DAG.getLibInfo().has(LibFunc_log10_finite))
-      ExpandFPLibCall(Node, RTLIB::LOG10_FINITE_F32,
-                      RTLIB::LOG10_FINITE_F64,
-                      RTLIB::LOG10_FINITE_F80,
-                      RTLIB::LOG10_FINITE_F128,
-                      RTLIB::LOG10_FINITE_PPCF128, Results);
-    else
-      ExpandFPLibCall(Node, RTLIB::LOG10_F32, RTLIB::LOG10_F64,
-                      RTLIB::LOG10_F80, RTLIB::LOG10_F128,
-                      RTLIB::LOG10_PPCF128, Results);
+    ExpandFPLibCall(Node, RTLIB::LOG10_F32, RTLIB::LOG10_F64, RTLIB::LOG10_F80,
+                    RTLIB::LOG10_F128, RTLIB::LOG10_PPCF128, Results);
     break;
   case ISD::FEXP:
   case ISD::STRICT_FEXP:
-    if (CanUseFiniteLibCall && DAG.getLibInfo().has(LibFunc_exp_finite))
-      ExpandFPLibCall(Node, RTLIB::EXP_FINITE_F32,
-                      RTLIB::EXP_FINITE_F64,
-                      RTLIB::EXP_FINITE_F80,
-                      RTLIB::EXP_FINITE_F128,
-                      RTLIB::EXP_FINITE_PPCF128, Results);
-    else
-      ExpandFPLibCall(Node, RTLIB::EXP_F32, RTLIB::EXP_F64,
-                      RTLIB::EXP_F80, RTLIB::EXP_F128,
-                      RTLIB::EXP_PPCF128, Results);
+    ExpandFPLibCall(Node, RTLIB::EXP_F32, RTLIB::EXP_F64, RTLIB::EXP_F80,
+                    RTLIB::EXP_F128, RTLIB::EXP_PPCF128, Results);
     break;
   case ISD::FEXP2:
   case ISD::STRICT_FEXP2:
-    if (CanUseFiniteLibCall && DAG.getLibInfo().has(LibFunc_exp2_finite))
-      ExpandFPLibCall(Node, RTLIB::EXP2_FINITE_F32,
-                      RTLIB::EXP2_FINITE_F64,
-                      RTLIB::EXP2_FINITE_F80,
-                      RTLIB::EXP2_FINITE_F128,
-                      RTLIB::EXP2_FINITE_PPCF128, Results);
-    else
-      ExpandFPLibCall(Node, RTLIB::EXP2_F32, RTLIB::EXP2_F64,
-                      RTLIB::EXP2_F80, RTLIB::EXP2_F128,
-                      RTLIB::EXP2_PPCF128, Results);
+    ExpandFPLibCall(Node, RTLIB::EXP2_F32, RTLIB::EXP2_F64, RTLIB::EXP2_F80,
+                    RTLIB::EXP2_F128, RTLIB::EXP2_PPCF128, Results);
     break;
   case ISD::FTRUNC:
   case ISD::STRICT_FTRUNC:
@@ -4107,16 +4066,8 @@ void SelectionDAGLegalize::ConvertNodeToLibcall(SDNode *Node) {
   }
   case ISD::FPOW:
   case ISD::STRICT_FPOW:
-    if (CanUseFiniteLibCall && DAG.getLibInfo().has(LibFunc_pow_finite))
-      ExpandFPLibCall(Node, RTLIB::POW_FINITE_F32,
-                      RTLIB::POW_FINITE_F64,
-                      RTLIB::POW_FINITE_F80,
-                      RTLIB::POW_FINITE_F128,
-                      RTLIB::POW_FINITE_PPCF128, Results);
-    else
-      ExpandFPLibCall(Node, RTLIB::POW_F32, RTLIB::POW_F64,
-                      RTLIB::POW_F80, RTLIB::POW_F128,
-                      RTLIB::POW_PPCF128, Results);
+    ExpandFPLibCall(Node, RTLIB::POW_F32, RTLIB::POW_F64, RTLIB::POW_F80,
+                    RTLIB::POW_F128, RTLIB::POW_PPCF128, Results);
     break;
   case ISD::LROUND:
   case ISD::STRICT_LROUND:
diff --git a/llvm/test/CodeGen/AArch64/illegal-float-ops.ll b/llvm/test/CodeGen/AArch64/illegal-float-ops.ll
index ffa813e09c7..5f24cd4bf63 100644
--- a/llvm/test/CodeGen/AArch64/illegal-float-ops.ll
+++ b/llvm/test/CodeGen/AArch64/illegal-float-ops.ll
@@ -1,5 +1,5 @@
 ; RUN: llc -mtriple=aarch64-none-linux-gnu -verify-machineinstrs -o - %s | FileCheck %s
-; RUN: llc -mtriple=aarch64-linux-android -verify-machineinstrs -o - %s | FileCheck --check-prefix=ANDROID-AARCH64 %s
+; RUN: llc -mtriple=aarch64-linux-android -verify-machineinstrs -o - %s | FileCheck %s
 
 @varfloat = global float 0.0
 @vardouble = global double 0.0
@@ -299,7 +299,7 @@ define void @test_exp_finite(double %double) #0 {
   %expdouble = call double @llvm.exp.f64(double %double)
   store double %expdouble, double* @vardouble
   ; ANDROID-AARCH64-NOT: bl __exp_finite
-  ; CHECK: bl __exp_finite
+  ; CHECK: bl exp
 
   ret void
 }
@@ -307,8 +307,8 @@ define void @test_exp_finite(double %double) #0 {
 define void @test_exp2_finite(double %double) #0 {
   %expdouble = call double @llvm.exp2.f64(double %double)
   store double %expdouble, double* @vardouble
-  ; ANDROID-AARCH64-NOT: bl __exp2_finite
-  ; CHECK: bl __exp2_finite
+  ; CHECK-NOT: bl __exp2_finite
+  ; CHECK: bl exp2
 
   ret void
 }
@@ -316,32 +316,32 @@ define void @test_exp2_finite(double %double) #0 {
 define void @test_log_finite(double %double) #0 {
   %logdouble = call double @llvm.log.f64(double %double)
   store double %logdouble, double* @vardouble
-  ; ANDROID-AARCH64-NOT: bl __log_finite
-  ; CHECK: bl __log_finite
+  ; CHECK-NOT: bl __log_finite
+  ; CHECK: bl log
   ret void
 }
 
 define void @test_log2_finite(double %double) #0 {
   %log2double = call double @llvm.log2.f64(double %double)
   store double %log2double, double* @vardouble
-  ; ANDROID-AARCH64-NOT: bl __log2_finite
-  ; CHECK: bl __log2_finite
+  ; CHECK-NOT: bl __log2_finite
+  ; CHECK: bl log2
   ret void
 }
 
 define void @test_log10_finite(double %double) #0 {
   %log10double = call double @llvm.log10.f64(double %double)
   store double %log10double, double* @vardouble
-  ; ANDROID-AARCH64-NOT: bl __log10_finite
-  ; CHECK: bl __log10_finite
+  ; CHECK-NOT: bl __log10_finite
+  ; CHECK: bl log10
   ret void
 }
 
 define void @test_pow_finite(double %double) #0 {
   %powdouble = call double @llvm.pow.f64(double %double, double %double)
   store double %powdouble, double* @vardouble
-  ; ANDROID-AARCH64-NOT: bl __pow_finite
-  ; CHECK: bl __pow_finite
+  ; CHECK-NOT: bl __pow_finite
+  ; CHECK: bl pow
   ret void
 }
 
diff --git a/llvm/test/CodeGen/X86/finite-libcalls.ll b/llvm/test/CodeGen/X86/finite-libcalls.ll
index d54ee48ea74..31fadfb0aff 100644
--- a/llvm/test/CodeGen/X86/finite-libcalls.ll
+++ b/llvm/test/CodeGen/X86/finite-libcalls.ll
@@ -9,7 +9,7 @@
 define float @exp_f32(float %x) #0 {
 ; GNU-LABEL: exp_f32:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __expf_finite # TAILCALL
+; GNU-NEXT:    jmp expf # TAILCALL
 ;
 ; WIN-LABEL: exp_f32:
 ; WIN:       # %bb.0:
@@ -25,7 +25,7 @@ define float @exp_f32(float %x) #0 {
 define double @exp_f64(double %x) #0 {
 ; GNU-LABEL: exp_f64:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __exp_finite # TAILCALL
+; GNU-NEXT:    jmp exp # TAILCALL
 ;
 ; WIN-LABEL: exp_f64:
 ; WIN:       # %bb.0:
@@ -44,7 +44,7 @@ define x86_fp80 @exp_f80(x86_fp80 %x) #0 {
 ; GNU-NEXT:    subq $24, %rsp
 ; GNU-NEXT:    fldt {{[0-9]+}}(%rsp)
 ; GNU-NEXT:    fstpt (%rsp)
-; GNU-NEXT:    callq __expl_finite
+; GNU-NEXT:    callq expl
 ; GNU-NEXT:    addq $24, %rsp
 ; GNU-NEXT:    retq
 ;
@@ -80,7 +80,7 @@ define x86_fp80 @exp_f80(x86_fp80 %x) #0 {
 define float @exp2_f32(float %x) #0 {
 ; GNU-LABEL: exp2_f32:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __exp2f_finite # TAILCALL
+; GNU-NEXT:    jmp exp2f # TAILCALL
 ;
 ; WIN-LABEL: exp2_f32:
 ; WIN:       # %bb.0:
@@ -96,7 +96,7 @@ define float @exp2_f32(float %x) #0 {
 define double @exp2_f64(double %x) #0 {
 ; GNU-LABEL: exp2_f64:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __exp2_finite # TAILCALL
+; GNU-NEXT:    jmp exp2 # TAILCALL
 ;
 ; WIN-LABEL: exp2_f64:
 ; WIN:       # %bb.0:
@@ -115,7 +115,7 @@ define x86_fp80 @exp2_f80(x86_fp80 %x) #0 {
 ; GNU-NEXT:    subq $24, %rsp
 ; GNU-NEXT:    fldt {{[0-9]+}}(%rsp)
 ; GNU-NEXT:    fstpt (%rsp)
-; GNU-NEXT:    callq __exp2l_finite
+; GNU-NEXT:    callq exp2l
 ; GNU-NEXT:    addq $24, %rsp
 ; GNU-NEXT:    retq
 ;
@@ -151,7 +151,7 @@ define x86_fp80 @exp2_f80(x86_fp80 %x) #0 {
 define float @log_f32(float %x) #0 {
 ; GNU-LABEL: log_f32:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __logf_finite # TAILCALL
+; GNU-NEXT:    jmp logf # TAILCALL
 ;
 ; WIN-LABEL: log_f32:
 ; WIN:       # %bb.0:
@@ -167,7 +167,7 @@ define float @log_f32(float %x) #0 {
 define double @log_f64(double %x) #0 {
 ; GNU-LABEL: log_f64:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __log_finite # TAILCALL
+; GNU-NEXT:    jmp log # TAILCALL
 ;
 ; WIN-LABEL: log_f64:
 ; WIN:       # %bb.0:
@@ -186,7 +186,7 @@ define x86_fp80 @log_f80(x86_fp80 %x) #0 {
 ; GNU-NEXT:    subq $24, %rsp
 ; GNU-NEXT:    fldt {{[0-9]+}}(%rsp)
 ; GNU-NEXT:    fstpt (%rsp)
-; GNU-NEXT:    callq __logl_finite
+; GNU-NEXT:    callq logl
 ; GNU-NEXT:    addq $24, %rsp
 ; GNU-NEXT:    retq
 ;
@@ -222,7 +222,7 @@ define x86_fp80 @log_f80(x86_fp80 %x) #0 {
 define float @log2_f32(float %x) #0 {
 ; GNU-LABEL: log2_f32:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __log2f_finite # TAILCALL
+; GNU-NEXT:    jmp log2f # TAILCALL
 ;
 ; WIN-LABEL: log2_f32:
 ; WIN:       # %bb.0:
@@ -238,7 +238,7 @@ define float @log2_f32(float %x) #0 {
 define double @log2_f64(double %x) #0 {
 ; GNU-LABEL: log2_f64:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __log2_finite # TAILCALL
+; GNU-NEXT:    jmp log2 # TAILCALL
 ;
 ; WIN-LABEL: log2_f64:
 ; WIN:       # %bb.0:
@@ -257,7 +257,7 @@ define x86_fp80 @log2_f80(x86_fp80 %x) #0 {
 ; GNU-NEXT:    subq $24, %rsp
 ; GNU-NEXT:    fldt {{[0-9]+}}(%rsp)
 ; GNU-NEXT:    fstpt (%rsp)
-; GNU-NEXT:    callq __log2l_finite
+; GNU-NEXT:    callq log2l
 ; GNU-NEXT:    addq $24, %rsp
 ; GNU-NEXT:    retq
 ;
@@ -293,7 +293,7 @@ define x86_fp80 @log2_f80(x86_fp80 %x) #0 {
 define float @log10_f32(float %x) #0 {
 ; GNU-LABEL: log10_f32:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __log10f_finite # TAILCALL
+; GNU-NEXT:    jmp log10f # TAILCALL
 ;
 ; WIN-LABEL: log10_f32:
 ; WIN:       # %bb.0:
@@ -309,7 +309,7 @@ define float @log10_f32(float %x) #0 {
 define double @log10_f64(double %x) #0 {
 ; GNU-LABEL: log10_f64:
 ; GNU:       # %bb.0:
-; GNU-NEXT:    jmp __log10_finite # TAILCALL
+; GNU-NEXT:    jmp log10 # TAILCALL
 ;
 ; WIN-LABEL: log10_f64:
 ; WIN:       # %bb.0:
@@ -328,7 +328,7 @@ define x86_fp80 @log10_f80(x86_fp80 %x) #0 {
 ; GNU-NEXT:    subq $24, %rsp
 ; GNU-NEXT:    fldt {{[0-9]+}}(%rsp)
 ; GNU-NEXT:    fstpt (%rsp)
-; GNU-NEXT:    callq __log10l_finite
+; GNU-NEXT:    callq log10l
 ; GNU-NEXT:    addq $24, %rsp
 ; GNU-NEXT:    retq
 ;
@@ -365,7 +365,7 @@ define float @pow_f32(float %x) #0 {
 ; GNU-LABEL: pow_f32:
 ; GNU:       # %bb.0:
 ; GNU-NEXT:    movaps %xmm0, %xmm1
-; GNU-NEXT:    jmp __powf_finite # TAILCALL
+; GNU-NEXT:    jmp powf # TAILCALL
 ;
 ; WIN-LABEL: pow_f32:
 ; WIN:       # %bb.0:
@@ -384,7 +384,7 @@ define double @pow_f64(double %x) #0 {
 ; GNU-LABEL: pow_f64:
 ; GNU:       # %bb.0:
 ; GNU-NEXT:    movaps %xmm0, %xmm1
-; GNU-NEXT:    jmp __pow_finite # TAILCALL
+; GNU-NEXT:    jmp pow # TAILCALL
 ;
 ; WIN-LABEL: pow_f64:
 ; WIN:       # %bb.0:
@@ -407,7 +407,7 @@ define x86_fp80 @pow_f80(x86_fp80 %x) #0 {
 ; GNU-NEXT:    fld %st(0)
 ; GNU-NEXT:    fstpt {{[0-9]+}}(%rsp)
 ; GNU-NEXT:    fstpt (%rsp)
-; GNU-NEXT:    callq __powl_finite
+; GNU-NEXT:    callq powl
 ; GNU-NEXT:    addq $40, %rsp
 ; GNU-NEXT:    retq
 ;

commit 73c53e612aa125a24eb2c75241b2ebbd560b85c7
Author: Saleem Abdulrasool <compnerd@compnerd.org>
Date:   Thu Feb 27 19:23:57 2020 -0800

    build: process the libxml2 library path for embedding
    
    Process the path for libxml2 before embedding that into the command line
    that is generated in `llvm-config`.  Each element in the path is being
    given a `-l` unconditionally which should not be the case for absolute
    paths.  Since the library path may be absolute or not, just apply some
    CMake pre-processing when generating the path.
    
    Before:
    ```
    /usr/lib/x86_64-linux-gnu/libz.so -lrt -ldl -ltinfo -lpthread -lm /usr/lib/x86_64-linux-gnu/libxml2.so
    ```
    
    After:
    ```
    /usr/lib/x86_64-linux-gnu/libz.so -lrt -ldl -ltinfo -lpthread -lm -lxml2
    ```
    
    Resolves PR44179!
    
    (cherry picked from commit c3595d1069277b4ab0df49d7139b6f1bbc94f21c)

diff --git a/llvm/lib/WindowsManifest/CMakeLists.txt b/llvm/lib/WindowsManifest/CMakeLists.txt
index fe6ddcd414d..8cfea1282ad 100644
--- a/llvm/lib/WindowsManifest/CMakeLists.txt
+++ b/llvm/lib/WindowsManifest/CMakeLists.txt
@@ -7,6 +7,15 @@ add_llvm_component_library(LLVMWindowsManifest
 
 if(LIBXML2_LIBRARIES)
   target_link_libraries(LLVMWindowsManifest PUBLIC ${LIBXML2_LIBRARIES})
+
+  get_filename_component(xml2_library ${LIBXML2_LIBRARIES} NAME)
+  if(xml2_library MATCHES "^${CMAKE_STATIC_LIBRARY_PREFIX}.*${CMAKE_STATIC_LIBRARY_SUFFIX}$")
+    string(REGEX REPLACE "^${CMAKE_STATIC_LIBRARY_PREFIX}" "" xml2_library ${xml2_library})
+    string(REGEX REPLACE "${CMAKE_STATIC_LIBRARY_SUFFIX}$" "" xml2_library ${xml2_library})
+  elseif(xml2_library MATCHES "^${CMAKE_SHARED_LIBRARY_PREFIX}.*${CMAKE_SHARED_LIBRARY_SUFFIX}$")
+    string(REGEX REPLACE "^${CMAKE_SHARED_LIBRARY_PREFIX}" "" xml2_library ${xml2_library})
+    string(REGEX REPLACE "${CMAKE_SHARED_LIBRARY_SUFFIX}$" "" xml2_library ${xml2_library})
+  endif()
   set_property(TARGET LLVMWindowsManifest PROPERTY
-    LLVM_SYSTEM_LIBS ${LIBXML2_LIBRARIES})
+    LLVM_SYSTEM_LIBS ${xml2_library})
 endif()

commit cef9526ce77d671790d6c7c07cba2a48066de468
Author: LLVM GN Syncbot <llvmgnsyncbot@gmail.com>
Date:   Sun Jan 19 14:54:02 2020 +0000

    [gn build] Port a0f50d73163
    
    (cherry picked from commit 4612e48d2fd91d99b4ea7136017bd72ab2946430)

diff --git a/llvm/utils/gn/secondary/clang/lib/AST/BUILD.gn b/llvm/utils/gn/secondary/clang/lib/AST/BUILD.gn
index c3669a6691b..9d44ae1aa88 100644
--- a/llvm/utils/gn/secondary/clang/lib/AST/BUILD.gn
+++ b/llvm/utils/gn/secondary/clang/lib/AST/BUILD.gn
@@ -74,6 +74,7 @@ static_library("AST") {
     "Expr.cpp",
     "ExprCXX.cpp",
     "ExprClassification.cpp",
+    "ExprConcepts.cpp",
     "ExprConstant.cpp",
     "ExprObjC.cpp",
     "ExternalASTMerger.cpp",

commit 4ce4b0c36786b0da6b1794578f67469e4627b9d1
Author: Hans Wennborg <hans@chromium.org>
Date:   Fri Feb 28 16:52:29 2020 +0100

    update clang-cl flag section in UsersManual.rst

diff --git a/clang/docs/UsersManual.rst b/clang/docs/UsersManual.rst
index 856d5e34bbc..07157b9ad5f 100644
--- a/clang/docs/UsersManual.rst
+++ b/clang/docs/UsersManual.rst
@@ -3297,59 +3297,58 @@ Execute ``clang-cl /?`` to see a list of supported options:
     CL.EXE COMPATIBILITY OPTIONS:
       /?                      Display available options
       /arch:<value>           Set architecture for code generation
-      /Brepro-                Emit an object file which cannot be reproduced over time
-      /Brepro                 Emit an object file which can be reproduced over time
+      /Brepro-                Write current time into COFF output (default)
+      /Brepro                 Do not write current time into COFF output (breaks link.exe /incremental)
       /clang:<arg>            Pass <arg> to the clang driver
-      /C                      Don't discard comments when preprocessing
+      /C                      Do not discard comments when preprocessing
       /c                      Compile only
       /d1PP                   Retain macro definitions in /E mode
       /d1reportAllClassLayout Dump record layout information
-      /diagnostics:caret      Enable caret and column diagnostics (on by default)
+      /diagnostics:caret      Enable caret and column diagnostics (default)
       /diagnostics:classic    Disable column and caret diagnostics
       /diagnostics:column     Disable caret diagnostics but keep column info
       /D <macro[=value]>      Define macro
-      /EH<value>              Exception handling model
+      /EH<value>              Set exception handling model
       /EP                     Disable linemarker output and preprocess to stdout
       /execution-charset:<value>
-                              Runtime encoding, supports only UTF-8
+                              Set runtime encoding, supports only UTF-8
       /E                      Preprocess to stdout
       /fallback               Fall back to cl.exe if clang-cl fails to compile
       /FA                     Output assembly code file during compilation
-      /Fa<file or directory>  Output assembly code to this file during compilation (with /FA)
-      /Fe<file or directory>  Set output executable file or directory (ends in / or \)
+      /Fa<file or dir/>       Set assembly output file name (with /FA)
+      /Fe<file or dir/>       Set output executable file name
       /FI <value>             Include file before parsing
       /Fi<file>               Set preprocess output file name (with /P)
-      /Fo<file or directory>  Set output object file, or directory (ends in / or \) (with /c)
+      /Fo<file or dir/>       Set output object file (with /c)
       /fp:except-
       /fp:except
       /fp:fast
       /fp:precise
       /fp:strict
-      /Fp<filename>           Set pch filename (with /Yc and /Yu)
+      /Fp<file>               Set pch file name (with /Yc and /Yu)
       /GA                     Assume thread-local variables are defined in the executable
       /Gd                     Set __cdecl as a default calling convention
       /GF-                    Disable string pooling
       /GF                     Enable string pooling (default)
-      /GR-                    Disable emission of RTTI data
+      /GR-                    Do not emit RTTI data
       /Gregcall               Set __regcall as a default calling convention
-      /GR                     Enable emission of RTTI data
+      /GR                     Emit RTTI data (default)
       /Gr                     Set __fastcall as a default calling convention
       /GS-                    Disable buffer security check
       /GS                     Enable buffer security check (default)
       /Gs                     Use stack probes (default)
       /Gs<value>              Set stack probe size (default 4096)
-      /guard:<value>          Enable Control Flow Guard with /guard:cf,
-                              or only the table with /guard:cf,nochecks
+      /guard:<value>          Enable Control Flow Guard with /guard:cf, or only the table with /guard:cf,nochecks
       /Gv                     Set __vectorcall as a default calling convention
-      /Gw-                    Don't put each data item in its own section
+      /Gw-                    Do not put each data item in its own section (default)
       /Gw                     Put each data item in its own section
-      /GX-                    Disable exception handling
-      /GX                     Enable exception handling
-      /Gy-                    Don't put each function in its own section (default)
+      /GX-                    Deprecated (like not passing /EH)
+      /GX                     Deprecated; use /EHsc
+      /Gy-                    Do not put each function in its own section (default)
       /Gy                     Put each function in its own section
       /Gz                     Set __stdcall as a default calling convention
       /help                   Display available options
-      /imsvc <dir>            Add directory to system include search path, as if part of %INCLUDE%
+      /imsvc <dir>            Add <dir> to system include search path, as if in %INCLUDE%
       /I <dir>                Add directory to include search path
       /J                      Make char type unsigned
       /LDd                    Create debug DLL
@@ -3359,35 +3358,37 @@ Execute ``clang-cl /?`` to see a list of supported options:
       /MD                     Use DLL run-time
       /MTd                    Use static debug run-time
       /MT                     Use static run-time
-      /O0                     Disable optimization
-      /O1                     Optimize for size  (same as /Og     /Os /Oy /Ob2 /GF /Gy)
-      /O2                     Optimize for speed (same as /Og /Oi /Ot /Oy /Ob2 /GF /Gy)
+      /O1                     Optimize for size  (like /Og     /Os /Oy /Ob2 /GF /Gy)
+      /O2                     Optimize for speed (like /Og /Oi /Ot /Oy /Ob2 /GF /Gy)
       /Ob0                    Disable function inlining
-      /Ob1                    Only inline functions which are (explicitly or implicitly) marked inline
+      /Ob1                    Only inline functions explicitly or implicitly marked inline
       /Ob2                    Inline functions as deemed beneficial by the compiler
       /Od                     Disable optimization
       /Og                     No effect
       /Oi-                    Disable use of builtin functions
       /Oi                     Enable use of builtin functions
+      /openmp-                Disable OpenMP support
+      /openmp:experimental    Enable OpenMP support with experimental SIMD support
+      /openmp                 Enable OpenMP support
       /Os                     Optimize for size
       /Ot                     Optimize for speed
-      /Ox                     Deprecated (same as /Og /Oi /Ot /Oy /Ob2); use /O2 instead
+      /Ox                     Deprecated (like /Og /Oi /Ot /Oy /Ob2); use /O2
       /Oy-                    Disable frame pointer omission (x86 only, default)
       /Oy                     Enable frame pointer omission (x86 only)
       /O<flags>               Set multiple /O flags at once; e.g. '/O2y-' for '/O2 /Oy-'
-      /o <file or directory>  Set output file or directory (ends in / or \)
+      /o <file or dir/>       Deprecated (set output file name); use /Fe or /Fe
       /P                      Preprocess to file
       /Qvec-                  Disable the loop vectorization passes
       /Qvec                   Enable the loop vectorization passes
-      /showFilenames-         Don't print the name of each compiled file (default)
+      /showFilenames-         Do not print the name of each compiled file (default)
       /showFilenames          Print the name of each compiled file
       /showIncludes           Print info about included files to stderr
-      /source-charset:<value> Source encoding, supports only UTF-8
-      /std:<value>            Language standard to compile for
+      /source-charset:<value> Set source encoding, supports only UTF-8
+      /std:<value>            Set C++ version (c++14,c++17,c++latest)
       /TC                     Treat all source files as C
-      /Tc <filename>          Specify a C source file
+      /Tc <file>              Treat <file> as C source file
       /TP                     Treat all source files as C++
-      /Tp <filename>          Specify a C++ source file
+      /Tp <file>              Treat <file> as C++ source file
       /utf-8                  Set source and runtime encoding to UTF-8 (default)
       /U <macro>              Undefine macro
       /vd<value>              Control vtordisp placement
@@ -3404,17 +3405,19 @@ Execute ``clang-cl /?`` to see a list of supported options:
       /W3                     Enable -Wall
       /W4                     Enable -Wall and -Wextra
       /Wall                   Enable -Weverything
-      /WX-                    Do not treat warnings as errors
+      /WX-                    Do not treat warnings as errors (default)
       /WX                     Treat warnings as errors
       /w                      Disable all warnings
-      /X                      Don't add %INCLUDE% to the include search path
+      /X                      Do not add %INCLUDE% to include search path
       /Y-                     Disable precompiled headers, overrides /Yc and /Yu
       /Yc<filename>           Generate a pch file for all code up to and including <filename>
       /Yu<filename>           Load a pch file and use it instead of all code up to and including <filename>
       /Z7                     Enable CodeView debug information in object files
-      /Zc:char8_t             Enable C++2a char8_t type
-      /Zc:char8_t-            Disable C++2a char8_t type
-      /Zc:dllexportInlines-   Don't dllexport/dllimport inline member functions of dllexport/import classes
+      /Zc:alignedNew-         Disable C++17 aligned allocation functions
+      /Zc:alignedNew          Enable C++17 aligned allocation functions
+      /Zc:char8_t-            Disable char8_t from c++2a
+      /Zc:char8_t             Enable char8_t from C++2a
+      /Zc:dllexportInlines-   Do not dllexport/dllimport inline member functions of dllexport/import classes
       /Zc:dllexportInlines    dllexport/dllimport inline member functions of dllexport/import classes (default)
       /Zc:sizedDealloc-       Disable C++14 sized global deallocation functions
       /Zc:sizedDealloc        Enable C++14 sized global deallocation functions
@@ -3423,18 +3426,21 @@ Execute ``clang-cl /?`` to see a list of supported options:
       /Zc:threadSafeInit      Enable thread-safe initialization of static variables
       /Zc:trigraphs-          Disable trigraphs (default)
       /Zc:trigraphs           Enable trigraphs
-      /Zc:twoPhase-           Disable two-phase name lookup in templates
+      /Zc:twoPhase-           Disable two-phase name lookup in templates (default)
       /Zc:twoPhase            Enable two-phase name lookup in templates
       /Zd                     Emit debug line number tables only
-      /Zi                     Alias for /Z7. Does not produce PDBs.
-      /Zl                     Don't mention any default libraries in the object file
-      /Zp                     Set the default maximum struct packing alignment to 1
-      /Zp<value>              Specify the default maximum struct packing alignment
+      /Zi                     Like /Z7
+      /Zl                     Do not let object file auto-link default libraries
+      /Zp                     Set default maximum struct packing alignment to 1
+      /Zp<value>              Set default maximum struct packing alignment
       /Zs                     Syntax-check only
 
     OPTIONS:
       -###                    Print (but do not run) the commands to run for this compilation
       --analyze               Run the static analyzer
+      -enable-trivial-auto-var-init-zero-knowing-it-will-be-removed-from-clang
+                              Trivial automatic variable initialization to zero is only here for benchmarks, it'll
+                              eventually be removed, and I'm OK with that because I'm only using it to benchmark
       -faddrsig               Emit an address-significance table
       -fansi-escape-codes     Use ANSI escape codes for diagnostics
       -fblocks                Enable the 'blocks' language feature
@@ -3444,6 +3450,13 @@ Execute ``clang-cl /?`` to see a list of supported options:
       -fcomplete-member-pointers
                               Require member pointer base types to be complete if they would be significant under the Microsoft ABI
       -fcoverage-mapping      Generate coverage mapping to enable code coverage analysis
+      -fcs-profile-generate=<directory>
+                              Generate instrumented code to collect context sensitive execution counts into
+                              <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)
+      -fcs-profile-generate   Generate instrumented code to collect context sensitive execution counts into
+                              default.profraw (overridden by LLVM_PROFILE_FILE env var)
+      -fdebug-compilation-dir <value>
+                              The compilation directory to embed in the debug info.
       -fdebug-macro           Emit macro debug information
       -fdelayed-template-parsing
                               Parse templated function definitions at the end of the translation unit
@@ -3451,16 +3464,17 @@ Execute ``clang-cl /?`` to see a list of supported options:
                               Print absolute paths in diagnostics
       -fdiagnostics-parseable-fixits
                               Print fix-its in machine parseable form
+      -fgnuc-version=<value>  Sets various macros to claim compatibility with the given GCC version (default is 4.2.1)
+      -fintegrated-cc1        Run cc1 in-process
       -flto=<value>           Set LTO mode to either 'full' or 'thin'
       -flto                   Enable LTO in 'full' mode
       -fmerge-all-constants   Allow merging of constants
       -fms-compatibility-version=<value>
-                              Dot-separated value representing the Microsoft compiler version
-                              number to report in _MSC_VER (0 = don't define it (default))
+                              Dot-separated value representing the Microsoft compiler version number to report in
+                              _MSC_VER (0 = don't define it (default))
       -fms-compatibility      Enable full Microsoft Visual C++ compatibility
       -fms-extensions         Accept some non-standard constructs supported by the Microsoft compiler
-      -fmsc-version=<value>   Microsoft compiler version number to report in _MSC_VER
-                              (0 = don't define it (default))
+      -fmsc-version=<value>   Microsoft compiler version number to report in _MSC_VER (0 = don't define it (default))
       -fno-addrsig            Don't emit an address-significance table
       -fno-builtin-<value>    Disable implicit builtin knowledge of a specific function
       -fno-builtin            Disable implicit builtin knowledge of functions
@@ -3471,6 +3485,11 @@ Execute ``clang-cl /?`` to see a list of supported options:
       -fno-debug-macro        Do not emit macro debug information
       -fno-delayed-template-parsing
                               Disable delayed template parsing
+      -fno-integrated-cc1     Spawn a separate process for each cc1
+      -fno-profile-generate   Disable generation of profile instrumentation.
+      -fno-profile-instr-generate
+                              Disable generation of profile instrumentation.
+      -fno-profile-instr-use  Disable using instrumentation data for profile-guided optimization
       -fno-sanitize-address-poison-custom-array-cookie
                               Disable poisoning array cookies when using custom operator new[] in AddressSanitizer
       -fno-sanitize-address-use-after-scope
@@ -3478,6 +3497,8 @@ Execute ``clang-cl /?`` to see a list of supported options:
       -fno-sanitize-address-use-odr-indicator
                               Disable ODR indicator globals
       -fno-sanitize-blacklist Don't use blacklist file for sanitizers
+      -fno-sanitize-cfi-canonical-jump-tables
+                              Do not make the jump table addresses canonical in the symbol table
       -fno-sanitize-cfi-cross-dso
                               Disable control flow integrity (CFI) checks for cross-DSO calls.
       -fno-sanitize-coverage=<value>
@@ -3498,17 +3519,26 @@ Execute ``clang-cl /?`` to see a list of supported options:
       -fno-sanitize-trap=<value>
                               Disable trapping for specified sanitizers
       -fno-standalone-debug   Limit debug information produced to reduce size of debug binary
+      -fno-temp-file          Directly create compilation output files. This may lead to incorrect incremental builds if the compiler crashes
       -fobjc-runtime=<value>  Specify the target Objective-C runtime kind and version
+      -forder-file-instrumentation
+                              Generate instrumented code to collect order file into default.profraw file
+                              (overridden by '=' form of option or LLVM_PROFILE_FILE env var)
       -fprofile-exclude-files=<value>
                               Instrument only functions from files where names don't match all the regexes separated by a semi-colon
       -fprofile-filter-files=<value>
                               Instrument only functions from files where names match any regex separated by a semi-colon
+      -fprofile-generate=<directory>
+                              Generate instrumented code to collect execution counts into
+                              <directory>/default.profraw (overridden by LLVM_PROFILE_FILE env var)
+      -fprofile-generate      Generate instrumented code to collect execution counts into
+                              default.profraw (overridden by LLVM_PROFILE_FILE env var)
       -fprofile-instr-generate=<file>
-                              Generate instrumented code to collect execution counts into <file>
-                              (overridden by LLVM_PROFILE_FILE env var)
+                              Generate instrumented code to collect execution counts into
+                              <file> (overridden by LLVM_PROFILE_FILE env var)
       -fprofile-instr-generate
-                              Generate instrumented code to collect execution counts into default.profraw file
-                              (overridden by '=' form of option or LLVM_PROFILE_FILE env var)
+                              Generate instrumented code to collect execution counts into
+                              default.profraw file (overridden by '=' form of option or LLVM_PROFILE_FILE env var)
       -fprofile-instr-use=<value>
                               Use instrumentation data for profile-guided optimization
       -fprofile-remapping-file=<file>
@@ -3522,9 +3552,12 @@ Execute ``clang-cl /?`` to see a list of supported options:
       -fsanitize-address-use-after-scope
                               Enable use-after-scope detection in AddressSanitizer
       -fsanitize-address-use-odr-indicator
-                              Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size
+                              Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized
+                              programs at the cost of an increase in binary size
       -fsanitize-blacklist=<value>
                               Path to blacklist file for sanitizers
+      -fsanitize-cfi-canonical-jump-tables
+                              Make the jump table addresses canonical in the symbol table
       -fsanitize-cfi-cross-dso
                               Enable control flow integrity (CFI) checks for cross-DSO calls.
       -fsanitize-cfi-icall-generalize-pointers
@@ -3532,7 +3565,8 @@ Execute ``clang-cl /?`` to see a list of supported options:
       -fsanitize-coverage=<value>
                               Specify the type of coverage instrumentation for Sanitizers
       -fsanitize-hwaddress-abi=<value>
-                              Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor)
+                              Select the HWAddressSanitizer ABI to target (interceptor or platform,
+                              default interceptor). This option is currently unused.
       -fsanitize-memory-track-origins=<value>
                               Enable origins tracking in MemorySanitizer
       -fsanitize-memory-track-origins
@@ -3542,6 +3576,8 @@ Execute ``clang-cl /?`` to see a list of supported options:
       -fsanitize-recover=<value>
                               Enable recovery for specified sanitizers
       -fsanitize-stats        Enable sanitizer statistics gathering.
+      -fsanitize-system-blacklist=<value>
+                              Path to system blacklist file for sanitizers
       -fsanitize-thread-atomics
                               Enable atomic operations instrumentation in ThreadSanitizer (default)
       -fsanitize-thread-func-entry-exit
@@ -3551,18 +3587,31 @@ Execute ``clang-cl /?`` to see a list of supported options:
       -fsanitize-trap=<value> Enable trapping for specified sanitizers
       -fsanitize-undefined-strip-path-components=<number>
                               Strip (or keep only, if negative) a given number of path components when emitting check metadata.
-      -fsanitize=<check>      Turn on runtime checks for various forms of undefined or suspicious
-                              behavior. See user manual for available checks
+      -fsanitize=<check>      Turn on runtime checks for various forms of undefined or suspicious behavior. See user manual for available checks
       -fsplit-lto-unit        Enables splitting of the LTO unit.
       -fstandalone-debug      Emit full debug info for all types used by the program
+      -fthin-link-bitcode=<value>
+                              Write minimized bitcode to <file> for the ThinLTO thin link only
+      -fthinlto-index=<value> Perform ThinLTO importing using provided function summary index
+      -ftime-trace-granularity=<value>
+                              Minimum time granularity (in microseconds) traced by time profiler
+      -ftime-trace            Turn on time profiler. Generates JSON file based on output filename.
+      -ftrivial-auto-var-init=<value>
+                              Initialize trivial automatic stack variables: uninitialized (default) | pattern
+      -fvirtual-function-elimination
+                              Enables dead virtual function elimination optimization. Requires -flto=full
       -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto
       -gcodeview-ghash        Emit type record hashes in a .debug$H section
       -gcodeview              Generate CodeView debug information
+      -gdwarf                 Generate source-level debug information with the default dwarf version
       -gline-directives-only  Emit debug line info directives only
       -gline-tables-only      Emit debug line number tables only
+      -gno-inline-line-tables Don't emit inline line tables
       -miamcu                 Use Intel MCU ABI
       -mllvm <value>          Additional arguments to forward to LLVM's option processing
       -nobuiltininc           Disable builtin #include directories
+      -print-supported-cpus   Print supported cpu models for the given target
+                              (if target is not specified, it will print the supported cpus for the default target)
       -Qunused-arguments      Don't emit warning for unused driver arguments
       -R<remark>              Enable the specified remark
       --target=<value>        Generate code for the given target

commit 7f015d0d4f0bd695431c729667c1d95068c58b71
Author: Hans Wennborg <hans@chromium.org>
Date:   Fri Feb 28 16:55:05 2020 +0100

    Re-generate docs
    
        bin/clang-tblgen -gen-diag-docs -I../clang/include \
              -I../clang/include/clang/Basic/ \
              ../clang/include/clang/Basic/Diagnostic.td -o \
              ../clang/docs/DiagnosticsReference.rst && \
        bin/clang-tblgen -gen-attr-docs -I../clang/include \
                ../clang/include/clang/Basic/Attr.td -o \
                ../clang/docs/AttributeReference.rst && \
        bin/clang-tblgen -gen-opt-docs -I../clang/include \
                -I../clang/include/clang/Driver -I../llvm/include \
                ../clang/include/clang/Driver/ClangOptionDocs.td -o \
                ../clang/docs/ClangCommandLineReference.rst

diff --git a/clang/docs/DiagnosticsReference.rst b/clang/docs/DiagnosticsReference.rst
index aa9115b801d..afd38929fb6 100644
--- a/clang/docs/DiagnosticsReference.rst
+++ b/clang/docs/DiagnosticsReference.rst
@@ -1636,7 +1636,7 @@ Synonym for `-Wc++17-compat-mangling`_.
 Synonym for `-Wc++17-extensions`_.
 
 
--Wc++2a-compat
+-Wc++20-compat
 --------------
 Some of the diagnostics controlled by this flag are enabled by default.
 
@@ -1651,32 +1651,32 @@ Some of the diagnostics controlled by this flag are enabled by default.
 +------------------------------------------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`aggregate initialization of type` |nbsp| :placeholder:`A` |nbsp| :diagtext:`with user-declared constructors is incompatible with C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`aggregate initialization of type` |nbsp| :placeholder:`A` |nbsp| :diagtext:`with user-declared constructors is incompatible with C++20`|
 +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
 
 +------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`this expression will be parsed as explicit(bool) in C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`this expression will be parsed as explicit(bool) in C++20`|
 +------------------------------------------------------------------------------------------------+
 
 +------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`'<=>' is a single token in C++2a; add a space to avoid a change in behavior`|
+|:warning:`warning:` |nbsp| :diagtext:`'<=>' is a single token in C++20; add a space to avoid a change in behavior`|
 +------------------------------------------------------------------------------------------------------------------+
 
 +--------------------------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`type of UTF-8 string literal will change from array of const char to array of const char8\_t in C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`type of UTF-8 string literal will change from array of const char to array of const char8\_t in C++20`|
 +--------------------------------------------------------------------------------------------------------------------------------------------+
 
 +-------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`'`:placeholder:`A`:diagtext:`' is a keyword in C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`'`:placeholder:`A`:diagtext:`' is a keyword in C++20`|
 +-------------------------------------------------------------------------------------------+
 
 
--Wc++2a-compat-pedantic
+-Wc++20-compat-pedantic
 -----------------------
-Synonym for `-Wc++2a-compat`_.
+Synonym for `-Wc++20-compat`_.
 
 
--Wc++2a-designator
+-Wc++20-designator
 ------------------
 **Diagnostic text:**
 
@@ -1685,24 +1685,24 @@ Synonym for `-Wc++2a-compat`_.
 +------------------------------------------------------------------------------------+
 
 
--Wc++2a-extensions
+-Wc++20-extensions
 ------------------
 Some of the diagnostics controlled by this flag are enabled by default.
 
-Also controls `-Wc++2a-designator`_.
+Also controls `-Wc++20-designator`_.
 
 **Diagnostic text:**
 
 +---------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`use of function template name with no prior declaration in function call with explicit template arguments is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`use of function template name with no prior declaration in function call with explicit template arguments is a C++20 extension`|
 +---------------------------------------------------------------------------------------------------------------------------------------------------------------------+
 
 +----------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`default member initializer for bit-field is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`default member initializer for bit-field is a C++20 extension`|
 +----------------------------------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------------+-------------------------+----------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`use of this statement in a constexpr` |nbsp| |+-----------------------+| |nbsp| :diagtext:`is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`use of this statement in a constexpr` |nbsp| |+-----------------------+| |nbsp| :diagtext:`is a C++20 extension`|
 |                                                                                   ||:diagtext:`function`   ||                                        |
 |                                                                                   |+-----------------------+|                                        |
 |                                                                                   ||:diagtext:`constructor`||                                        |
@@ -1714,7 +1714,7 @@ Also controls `-Wc++2a-designator`_.
 +----------------------------------------------------------------------------------------------------------------------+
 
 +------------------------------------------------------------------------------+-------------------------+----------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`function try block in constexpr` |nbsp| |+-----------------------+| |nbsp| :diagtext:`is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`function try block in constexpr` |nbsp| |+-----------------------+| |nbsp| :diagtext:`is a C++20 extension`|
 |                                                                              ||:diagtext:`function`   ||                                        |
 |                                                                              |+-----------------------+|                                        |
 |                                                                              ||:diagtext:`constructor`||                                        |
@@ -1734,11 +1734,11 @@ Also controls `-Wc++2a-designator`_.
 +---------------------------------------------------------------------------------------------------------------------------+
 
 +---------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`use of the` |nbsp| :placeholder:`A` |nbsp| :diagtext:`attribute is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`use of the` |nbsp| :placeholder:`A` |nbsp| :diagtext:`attribute is a C++20 extension`|
 +---------------------------------------------------------------------------------------------------------------------------+
 
 +---------------------------------------------------------------------------------+--------------------------------------------------------------+----------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`decomposition declaration declared` |nbsp| |+------------------------------------------------------------+| |nbsp| :diagtext:`is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`decomposition declaration declared` |nbsp| |+------------------------------------------------------------+| |nbsp| :diagtext:`is a C++20 extension`|
 |                                                                                 ||+------------------------------------------+                ||                                        |
 |                                                                                 |||:diagtext:`'`:placeholder:`B`:diagtext:`'`|                ||                                        |
 |                                                                                 ||+------------------------------------------+                ||                                        |
@@ -1754,48 +1754,63 @@ Also controls `-Wc++2a-designator`_.
 +-------------------------------------------------------------------------------------------+
 
 +--------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`explicit capture of 'this' with a capture default of '=' is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`explicit capture of 'this' with a capture default of '=' is a C++20 extension`|
 +--------------------------------------------------------------------------------------------------------------------+
 
 +--------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`explicit(bool) is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`explicit(bool) is a C++20 extension`|
 +--------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`range-based for loop initialization statements are a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`range-based for loop initialization statements are a C++20 extension`|
 +-----------------------------------------------------------------------------------------------------------+
 
 +---------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`initialized lambda pack captures are a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`initialized lambda pack captures are a C++20 extension`|
 +---------------------------------------------------------------------------------------------+
 
 +----------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`inline nested namespace definition is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`inline nested namespace definition is a C++20 extension`|
 +----------------------------------------------------------------------------------------------+
 
 +--------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`explicit template parameter list for lambdas is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`explicit template parameter list for lambdas is a C++20 extension`|
 +--------------------------------------------------------------------------------------------------------+
 
 +--------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`invoking a pointer to a 'const &' member function on an rvalue is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`invoking a pointer to a 'const &' member function on an rvalue is a C++20 extension`|
 +--------------------------------------------------------------------------------------------------------------------------+
 
 
+-Wc++2a-compat
+--------------
+Synonym for `-Wc++20-compat`_.
+
+
+-Wc++2a-compat-pedantic
+-----------------------
+Synonym for `-Wc++20-compat-pedantic`_.
+
+
+-Wc++2a-extensions
+------------------
+Synonym for `-Wc++20-extensions`_.
+
+
 -Wc++98-c++11-c++14-c++17-compat
 --------------------------------
 **Diagnostic text:**
 
 +------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`use of function template name with no prior function template declaration in function call with explicit template arguments is incompatible with C++ standards before C++20`|
 +------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
 
 +-------------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`default member initializer for bit-field is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`default member initializer for bit-field is incompatible with C++ standards before C++20`|
 +-------------------------------------------------------------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------------+-------------------------+-------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`use of this statement in a constexpr` |nbsp| |+-----------------------+| |nbsp| :diagtext:`is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`use of this statement in a constexpr` |nbsp| |+-----------------------+| |nbsp| :diagtext:`is incompatible with C++ standards before C++20`|
 |                                                                                   ||:diagtext:`function`   ||                                                                   |
 |                                                                                   |+-----------------------+|                                                                   |
 |                                                                                   ||:diagtext:`constructor`||                                                                   |
@@ -1807,7 +1822,7 @@ Also controls `-Wc++2a-designator`_.
 +-------------------------------------------------------------------------------------------------------------------------------------------------+
 
 +------------------------------------------------------------------------------+-------------------------+-------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`function try block in constexpr` |nbsp| |+-----------------------+| |nbsp| :diagtext:`is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`function try block in constexpr` |nbsp| |+-----------------------+| |nbsp| :diagtext:`is incompatible with C++ standards before C++20`|
 |                                                                              ||:diagtext:`function`   ||                                                                   |
 |                                                                              |+-----------------------+|                                                                   |
 |                                                                              ||:diagtext:`constructor`||                                                                   |
@@ -1827,11 +1842,11 @@ Also controls `-Wc++2a-designator`_.
 +------------------------------------------------------------------------------------------------------------------------------------------------------+
 
 +-------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`virtual constexpr functions are incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`virtual constexpr functions are incompatible with C++ standards before C++20`|
 +-------------------------------------------------------------------------------------------------------------------+
 
 +---------------------------------------------------------------------------------+--------------------------------------------------------------+-------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`decomposition declaration declared` |nbsp| |+------------------------------------------------------------+| |nbsp| :diagtext:`is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`decomposition declaration declared` |nbsp| |+------------------------------------------------------------+| |nbsp| :diagtext:`is incompatible with C++ standards before C++20`|
 |                                                                                 ||+------------------------------------------+                ||                                                                   |
 |                                                                                 |||:diagtext:`'`:placeholder:`B`:diagtext:`'`|                ||                                                                   |
 |                                                                                 ||+------------------------------------------+                ||                                                                   |
@@ -1847,7 +1862,7 @@ Also controls `-Wc++2a-designator`_.
 +----------------------------------------------------------------------------------------------------------------------+
 
 +-------------------------------------------------------------------------+--------------------------------------+----------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`explicitly defaulting this` |nbsp| |+------------------------------------+| |nbsp| :diagtext:`with a type different from the implicit type is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`explicitly defaulting this` |nbsp| |+------------------------------------+| |nbsp| :diagtext:`with a type different from the implicit type is incompatible with C++ standards before C++20`|
 |                                                                         ||:diagtext:`default constructor`     ||                                                                                                                |
 |                                                                         |+------------------------------------+|                                                                                                                |
 |                                                                         ||:diagtext:`copy constructor`        ||                                                                                                                |
@@ -1863,27 +1878,27 @@ Also controls `-Wc++2a-designator`_.
 +-------------------------------------------------------------------------+--------------------------------------+----------------------------------------------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`explicit capture of 'this' with a capture default of '=' is incompatible with C++ standards before C++20`|
 +-----------------------------------------------------------------------------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`explicit(bool) is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`explicit(bool) is incompatible with C++ standards before C++20`|
 +-----------------------------------------------------------------------------------------------------+
 
 +--------------------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`range-based for loop initialization statements are incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`range-based for loop initialization statements are incompatible with C++ standards before C++20`|
 +--------------------------------------------------------------------------------------------------------------------------------------+
 
 +------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`initialized lambda capture packs are incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`initialized lambda capture packs are incompatible with C++ standards before C++20`|
 +------------------------------------------------------------------------------------------------------------------------+
 
 +-------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`inline nested namespace definition is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`inline nested namespace definition is incompatible with C++ standards before C++20`|
 +-------------------------------------------------------------------------------------------------------------------------+
 
 +---------------------------+----------------------------------+-----------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| |+--------------------------------+| |nbsp| :diagtext:`of lambda is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| |+--------------------------------+| |nbsp| :diagtext:`of lambda is incompatible with C++ standards before C++20`|
 |                           ||:diagtext:`default construction`||                                                                             |
 |                           |+--------------------------------+|                                                                             |
 |                           ||:diagtext:`assignment`          ||                                                                             |
@@ -1891,11 +1906,11 @@ Also controls `-Wc++2a-designator`_.
 +---------------------------+----------------------------------+-----------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`explicit template parameter list for lambdas is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`explicit template parameter list for lambdas is incompatible with C++ standards before C++20`|
 +-----------------------------------------------------------------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`'<=>' operator is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`'<=>' operator is incompatible with C++ standards before C++20`|
 +-----------------------------------------------------------------------------------------------------+
 
 +----------------------------------------------------------------------------------------------------------------+
@@ -1914,7 +1929,7 @@ Also controls `-Wc++98-c++11-c++14-c++17-compat`_.
 +---------------------------------------------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++2a`|
+|:warning:`warning:` |nbsp| :diagtext:`invoking a pointer to a 'const &' member function on an rvalue is incompatible with C++ standards before C++20`|
 +-----------------------------------------------------------------------------------------------------------------------------------------------------+
 
 
@@ -2535,7 +2550,7 @@ Some of the diagnostics controlled by this flag are enabled by default.
 ----------------
 Some of the diagnostics controlled by this flag are enabled by default.
 
-Also controls `-Wc++2a-designator`_.
+Also controls `-Wc++20-designator`_.
 
 **Diagnostic text:**
 
@@ -2828,7 +2843,7 @@ This diagnostic is enabled by default.
 **Diagnostic text:**
 
 +---------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`ISO C++2a does not permit the 'bool' keyword after 'concept'`|
+|:warning:`warning:` |nbsp| :diagtext:`ISO C++20 does not permit the 'bool' keyword after 'concept'`|
 +---------------------------------------------------------------------------------------------------+
 
 
@@ -3402,7 +3417,7 @@ Also controls `-Wdeprecated-anon-enum-enum-conversion`_, `-Wdeprecated-array-com
 +--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
 
 +----------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`-fconcepts-ts is deprecated - use '-std=c++2a' for Concepts support`|
+|:warning:`warning:` |nbsp| :diagtext:`-fconcepts-ts is deprecated - use '-std=c++20' for Concepts support`|
 +----------------------------------------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------------------------------------------------------------------------------------+
@@ -6550,6 +6565,14 @@ This diagnostic is enabled by default.
 |                           |+--------------------------------------------------------------+|                                       |
 +---------------------------+----------------------------------------------------------------+---------------------------------------+
 
++---------------------------+-------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+
+|:warning:`warning:` |nbsp| |+-----------------------------+| |nbsp| :diagtext:`from` |nbsp| :placeholder:`B` |nbsp| :diagtext:`to` |nbsp| :placeholder:`C` |nbsp| :diagtext:`changes address space of nested pointers`|
+|                           ||:diagtext:`reinterpret\_cast`||                                                                                                                                                          |
+|                           |+-----------------------------+|                                                                                                                                                          |
+|                           ||:diagtext:`C-style cast`     ||                                                                                                                                                          |
+|                           |+-----------------------------+|                                                                                                                                                          |
++---------------------------+-------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------+
+
 
 -Wincompatible-property-type
 ----------------------------
@@ -7684,6 +7707,8 @@ This diagnostic is enabled by default.
 --------------------
 This diagnostic is enabled by default.
 
+Also controls `-Wmicrosoft-template-shadow`_.
+
 **Diagnostic text:**
 
 +------------------------------------------------------------------------------------------------------------------------------------------------------+
@@ -7732,15 +7757,22 @@ This diagnostic is enabled by default.
 |:warning:`warning:` |nbsp| :diagtext:`'static' can only be specified inside the class definition`|
 +-------------------------------------------------------------------------------------------------+
 
-+---------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`declaration of` |nbsp| :placeholder:`A` |nbsp| :diagtext:`shadows template parameter`|
-+---------------------------------------------------------------------------------------------------------------------------+
-
 +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
 |:warning:`warning:` |nbsp| :diagtext:`use of undeclared identifier` |nbsp| :placeholder:`A`:diagtext:`; unqualified lookup into dependent bases of class template` |nbsp| :placeholder:`B` |nbsp| :diagtext:`is a Microsoft extension`|
 +--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
 
 
+-Wmicrosoft-template-shadow
+---------------------------
+This diagnostic is enabled by default.
+
+**Diagnostic text:**
+
++---------------------------------------------------------------------------------------------------------------------------+
+|:warning:`warning:` |nbsp| :diagtext:`declaration of` |nbsp| :placeholder:`A` |nbsp| :diagtext:`shadows template parameter`|
++---------------------------------------------------------------------------------------------------------------------------+
+
+
 -Wmicrosoft-union-member-reference
 ----------------------------------
 This diagnostic is enabled by default.
@@ -8142,7 +8174,7 @@ This diagnostic is an error by default, but the flag ``-Wno-modules-import-neste
 ------
 Some of the diagnostics controlled by this flag are enabled by default.
 
-Controls `-Wcast-of-sel-type`_, `-Wchar-subscripts`_, `-Wcomment`_, `-Wdelete-non-virtual-dtor`_, `-Wextern-c-compat`_, `-Wformat`_, `-Wimplicit`_, `-Winfinite-recursion`_, `-Wint-in-bool-context`_, `-Wloop-analysis`_, `-Wmismatched-tags`_, `-Wmissing-braces`_, `-Wmove`_, `-Wmultichar`_, `-Wobjc-designated-initializers`_, `-Wobjc-flexible-array`_, `-Wobjc-missing-super-calls`_, `-Woverloaded-virtual`_, `-Wprivate-extern`_, `-Wreorder`_, `-Wreturn-type`_, `-Wself-assign`_, `-Wself-move`_, `-Wsizeof-array-argument`_, `-Wsizeof-array-decay`_, `-Wstring-plus-int`_, `-Wtautological-compare`_, `-Wtrigraphs`_, `-Wuninitialized`_, `-Wunknown-pragmas`_, `-Wunused`_, `-Wuser-defined-warnings`_, `-Wvolatile-register-var`_.
+Controls `-Wcast-of-sel-type`_, `-Wchar-subscripts`_, `-Wcomment`_, `-Wdelete-non-virtual-dtor`_, `-Wextern-c-compat`_, `-Wfor-loop-analysis`_, `-Wformat`_, `-Wimplicit`_, `-Winfinite-recursion`_, `-Wint-in-bool-context`_, `-Wmismatched-tags`_, `-Wmissing-braces`_, `-Wmove`_, `-Wmultichar`_, `-Wobjc-designated-initializers`_, `-Wobjc-flexible-array`_, `-Wobjc-missing-super-calls`_, `-Woverloaded-virtual`_, `-Wprivate-extern`_, `-Wrange-loop-construct`_, `-Wreorder`_, `-Wreturn-type`_, `-Wself-assign`_, `-Wself-move`_, `-Wsizeof-array-argument`_, `-Wsizeof-array-decay`_, `-Wstring-plus-int`_, `-Wtautological-compare`_, `-Wtrigraphs`_, `-Wuninitialized`_, `-Wunknown-pragmas`_, `-Wunused`_, `-Wuser-defined-warnings`_, `-Wvolatile-register-var`_.
 
 
 -Wmove
@@ -9691,7 +9723,7 @@ This diagnostic is enabled by default.
 
 -Wpedantic
 ----------
-Also controls `-Wc++11-extra-semi`_, `-Wc++11-long-long`_, `-Wc++14-binary-literal`_, `-Wc++2a-designator`_, `-Wc11-extensions`_, `-Wcomplex-component-init`_, `-Wdeclaration-after-statement`_, `-Wdollar-in-identifier-extension`_, `-Wembedded-directive`_, `-Wempty-translation-unit`_, `-Wfixed-enum-extension`_, `-Wflexible-array-extensions`_, `-Wfour-char-constants`_, `-Wgnu-anonymous-struct`_, `-Wgnu-auto-type`_, `-Wgnu-binary-literal`_, `-Wgnu-case-range`_, `-Wgnu-complex-integer`_, `-Wgnu-compound-literal-initializer`_, `-Wgnu-conditional-omitted-operand`_, `-Wgnu-empty-initializer`_, `-Wgnu-empty-struct`_, `-Wgnu-flexible-array-initializer`_, `-Wgnu-flexible-array-union-member`_, `-Wgnu-folding-constant`_, `-Wgnu-imaginary-constant`_, `-Wgnu-include-next`_, `-Wgnu-label-as-value`_, `-Wgnu-redeclared-enum`_, `-Wgnu-statement-expression`_, `-Wgnu-union-cast`_, `-Wgnu-zero-line-directive`_, `-Wgnu-zero-variadic-macro-arguments`_, `-Wimport-preprocessor-directive-pedantic`_, `-Wkeyword-macro`_, `-Wlanguage-extension-token`_, `-Wlong-long`_, `-Wmicrosoft-charize`_, `-Wmicrosoft-comment-paste`_, `-Wmicrosoft-cpp-macro`_, `-Wmicrosoft-end-of-file`_, `-Wmicrosoft-enum-value`_, `-Wmicrosoft-fixed-enum`_, `-Wmicrosoft-flexible-array`_, `-Wmicrosoft-redeclare-static`_, `-Wnested-anon-types`_, `-Wnullability-extension`_, `-Woverlength-strings`_, `-Wretained-language-linkage`_, `-Wundefined-internal-type`_, `-Wvla-extension`_, `-Wzero-length-array`_.
+Also controls `-Wc++11-extra-semi`_, `-Wc++11-long-long`_, `-Wc++14-binary-literal`_, `-Wc++20-designator`_, `-Wc11-extensions`_, `-Wcomplex-component-init`_, `-Wdeclaration-after-statement`_, `-Wdollar-in-identifier-extension`_, `-Wembedded-directive`_, `-Wempty-translation-unit`_, `-Wfixed-enum-extension`_, `-Wflexible-array-extensions`_, `-Wfour-char-constants`_, `-Wgnu-anonymous-struct`_, `-Wgnu-auto-type`_, `-Wgnu-binary-literal`_, `-Wgnu-case-range`_, `-Wgnu-complex-integer`_, `-Wgnu-compound-literal-initializer`_, `-Wgnu-conditional-omitted-operand`_, `-Wgnu-empty-initializer`_, `-Wgnu-empty-struct`_, `-Wgnu-flexible-array-initializer`_, `-Wgnu-flexible-array-union-member`_, `-Wgnu-folding-constant`_, `-Wgnu-imaginary-constant`_, `-Wgnu-include-next`_, `-Wgnu-label-as-value`_, `-Wgnu-redeclared-enum`_, `-Wgnu-statement-expression`_, `-Wgnu-union-cast`_, `-Wgnu-zero-line-directive`_, `-Wgnu-zero-variadic-macro-arguments`_, `-Wimport-preprocessor-directive-pedantic`_, `-Wkeyword-macro`_, `-Wlanguage-extension-token`_, `-Wlong-long`_, `-Wmicrosoft-charize`_, `-Wmicrosoft-comment-paste`_, `-Wmicrosoft-cpp-macro`_, `-Wmicrosoft-end-of-file`_, `-Wmicrosoft-enum-value`_, `-Wmicrosoft-fixed-enum`_, `-Wmicrosoft-flexible-array`_, `-Wmicrosoft-redeclare-static`_, `-Wnested-anon-types`_, `-Wnullability-extension`_, `-Woverlength-strings`_, `-Wretained-language-linkage`_, `-Wundefined-internal-type`_, `-Wvla-extension`_, `-Wzero-length-array`_.
 
 **Diagnostic text:**
 
@@ -9768,7 +9800,7 @@ Also controls `-Wc++11-extra-semi`_, `-Wc++11-long-long`_, `-Wc++14-binary-liter
 +--------------------------------------------------------------------------------------------------------------------------------------+
 
 +--------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`invoking a pointer to a 'const &' member function on an rvalue is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`invoking a pointer to a 'const &' member function on an rvalue is a C++20 extension`|
 +--------------------------------------------------------------------------------------------------------------------------+
 
 +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
@@ -9936,7 +9968,7 @@ Also controls `-Wc++11-extra-semi`_, `-Wc++11-long-long`_, `-Wc++14-binary-liter
 +---------------------------------------------------------------------------------------------------------------------------+
 
 +---------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`use of the` |nbsp| :placeholder:`A` |nbsp| :diagtext:`attribute is a C++2a extension`|
+|:warning:`warning:` |nbsp| :diagtext:`use of the` |nbsp| :placeholder:`A` |nbsp| :diagtext:`attribute is a C++20 extension`|
 +---------------------------------------------------------------------------------------------------------------------------+
 
 +-----------------------------------------------------------------------------+--------------------+---------------------------------------------+
@@ -10569,6 +10601,20 @@ This diagnostic is enabled by default.
 
 -Wrange-loop-analysis
 ---------------------
+Controls `-Wrange-loop-bind-reference`_, `-Wrange-loop-construct`_.
+
+
+-Wrange-loop-bind-reference
+---------------------------
+**Diagnostic text:**
+
++-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
+|:warning:`warning:` |nbsp| :diagtext:`loop variable` |nbsp| :placeholder:`A` |nbsp| :diagtext:`is always a copy because the range of type` |nbsp| :placeholder:`B` |nbsp| :diagtext:`does not return a reference`|
++-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
+
+
+-Wrange-loop-construct
+----------------------
 **Diagnostic text:**
 
 +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
@@ -10579,10 +10625,6 @@ This diagnostic is enabled by default.
 |:warning:`warning:` |nbsp| :diagtext:`loop variable` |nbsp| :placeholder:`A` |nbsp| :diagtext:`of type` |nbsp| :placeholder:`B` |nbsp| :diagtext:`creates a copy from type` |nbsp| :placeholder:`C`|
 +---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
 
-+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-|:warning:`warning:` |nbsp| :diagtext:`loop variable` |nbsp| :placeholder:`A` |nbsp| :diagtext:`is always a copy because the range of type` |nbsp| :placeholder:`B` |nbsp| :diagtext:`does not return a reference`|
-+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
-
 
 -Wreadonly-iboutlet-property
 ----------------------------
@@ -13138,6 +13180,10 @@ This diagnostic is enabled by default.
 |:warning:`warning:` |nbsp| :diagtext:`the flag '`:placeholder:`A`:diagtext:`' has been deprecated and will be ignored`|
 +----------------------------------------------------------------------------------------------------------------------+
 
++--------------------------------------------------------------------------------------+
+|:warning:`warning:` |nbsp| :diagtext:`ignoring -fdiscard-value-names for LLVM Bitcode`|
++--------------------------------------------------------------------------------------+
+
 
 -Wunused-comparison
 -------------------

commit 4c6e5899859651d5f0907fc4d5752e616c1598c3
Author: Hans Wennborg <hans@chromium.org>
Date:   Fri Feb 28 17:11:03 2020 +0100

    ReleaseNotes: remove in-progress warnings, tidy up a bit

diff --git a/clang-tools-extra/docs/ReleaseNotes.rst b/clang-tools-extra/docs/ReleaseNotes.rst
index 86ff28cfb0f..10a48ea5f86 100644
--- a/clang-tools-extra/docs/ReleaseNotes.rst
+++ b/clang-tools-extra/docs/ReleaseNotes.rst
@@ -1,6 +1,6 @@
-====================================================
-Extra Clang Tools 10.0.0 (In-Progress) Release Notes
-====================================================
+======================================
+Extra Clang Tools 10.0.0 Release Notes
+======================================
 
 .. contents::
    :local:
@@ -8,12 +8,6 @@ Extra Clang Tools 10.0.0 (In-Progress) Release Notes
 
 Written by the `LLVM Team <https://llvm.org/>`_
 
-.. warning::
-
-   These are in-progress notes for the upcoming Extra Clang Tools 10 release.
-   Release notes for previous releases can be found on
-   `the Download Page <https://releases.llvm.org/download.html>`_.
-
 Introduction
 ============
 
@@ -27,11 +21,6 @@ For more information about Clang or LLVM, including information about
 the latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or
 the `LLVM Web Site <https://llvm.org>`_.
 
-Note that if you are reading this file from a Subversion checkout or the
-main Clang web page, this document applies to the *next* release, not
-the current one. To see the release notes for a specific release, please
-see the `releases page <https://llvm.org/releases/>`_.
-
 What's New in Extra Clang Tools 10.0.0?
 =======================================
 
@@ -39,10 +28,6 @@ Some of the major new features and improvements to Extra Clang Tools are listed
 here. Generic improvements to Extra Clang Tools as a whole or to its underlying
 infrastructure are described first, followed by tool-specific sections.
 
-Major New Features
-------------------
-
-...
 
 Improvements to clangd
 ----------------------
@@ -59,10 +44,10 @@ Improvements to clangd
 
 - clangd can be more easily used remotely or in a docker container.
 
-  The `--path-mappings` flag translates between local and remote paths.
+  The ``--path-mappings`` flag translates between local and remote paths.
 
 - Experimental support for renaming across files (behind the
-  `--cross-file-rename` flag).
+  ``--cross-file-rename`` flag).
 
 - Hover now exposes more information, including the type of symbols and the
   value of constant expressions.
@@ -81,7 +66,7 @@ Improvements to clangd
 - Semantic highlighting is more robust, highlights more types of tokens, and
   as an extension provides information about inactive preprocessor regions.
 
-- Code completion results now include an extension field `score`.
+- Code completion results now include an extension field ``score``.
 
   This allows clients to incorporate clangd quality signals when re-ranking code
   completion after client-side fuzzy-matching.
@@ -97,16 +82,6 @@ Improvements to clang-doc
 
 - :doc:`clang-doc <clang-doc>` now generates documentation in HTML format.
 
-Improvements to clang-query
----------------------------
-
-The improvements are...
-
-Improvements to clang-rename
-----------------------------
-
-The improvements are...
-
 Improvements to clang-tidy
 --------------------------
 
@@ -116,7 +91,7 @@ New checks
 - New :doc:`bugprone-bad-signal-to-kill-thread
   <clang-tidy/checks/bugprone-bad-signal-to-kill-thread>` check.
 
-  Finds ``pthread_kill`` function calls when a thread is terminated by 
+  Finds ``pthread_kill`` function calls when a thread is terminated by
   raising ``SIGTERM`` signal.
 
 - New :doc:`bugprone-dynamic-static-initializers
@@ -211,7 +186,7 @@ New checks
 - New :doc:`readability-qualified-auto
   <clang-tidy/checks/readability-qualified-auto>` check.
 
-  Adds pointer and ``const`` qualifications to ``auto``-typed variables 
+  Adds pointer and ``const`` qualifications to ``auto``-typed variables
   that are deduced to pointers and ``const`` pointers.
 
 - New :doc:`readability-redundant-access-specifiers
@@ -296,25 +271,6 @@ Renamed checks
 - The 'objc-avoid-spinlock' check was renamed to :doc:`darwin-avoid-spinlock
   <clang-tidy/checks/darwin-avoid-spinlock>`
 
-Improvements to include-fixer
------------------------------
-
-The improvements are...
-
-Improvements to clang-include-fixer
------------------------------------
-
-The improvements are...
-
-Improvements to modularize
---------------------------
-
-The improvements are...
-
-Improvements to pp-trace
-------------------------
-
-The improvements are...
 
 Clang-tidy visual studio plugin
 -------------------------------
diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index b5415a03354..86668d9f77e 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -1,6 +1,6 @@
-========================================
-Clang 10.0.0 (In-Progress) Release Notes
-========================================
+==========================
+Clang 10.0.0 Release Notes
+==========================
 
 .. contents::
    :local:
@@ -8,11 +8,6 @@ Clang 10.0.0 (In-Progress) Release Notes
 
 Written by the `LLVM Team <https://llvm.org/>`_
 
-.. warning::
-
-   These are in-progress notes for the upcoming Clang 10 release.
-   Release notes for previous releases can be found on
-   `the Download Page <https://releases.llvm.org/download.html>`_.
 
 Introduction
 ============
@@ -30,10 +25,6 @@ For more information about Clang or LLVM, including information about the
 latest release, please see the `Clang Web Site <https://clang.llvm.org>`_ or the
 `LLVM Web Site <https://llvm.org>`_.
 
-Note that if you are reading this file from a Subversion checkout or the
-main Clang web page, this document applies to the *next* release, not
-the current one. To see the release notes for a specific release, please
-see the `releases page <https://llvm.org/releases/>`_.
 
 What's New in Clang 10.0.0?
 ===========================
@@ -58,27 +49,33 @@ Improvements to Clang's diagnostics
 
 - -Wtautological-overlap-compare will warn on negative numbers and non-int
   types.
+
 - -Wtautological-compare for self comparisons and
   -Wtautological-overlap-compare will now look through member and array
   access to determine if two operand expressions are the same.
+
 - -Wtautological-bitwise-compare is a new warning group.  This group has the
   current warning which diagnoses the tautological comparison of a bitwise
   operation and a constant. The group also has the new warning which diagnoses
   when a bitwise-or with a non-negative value is converted to a bool, since
   that bool will always be true.
+
 - -Wbitwise-conditional-parentheses will warn on operator precedence issues
   when mixing bitwise-and (&) and bitwise-or (|) operator with the
   conditional operator (?:).
+
 - -Wrange-loop-analysis got several improvements. It no longer warns about a
   copy being made when the result is bound to an rvalue reference. It no longer
   warns when an object of a small, trivially copyable type is copied. The
   warning now offers fixits. Excluding -Wrange-loop-bind-reference it is now
   part of -Wall. To reduce the number of false positives the diagnostic is
   disabled in macros and template instantiations.
+
 - -Wmisleading-indentation has been added. This warning is similar to the GCC
   warning of the same name. It warns about statements that are indented as if
   they were part of a if/else/for/while statement but are not semantically
   part of that if/else/for/while.
+
 - -Wbitwise-op-parentheses and -Wlogical-op-parentheses are disabled by default.
 
 Non-comprehensive list of changes in this release
@@ -98,7 +95,7 @@ Non-comprehensive list of changes in this release
   learned to sanitize pre/post increment/decrement of types with bit width
   smaller than ``int``.
 
-- For X86 target, -march=skylake-avx512, -march=icelake-client,
+* For X86 target, -march=skylake-avx512, -march=icelake-client,
   -march=icelake-server, -march=cascadelake, -march=cooperlake will default to
   not using 512-bit zmm registers in vectorized code unless 512-bit intrinsics
   are used in the source code. 512-bit operations are known to cause the CPUs
@@ -145,12 +142,12 @@ New Compiler Flags
   please let us know if you encounter a situation where you need to specify this
   flag for correct program behavior.
 
-- The `-ffixed-xX` flags now work on RISC-V. These reserve the corresponding
+- The ``-ffixed-xX`` flags now work on RISC-V. These reserve the corresponding
   general-purpose registers.
 
-- RISC-V has added `-mcmodel=medany` and `-mcmodel=medlow` as aliases for
-  `-mcmodel=small` and `-mcmodel=medium` respectively. Preprocessor definitions
-  for `__riscv_cmodel_medlow` and `__riscv_cmodel_medany` have been corrected.
+- RISC-V has added ``-mcmodel=medany`` and ``-mcmodel=medlow`` as aliases for
+  ``-mcmodel=small`` and ``-mcmodel=medium`` respectively. Preprocessor definitions
+  for ``__riscv_cmodel_medlow`` and ``__riscv_cmodel_medany`` have been corrected.
 
 - ``-fmacro-prefix-map=OLD=NEW`` substitutes directory prefix ``OLD`` for
   ``NEW`` in predefined preprocessor macros such as ``__FILE__``. This helps
@@ -173,12 +170,12 @@ future versions of Clang.
 
 - -mmpx used to enable the __MPX__ preprocessor define for the Intel MPX
   instructions. There were no MPX intrinsics.
+
 - -mno-mpx used to disable -mmpx and is the default behavior.
+
 - -fconcepts-ts previously used to enable experimental concepts support. Use
   -std=c++2a instead to enable Concepts support.
 
-- ...
-
 Modified Compiler Flags
 -----------------------
 
@@ -212,11 +209,6 @@ Modified Compiler Flags
 - RISC-V now supports multilibs in baremetal environments. This support does not
   extend to supporting multilib aliases.
 
-New Pragmas in Clang
---------------------
-
-- ...
-
 Attribute Changes in Clang
 --------------------------
 
@@ -247,16 +239,6 @@ Windows Support
   functions using the new ``__declspec(guard(nocf))`` modifier.
 
 
-C Language Changes in Clang
----------------------------
-
-- ...
-
-C11 Feature Support
-^^^^^^^^^^^^^^^^^^^
-
-...
-
 C++ Language Changes in Clang
 -----------------------------
 
@@ -265,11 +247,6 @@ C++ Language Changes in Clang
   how it behaved in previous Clang versions, a warning is emitted for this
   combination.
 
-C++1z Feature Support
-^^^^^^^^^^^^^^^^^^^^^
-
-...
-
 Objective-C Language Changes in Clang
 -------------------------------------
 
@@ -390,10 +367,6 @@ Other improvements:
 - Added basic analysis for use of the uninitialized variables in clauses.
 - Bug fixes.
 
-CUDA Support in Clang
----------------------
-
-- ...
 
 Internal API Changes
 --------------------
@@ -429,12 +402,6 @@ release of Clang. Users of the build system should adjust accordingly.
   statically linking clang's components. This option will reduce the size of
   binary distributions at the expense of compiler performance.
 
-- ...
-
-AST Matchers
-------------
-
-- ...
 
 clang-format
 ------------
@@ -578,25 +545,6 @@ Undefined Behavior Sanitizer (UBSan)
         return getelementpointer_inbounds(base, offset);
       }
 
-Core Analysis Improvements
-==========================
-
-- ...
-
-New Issues Found
-================
-
-- ...
-
-Python Binding Changes
-----------------------
-
-The following methods have been added:
-
--  ...
-
-Significant Known Problems
-==========================
 
 Additional Information
 ======================
diff --git a/libcxx/docs/ReleaseNotes.rst b/libcxx/docs/ReleaseNotes.rst
index 438e36beec4..f57c915a445 100644
--- a/libcxx/docs/ReleaseNotes.rst
+++ b/libcxx/docs/ReleaseNotes.rst
@@ -1,6 +1,6 @@
-=========================================
-Libc++ 10.0.0 (In-Progress) Release Notes
-=========================================
+===========================
+Libc++ 10.0.0 Release Notes
+===========================
 
 .. contents::
    :local:
@@ -8,12 +8,6 @@ Libc++ 10.0.0 (In-Progress) Release Notes
 
 Written by the `Libc++ Team <https://libcxx.llvm.org>`_
 
-.. warning::
-
-   These are in-progress notes for the upcoming libc++ 10 release.
-   Release notes for previous releases can be found on
-   `the Download Page <https://releases.llvm.org/download.html>`_.
-
 Introduction
 ============
 
@@ -27,11 +21,6 @@ be downloaded from the `LLVM releases web site <https://llvm.org/releases/>`_.
 For more information about libc++, please see the `Libc++ Web Site
 <https://libcxx.llvm.org>`_ or the `LLVM Web Site <https://llvm.org>`_.
 
-Note that if you are reading this file from a Subversion checkout or the
-main Libc++ web page, this document applies to the *next* release, not
-the current one. To see the release notes for a specific release, please
-see the `releases page <https://llvm.org/releases/>`_.
-
 What's New in Libc++ 10.0.0?
 ============================
 
@@ -39,10 +28,3 @@ Fixes
 -----
 
 - Fixed use of non-default locales on Windows
-
-New Features
-------------
-
-API Changes
------------
-- ...
diff --git a/lld/docs/ReleaseNotes.rst b/lld/docs/ReleaseNotes.rst
index 7d8599cf173..8513a08e90e 100644
--- a/lld/docs/ReleaseNotes.rst
+++ b/lld/docs/ReleaseNotes.rst
@@ -5,10 +5,6 @@ lld 10.0.0 Release Notes
 .. contents::
     :local:
 
-.. warning::
-   These are in-progress notes for the upcoming LLVM 10.0.0 release.
-   Release notes for previous releases can be found on
-   `the Download Page <https://releases.llvm.org/download.html>`_.
 
 Introduction
 ============
@@ -33,7 +29,7 @@ ELF Improvements
 * New ``elf32btsmipn32_fbsd`` and ``elf32ltsmipn32_fbsd`` emulations
   are supported.
 
-* Relax MIPS ``jalr``and ``jr`` instructions marked by the ``R_MIPS_JALR``
+* Relax MIPS ``jalr`` and ``jr`` instructions marked by the ``R_MIPS_JALR``
   relocation.
 * For certain "undefined symbol" errors, a definition with a close spelling will be suggested.
   (`D67039 <https://reviews.llvm.org/D67039>`_)
@@ -90,10 +86,6 @@ Breaking changes
   could cause subtle bugs.
   (`D70468 <https://reviews.llvm.org/D70468>`_)
 
-COFF Improvements
------------------
-
-* ...
 
 MinGW Improvements
 ------------------
@@ -126,10 +118,6 @@ MinGW Improvements
   (which can happen for the default-null symbol for weak symbols)
   (`1737cc750c46 <https://reviews.llvm.org/rG1737cc750c46>`)
 
-MachO Improvements
-------------------
-
-* Item 1.
 
 WebAssembly Improvements
 ------------------------
diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index 7ca74e37858..07b37fb6c19 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -5,12 +5,6 @@ LLVM 10.0.0 Release Notes
 .. contents::
     :local:
 
-.. warning::
-   These are in-progress notes for the upcoming LLVM 10 release.
-   Release notes for previous releases can be found on
-   `the Download Page <https://releases.llvm.org/download.html>`_.
-
-
 Introduction
 ============
 
@@ -26,21 +20,11 @@ have questions or comments, the `LLVM Developer's Mailing List
 <https://lists.llvm.org/mailman/listinfo/llvm-dev>`_ is a good place to send
 them.
 
-Note that if you are reading this file from a Subversion checkout or the main
-LLVM web page, this document applies to the *next* release, not the current
-one.  To see the release notes for a specific release, please see the `releases
-page <https://llvm.org/releases/>`_.
-
 Non-comprehensive list of changes in this release
 =================================================
-.. NOTE
-   For small 1-3 sentence descriptions, just add an entry at the end of
-   this list. If your description won't fit comfortably in one bullet
-   point (e.g. maybe you would like to give an example of the
-   functionality, or simply have a lot to talk about), see the `NOTE` below
-   for adding a new subsection.
 
 * The ISD::FP_ROUND_INREG opcode and related code was removed from SelectionDAG.
+
 * Enabled MemorySSA as a loop dependency. Since
   `r370957 <https://reviews.llvm.org/rL370957>`_
   (`D58311 <https://reviews.llvm.org/D58311>`_ ``[MemorySSA & LoopPassManager]
@@ -55,22 +39,13 @@ Non-comprehensive list of changes in this release
   AliasSetTracker usage with MemorySSA without any performance penalties.
   The fact that MemorySSA is now preserved by and available in a series of loop
   passes, also opens up opportunities for its use in those respective passes.
+
 * The BasicBlockPass, BBPassManager and all their uses were deleted in
   `this revision <https://reviews.llvm.org/rG9f0ff0b2634bab6a5be8dace005c9eb24d386dd1>`_.
 
 * The LLVM_BUILD_LLVM_DYLIB and LLVM_LINK_LLVM_DYLIB CMake options are no longer
   available on Windows.
 
-.. NOTE
-   If you would like to document a larger change, then you can add a
-   subsection about it right here. You can copy the following boilerplate
-   and un-indent it (the indentation causes it to be inside this comment).
-
-   Special New Feature
-   -------------------
-
-   Makes programs 10x faster by doing Special New Thing.
-
 * As per :ref:`LLVM Language Reference Manual <i_getelementptr>`,
   ``getelementptr inbounds`` can not change the null status of a pointer,
   meaning it can not produce non-null pointer given null base pointer, and
@@ -84,7 +59,6 @@ Non-comprehensive list of changes in this release
   Undefined Behaviour Sanitizer ``-fsanitize=pointer-overflow`` check
   will now catch such cases.
 
-
 * Windows Control Flow Guard: the ``-cfguard`` option now emits CFG checks on
   indirect function calls. The previous behavior is still available with the
   ``-cfguard-nochecks`` option. Note that this feature should always be used
@@ -123,29 +97,29 @@ Changes to the LLVM IR
   that correctly converted 80-90% of Clang tests. Some manual work will almost
   certainly still be needed.
 
-* A new `freeze` instruction is added. The `freeze` instruction is used to stop
+* A new ``freeze`` instruction is added. The ``freeze`` instruction is used to stop
   IR-level propagation of undef and poison values. Currently its support is
   preliminary; a freeze-equivalent operation for SelDag/MIR needs to be added.
 
 
-Changes to building LLVM
-------------------------
-
-...
 
 Changes to the AArch64 Backend
 ------------------------------
 
-- Added support for Cortex-A65, Cortex-A65AE, Neoverse E1 and Neoverse N1 cores.
-- With a few more bugs fixed in the LLVM 10 release, clang-cl can now target windows-on-Arm well, demonstrated by building complex pieces of software such as Chromium and the Electron framework.
-- Support for -fpatchable-function-entry was added.
+* Added support for Cortex-A65, Cortex-A65AE, Neoverse E1 and Neoverse N1 cores.
+
+* With a few more bugs fixed in the LLVM 10 release, clang-cl can now target windows-on-Arm well, demonstrated by building complex pieces of software such as Chromium and the Electron framework.
+
+* Support for -fpatchable-function-entry was added.
 
 Changes to the ARM Backend
 --------------------------
 
-- Optimized Armv8.1-M code generation, including generating Low Overhead Loops.
-- Added auto-vectorization for the Armv8.1-M MVE vector extension.
-- Support was added for inline asm constraints s,j,x,N,O.
+* Optimized Armv8.1-M code generation, including generating Low Overhead Loops.
+
+* Added auto-vectorization for the Armv8.1-M MVE vector extension.
+
+* Support was added for inline asm constraints s,j,x,N,O.
 
 
 Changes to the MIPS Target
@@ -153,18 +127,25 @@ Changes to the MIPS Target
 
 * Improved support for ``octeon`` and added support for ``octeon+``
   MIPS-family CPU.
+
 * ``min``, ``max``, ``umin``, ``umax`` atomics now supported on MIPS targets.
+
 * Now PC-relative relocations are generated for ``.eh_frame`` sections when
   possible. That allows to link MIPS binaries without having to pass the
   ``-Wl,-z,notext`` option.
+
 * Fix evaluating J-format branch (``j``, ``jal``, ...) targets when the
   instruction is not in the first 256 MB region.
+
 * Fixed ``jal``, ``sc``, ``scs``, ``ll``, ``lld``, ``la``, ``lw``, ``sw``
   instructions expanding. Now they accept more types of expression as arguments,
   correctly handle load/store for ``XGOT`` model, expand using less instructions
   or registers.
+
 * Initial MIPS support has been added to ``llvm-exegesis``.
+
 * Generates ``_mcount`` calls using proper MIPS ABI.
+
 * Improved support of GlobalISel instruction selection framework. This feature
   is still in experimental state for MIPS targets though.
 
@@ -174,7 +155,9 @@ Changes to the PowerPC Target
 Optimization:
 
   *  Improved register pressure estimates in the loop vectorizer based on type
+
   *  Improved the PowerPC cost model for the vectorizer
+
   *  Enabled vectorization of math routines on PowerPC using MASSV (Mathematical Acceleration SubSystem) library
 
 compiler-rt:
@@ -184,14 +167,19 @@ compiler-rt:
 Codegen:
 
    *  Optimized memory access instructions in loops (pertaining to update-form instructions and address computation)
+
    *  Added options to disable hoisting instructions to hotter blocks based on statically or profile-based block hotness estimates
+
    *  Code generation improvements (particularly with floating point and vector code as well as handling condition registers)
+
    *  Various infrastructural improvements, code refactoring, and bug fixes
+
    *  Optimized handling of control flow based on multiple comparison of same values
 
 Tools:
 
   *   llvm-readobj supports displaying file header, section headers, symbol table and relocation entries for XCOFF object files
+
   *   llvm-objdump supports disassembling physical sections for XCOFF object files
 
 
@@ -200,10 +188,14 @@ Changes to the SystemZ Target
 
 * Added support for the ``-march=z15`` and ``-mtune=z15`` command line options
   (as aliases to the existing ``-march=arch13`` and ``-mtune=arch13`` options).
+
 * Added support for the ``-march=native`` command line option.
+
 * Added support for the ``-mfentry``, ``-mnop-mcount``, and ``-mrecord-mcount``
   command line options.
+
 * Added support for the GHC calling convention.
+
 * Miscellaneous codegen enhancements, in particular to enable better
   reuse of condition code values and improved use of conditional
   move instructions.
@@ -217,38 +209,39 @@ Changes to the X86 Target
   now stored in the lower bits of an xmm register and the upper bits are
   undefined. Previously the elements were spread apart with undefined bits in
   between them.
+
 * v32i8 and v64i8 vectors with AVX512F enabled, but AVX512BW disabled will now
   be passed in ZMM registers for calls and returns. Previously they were passed
   in two YMM registers. Old behavior can be enabled by passing
   -x86-enable-old-knl-abi
+
 * -mprefer-vector-width=256 is now the default behavior skylake-avx512 and later
   Intel CPUs. This tries to limit the use of 512-bit registers which can cause a
   decrease in CPU frequency on these CPUs. This can be re-enabled by passing
   -mprefer-vector-width=512 to clang or passing -mattr=-prefer-256-bit to llc.
+
 * Deprecated the mpx feature flag for the Intel MPX instructions. There were no
   intrinsics for this feature. This change only this effects the results
   returned by getHostCPUFeatures on CPUs that implement the MPX instructions.
+
 * The feature flag fast-partial-ymm-or-zmm-write which previously disabled
   vzeroupper insertion has been removed. It has been replaced with a vzeroupper
   feature flag which has the opposite polarity. So -vzeroupper has the same
   effect as +fast-partial-ymm-or-zmm-write.
 
-Changes to the AMDGPU Target
------------------------------
-
-Changes to the AVR Target
------------------------------
-
- During this release ...
 
 Changes to the WebAssembly Target
 ---------------------------------
 
 * __attribute__((used)) no longer implies that a symbol is exported, for
   consistency with other targets.
+
 * Multivalue function signatures are now supported in WebAssembly object files
-* The new `atomic.fence` instruction is now supported
+
+* The new ``atomic.fence`` instruction is now supported
+
 * Thread-Local Storage (TLS) is now supported.
+
 * SIMD support is significantly expanded.
 
 Changes to the Windows Target
@@ -260,69 +253,94 @@ Changes to the RISC-V Target
 ----------------------------
 
 New Features:
+
 * The Machine Outliner is now supported, but not enabled by default.
+
 * Shrink-wrapping is now supported.
+
 * The Machine Scheduler has been enabled and scheduler descriptions for the
   Rocket micro-architecture have been added, covering both 32- and 64-bit Rocket
   cores.
+
 * This release lays the groundwork for enabling LTO in a future LLVM release.
-  In particular, LLVM now uses a new `target-abi` module metadata item to
+  In particular, LLVM now uses a new ``target-abi`` module metadata item to
   represent the chosen RISC-V psABI variant. Frontends should add this module
   flag to prevent ABI lowering problems when LTO is enabled in a future LLVM
   release.
+
 * Support has been added for assembling RVC HINT instructions.
+
 * Added code lowering for half-precision floats.
-* The `fscsr` and `frcsr` (`fssr`, `frsr`) obsolete aliases have been added to
+
+* The ``fscsr`` and ``frcsr`` (``fssr``, ``frsr``) obsolete aliases have been added to
   the assembler for use in legacy code.
+
 * The stack can now be realigned even when there are variable-sized objects in
   the same frame.
+
 * fastcc is now supported. This is a more efficient, unstandardised, calling
   convention for calls to private leaf functions in the same IR module.
-* llvm-objdump now supports `-M no-aliases` and `-M numeric` for altering the
+
+* llvm-objdump now supports ``-M no-aliases`` and ``-M numeric`` for altering the
   dumped assembly. These match the behaviour of GNU objdump, respectively
   disabling instruction aliases and printing the numeric register names rather
   than the ABI register names.
 
 Improvements:
 * Trap and Debugtrap now lower to RISC-V-specific trap instructions.
+
 * LLVM IR Inline assembly now supports using ABI register names and using
   floating point registers in constraints.
+
 * Stack Pointer adjustments have been changed to better match RISC-V's immediates.
-* `ra` (`x1`) can now be used as a callee-saved register.
+
+* ``ra`` (``x1``) can now be used as a callee-saved register.
+
 * The assembler now suggests spelling corrections for unknown assembly
   mnemonics.
+
 * Stack offsets of greater than 32-bits are now accepted on RV64.
+
 * Variadic functions can now be tail-call optimised, as long as they do not use
   stack memory for passing arguments.
+
 * Code generation has been changed for 32-bit arithmetic operations on RV64 to
   reduce sign-extensions.
 
 Bug Fixes:
+
 * There was an issue with register preservation after calls in interrupt
   handlers, where some registers were marked as preserved even though they were
   not being preserved by the call. This has been corrected, and now only
   callee-saved registers are live over a function call in an interrupt handler
   (just like calls in regular functions).
+
 * Atomic instructions now only accept GPRs (plus an offset) in memory operands.
+
 * Fixed some issues with evaluation of relocations and fixups.
+
 * The error messages around missing RISC-V extensions in the assembler have been
   improved.
+
 * The error messages around unsupported relocations have been improved.
+
 * Non-PIC code no longer forces Local Exec TLS.
+
 * There have been some small changes to the code generation for atomic
   operations.
+
 * RISC-V no longer emits incorrect CFI directives in function prologs and
   epilogs.
+
 * RV64 no longer clears the upper bits when returning complex types from
   libcalls using the LP64 psABI.
 
 Compiler-RT:
+
 * RISC-V (both 64-bit and 32-bit) is now supported by compiler-rt, allowing
   crtbegin and crtend to be built.
-* The Sanitizers now support 64-bit RISC-V on linux.
 
-Changes to the OCaml bindings
------------------------------
+* The Sanitizers now support 64-bit RISC-V on linux.
 
 
 
@@ -340,8 +358,6 @@ Changes to the Go bindings
   to Debug information in LLVM IR.
 
 
-Changes to the DAG infrastructure
----------------------------------
 
 Changes to LLDB
 ===============
@@ -354,7 +370,7 @@ Changes to LLDB
 
 * Tab completions for command options now also provide a description for each option.
 
-* Fixed that printing structs/classes with the `expression` command sometimes did not
+* Fixed that printing structs/classes with the ``expression`` command sometimes did not
   print the members/contents of the class.
 
 * Improved support for using classes with bit-field members in the expression evaluator.

commit dce2ef9e642127d0e4809fb4ecc682b1152bf98b
Author: Michael Kruse <llvm-project@meinersbur.de>
Date:   Wed Feb 26 14:26:04 2020 -0600

    [Polly][docs] Polly release notes.
    
    Highlight work that has been done during the development window. After
    cherry-picking D72372 to fix PR45001 no workaround is necessary anymore,
    but the generalization of the linking mechanism is still worth pointing
    out.

diff --git a/polly/docs/ReleaseNotes.rst b/polly/docs/ReleaseNotes.rst
index 1d9aacc9aa6..7d5ddbbaec1 100644
--- a/polly/docs/ReleaseNotes.rst
+++ b/polly/docs/ReleaseNotes.rst
@@ -1,13 +1,16 @@
-=============================
-Release Notes 10.0 (upcoming)
-=============================
+==================
+Release Notes 10.0
+==================
 
 In Polly 10 the following important changes have been incorporated.
 
-.. warning::
+- The mechanism that Polly uses to link itself statically into the opt,
+  bugpoint and clang executables has been generalized such that it can
+  be used by other pass plugins. An example plugin "Bye" has been added
+  to LLVM to illustate the mechanism.
 
-  These releaes notes are for the next release of Polly and describe
-  the new features that have recently been committed to our development
-  branch.
-
-- Change ...
+- Some ScopInfo methods that are only relevant during SCoP construction
+  have been moved into the ScopBuilder class. In addition to making it
+  clearer which methods can only be used during the construction phase,
+  the refactoring helps shrinking the size of the public header
+  ScopInfo.h.

commit 5405c262a4abec1a9cf0b8b89aabbf529209262a
Author: Michael Spencer <bigcheesegs@gmail.com>
Date:   Fri Feb 28 14:39:49 2020 -0800

    [llvm][Support][modulemap] Exclude WindowsSupport.h from the LLVM_Util module
    
    rG01f9abbb50b1 moved WindowsSupport.h to include/llvm/Support/Windows/
    
    This is a problem because the modulemap include all of the Support and
    ADT directories, thus any use of any header in Support or ADT would
    cause the compiler to try to build WindowsSupport.h, which only works
    on Windows.
    
    Fix this by explicitly excluding WindowsSupport.h from the LLVM_Util
    module.
    
    (cherry picked from commit 0b6abe428164c38c7dec6c539e454cfd671067a4)

diff --git a/llvm/include/llvm/module.modulemap b/llvm/include/llvm/module.modulemap
index 05de40698e3..d281682ae00 100644
--- a/llvm/include/llvm/module.modulemap
+++ b/llvm/include/llvm/module.modulemap
@@ -380,6 +380,9 @@ module LLVM_Utils {
 
     umbrella "Support"
     module * { export * }
+    
+    // Exclude this; it should only be used on Windows.
+    exclude header "Support/Windows/WindowsSupport.h"
 
     // Exclude these; they are fundamentally non-modular.
     exclude header "Support/PluginLoader.h"

commit f5fd8a37c18439102eb30c85dadac68c260a1a0d
Author: Reid Kleckner <rnk@google.com>
Date:   Fri Feb 28 17:21:50 2020 -0800

    Try to fix WindowsManifest CMake logic on Windows
    
    CMake is complaining about the "^" regex if the prefixes are empty
    strings.
    
    (cherry picked from commit e441a584f3f7d743ab77031a47d9ad60ee56b53d)

diff --git a/llvm/lib/WindowsManifest/CMakeLists.txt b/llvm/lib/WindowsManifest/CMakeLists.txt
index 8cfea1282ad..7ccc17ad577 100644
--- a/llvm/lib/WindowsManifest/CMakeLists.txt
+++ b/llvm/lib/WindowsManifest/CMakeLists.txt
@@ -9,10 +9,12 @@ if(LIBXML2_LIBRARIES)
   target_link_libraries(LLVMWindowsManifest PUBLIC ${LIBXML2_LIBRARIES})
 
   get_filename_component(xml2_library ${LIBXML2_LIBRARIES} NAME)
-  if(xml2_library MATCHES "^${CMAKE_STATIC_LIBRARY_PREFIX}.*${CMAKE_STATIC_LIBRARY_SUFFIX}$")
+  if (CMAKE_STATIC_LIBRARY_PREFIX AND
+      xml2_library MATCHES "^${CMAKE_STATIC_LIBRARY_PREFIX}.*${CMAKE_STATIC_LIBRARY_SUFFIX}$")
     string(REGEX REPLACE "^${CMAKE_STATIC_LIBRARY_PREFIX}" "" xml2_library ${xml2_library})
     string(REGEX REPLACE "${CMAKE_STATIC_LIBRARY_SUFFIX}$" "" xml2_library ${xml2_library})
-  elseif(xml2_library MATCHES "^${CMAKE_SHARED_LIBRARY_PREFIX}.*${CMAKE_SHARED_LIBRARY_SUFFIX}$")
+  elseif (CMAKE_SHARED_LIBRARY_PREFIX AND
+          xml2_library MATCHES "^${CMAKE_SHARED_LIBRARY_PREFIX}.*${CMAKE_SHARED_LIBRARY_SUFFIX}$")
     string(REGEX REPLACE "^${CMAKE_SHARED_LIBRARY_PREFIX}" "" xml2_library ${xml2_library})
     string(REGEX REPLACE "${CMAKE_SHARED_LIBRARY_SUFFIX}$" "" xml2_library ${xml2_library})
   endif()

commit 499b1699621eb0aed9bec7017c1db60ccad30ae4
Author: Petr Hosek <phosek@google.com>
Date:   Wed Feb 5 19:07:43 2020 -0800

    [CMake] Use PUBLIC link mode for static libraries
    
    Using INTERFACE prevents the use of imported libraries as we've done
    in 00b3d49 because these aren't linked against the target, they're
    only made part of the interface. This doesn't affect the output since
    static libraries aren't being linked into, but it enables the use of
    imported libraries.
    
    Differential Revision: https://reviews.llvm.org/D74106
    
    (cherry picked from commit 50a6d3a6486d81d21a2c31ce8522321e19bed35e)

diff --git a/llvm/cmake/modules/AddLLVM.cmake b/llvm/cmake/modules/AddLLVM.cmake
index 8d674f93542..fd69786544a 100644
--- a/llvm/cmake/modules/AddLLVM.cmake
+++ b/llvm/cmake/modules/AddLLVM.cmake
@@ -602,7 +602,7 @@ function(llvm_add_library name)
   endif()
 
   if(ARG_STATIC)
-    set(libtype INTERFACE)
+    set(libtype PUBLIC)
   else()
     # We can use PRIVATE since SO knows its dependent libs.
     set(libtype PRIVATE)

commit 917119e95aa1e4ce99395f93f2eb696613c556ff
Author: Petr Hosek <phosek@google.com>
Date:   Thu Feb 6 15:24:07 2020 -0800

    [CMake] Link against ZLIB::ZLIB
    
    This is the imported target that find_package(ZLIB) defines.
    
    Differential Revision: https://reviews.llvm.org/D74176
    
    (cherry picked from commit 2181bf40d87165ff4c208b46b135be823eef5c55)

diff --git a/llvm/lib/Support/CMakeLists.txt b/llvm/lib/Support/CMakeLists.txt
index 26332d4f539..e23f7989e77 100644
--- a/llvm/lib/Support/CMakeLists.txt
+++ b/llvm/lib/Support/CMakeLists.txt
@@ -1,5 +1,5 @@
 if(LLVM_ENABLE_ZLIB)
-  set(system_libs ${ZLIB_LIBRARY})
+  set(imported_libs ZLIB::ZLIB)
 endif()
 
 if( MSVC OR MINGW )
@@ -186,10 +186,29 @@ add_llvm_component_library(LLVMSupport
   ${LLVM_MAIN_INCLUDE_DIR}/llvm/ADT
   ${LLVM_MAIN_INCLUDE_DIR}/llvm/Support
   ${Backtrace_INCLUDE_DIRS}
-  LINK_LIBS ${system_libs} ${delayload_flags} ${Z3_LINK_FILES}
+  LINK_LIBS ${system_libs} ${imported_libs} ${delayload_flags} ${Z3_LINK_FILES}
   )
 
-set_property(TARGET LLVMSupport PROPERTY LLVM_SYSTEM_LIBS "${system_libs}")
+set(llvm_system_libs ${system_libs})
+
+if(LLVM_ENABLE_ZLIB)
+  string(TOUPPER ${CMAKE_BUILD_TYPE} build_type)
+  get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION_${build_type})
+  if(NOT zlib_library)
+    get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION)
+  endif()
+  get_filename_component(zlib_library ${zlib_library} NAME)
+  if(zlib_library MATCHES "^${CMAKE_STATIC_LIBRARY_PREFIX}.*${CMAKE_STATIC_LIBRARY_SUFFIX}$")
+    STRING(REGEX REPLACE "^${CMAKE_STATIC_LIBRARY_PREFIX}" "" zlib_library ${zlib_library})
+    STRING(REGEX REPLACE "${CMAKE_STATIC_LIBRARY_SUFFIX}$" "" zlib_library ${zlib_library})
+  elseif(zlib_library MATCHES "^${CMAKE_SHARED_LIBRARY_PREFIX}.*${CMAKE_SHARED_LIBRARY_SUFFIX}$")
+    STRING(REGEX REPLACE "^${CMAKE_SHARED_LIBRARY_PREFIX}" "" zlib_library ${zlib_library})
+    STRING(REGEX REPLACE "${CMAKE_SHARED_LIBRARY_SUFFIX}$" "" zlib_library ${zlib_library})
+  endif()
+  set(llvm_system_libs ${llvm_system_libs} "${zlib_library}")
+endif()
+
+set_property(TARGET LLVMSupport PROPERTY LLVM_SYSTEM_LIBS "${llvm_system_libs}")
 
 if(LLVM_WITH_Z3)
   target_include_directories(LLVMSupport SYSTEM

commit 6b16ce944fef5f3b30b7dcc001b3af478e038668
Author: Reid Kleckner <rnk@google.com>
Date:   Sun Mar 1 08:45:22 2020 -0800

    Attempt to fix ZLIB CMake logic on Windows
    
    CMake doesn't seem to like it when you regex search for "^".
    
    (cherry picked from commit 1079c68aa0fdb14d270a31c0df49a2afc5ed2485)

diff --git a/llvm/lib/Support/CMakeLists.txt b/llvm/lib/Support/CMakeLists.txt
index e23f7989e77..5c656164e77 100644
--- a/llvm/lib/Support/CMakeLists.txt
+++ b/llvm/lib/Support/CMakeLists.txt
@@ -198,10 +198,12 @@ if(LLVM_ENABLE_ZLIB)
     get_property(zlib_library TARGET ZLIB::ZLIB PROPERTY LOCATION)
   endif()
   get_filename_component(zlib_library ${zlib_library} NAME)
-  if(zlib_library MATCHES "^${CMAKE_STATIC_LIBRARY_PREFIX}.*${CMAKE_STATIC_LIBRARY_SUFFIX}$")
+  if(CMAKE_STATIC_LIBRARY_PREFIX AND
+     zlib_library MATCHES "^${CMAKE_STATIC_LIBRARY_PREFIX}.*${CMAKE_STATIC_LIBRARY_SUFFIX}$")
     STRING(REGEX REPLACE "^${CMAKE_STATIC_LIBRARY_PREFIX}" "" zlib_library ${zlib_library})
     STRING(REGEX REPLACE "${CMAKE_STATIC_LIBRARY_SUFFIX}$" "" zlib_library ${zlib_library})
-  elseif(zlib_library MATCHES "^${CMAKE_SHARED_LIBRARY_PREFIX}.*${CMAKE_SHARED_LIBRARY_SUFFIX}$")
+  elseif(CMAKE_SHARED_LIBRARY_PREFIX AND
+         zlib_library MATCHES "^${CMAKE_SHARED_LIBRARY_PREFIX}.*${CMAKE_SHARED_LIBRARY_SUFFIX}$")
     STRING(REGEX REPLACE "^${CMAKE_SHARED_LIBRARY_PREFIX}" "" zlib_library ${zlib_library})
     STRING(REGEX REPLACE "${CMAKE_SHARED_LIBRARY_SUFFIX}$" "" zlib_library ${zlib_library})
   endif()

commit 99e5b2ff9df5ca4c7fe13b63f60d953058cd9ca3
Author: Krasimir Georgiev <krasimir@google.com>
Date:   Fri Jan 17 13:26:24 2020 +0100

    clang-format: fix spacing in `operator const char*()`
    
    Summary:
    Revision a75f8d98d7ac9e557b238a229a9a2647c71feed1 fixed spacing for operators,
    but caused the const and non-const versions to diverge:
    ```
    // With Style.PointerAlignment = FormatStyle::PAS_Left:
    
    struct A {
      operator char*() { return ""; }
      operator const char *() const { return ""; }
    };
    
    ```
    The code was checking if the type specifier was directly preceded by `operator`.
    However there could be comments and `const/volatile` in between.
    
    Reviewers: mprobst
    
    Reviewed By: mprobst
    
    Subscribers: cfe-commits
    
    Tags: #clang
    
    Differential Revision: https://reviews.llvm.org/D72911
    
    (cherry picked from commit 33463cfba2be7c8d6c08e666123cc34f114a1f3e)

diff --git a/clang/lib/Format/TokenAnnotator.cpp b/clang/lib/Format/TokenAnnotator.cpp
index 88564e02f23..70bcd7048c5 100644
--- a/clang/lib/Format/TokenAnnotator.cpp
+++ b/clang/lib/Format/TokenAnnotator.cpp
@@ -2707,10 +2707,17 @@ bool TokenAnnotator::spaceRequiredBetween(const AnnotatedLine &Line,
     return false;
   if (Right.isOneOf(tok::star, tok::amp, tok::ampamp) &&
       (Left.is(tok::identifier) || Left.isSimpleTypeSpecifier()) &&
-      Left.Previous && Left.Previous->is(tok::kw_operator))
-    // Space between the type and the *
-    // operator void*(), operator char*(), operator Foo*() dependant
-    // on PointerAlignment style.
+      // Space between the type and the * in:
+      //   operator void*()
+      //   operator char*()
+      //   operator /*comment*/ const char*()
+      //   operator volatile /*comment*/ char*()
+      //   operator Foo*()
+      // dependent on PointerAlignment style.
+      Left.Previous &&
+      (Left.Previous->endsSequence(tok::kw_operator) ||
+       Left.Previous->endsSequence(tok::kw_const, tok::kw_operator) ||
+       Left.Previous->endsSequence(tok::kw_volatile, tok::kw_operator)))
     return (Style.PointerAlignment != FormatStyle::PAS_Left);
   const auto SpaceRequiredForArrayInitializerLSquare =
       [](const FormatToken &LSquareTok, const FormatStyle &Style) {
diff --git a/clang/unittests/Format/FormatTest.cpp b/clang/unittests/Format/FormatTest.cpp
index c47e2e9a116..a5a26b5c1e8 100644
--- a/clang/unittests/Format/FormatTest.cpp
+++ b/clang/unittests/Format/FormatTest.cpp
@@ -15008,6 +15008,9 @@ TEST_F(FormatTest, OperatorSpacing) {
   Style.PointerAlignment = FormatStyle::PAS_Left;
   verifyFormat("Foo::operator*();", Style);
   verifyFormat("Foo::operator void*();", Style);
+  verifyFormat("Foo::operator/*comment*/ void*();", Style);
+  verifyFormat("Foo::operator/*a*/ const /*b*/ void*();", Style);
+  verifyFormat("Foo::operator/*a*/ volatile /*b*/ void*();", Style);
   verifyFormat("Foo::operator()(void*);", Style);
   verifyFormat("Foo::operator*(void*);", Style);
   verifyFormat("Foo::operator*();", Style);
@@ -15015,6 +15018,9 @@ TEST_F(FormatTest, OperatorSpacing) {
 
   verifyFormat("Foo::operator&();", Style);
   verifyFormat("Foo::operator void&();", Style);
+  verifyFormat("Foo::operator/*comment*/ void&();", Style);
+  verifyFormat("Foo::operator/*a*/ const /*b*/ void&();", Style);
+  verifyFormat("Foo::operator/*a*/ volatile /*b*/ void&();", Style);
   verifyFormat("Foo::operator()(void&);", Style);
   verifyFormat("Foo::operator&(void&);", Style);
   verifyFormat("Foo::operator&();", Style);
@@ -15022,6 +15028,9 @@ TEST_F(FormatTest, OperatorSpacing) {
 
   verifyFormat("Foo::operator&&();", Style);
   verifyFormat("Foo::operator void&&();", Style);
+  verifyFormat("Foo::operator/*comment*/ void&&();", Style);
+  verifyFormat("Foo::operator/*a*/ const /*b*/ void&&();", Style);
+  verifyFormat("Foo::operator/*a*/ volatile /*b*/ void&&();", Style);
   verifyFormat("Foo::operator()(void&&);", Style);
   verifyFormat("Foo::operator&&(void&&);", Style);
   verifyFormat("Foo::operator&&();", Style);

commit 0bf4795d069642afe2a430521f3549e425f092c9
Author: Reid Kleckner <rnk@google.com>
Date:   Sun Mar 1 07:47:55 2020 -0800

    [WinEH] Fix inttoptr+phi optimization in presence of catchswitch
    
    getFirstInsertionPt's return value must be checked for validity before
    casting it to Instruction*. Don't attempt to insert casts after a phi in
    a catchswitch block.
    
    Fixes PR45033, introduced in D37832.
    
    Reviewed By: davidxl, hfinkel
    
    Differential Revision: https://reviews.llvm.org/D75381
    
    (cherry picked from commit 1adbe86d87bd4ecffc73ab17c7da56f44816f424)

diff --git a/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp b/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
index 74e015a4f1d..6c2aead5a75 100644
--- a/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
+++ b/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
@@ -218,13 +218,21 @@ Instruction *InstCombiner::FoldIntegerTypedPHI(PHINode &PN) {
     return nullptr;
 
   // If any of the operand that requires casting is a terminator
-  // instruction, do not do it.
+  // instruction, do not do it. Similarly, do not do the transform if the value
+  // is PHI in a block with no insertion point, for example, a catchswitch
+  // block, since we will not be able to insert a cast after the PHI.
   if (any_of(AvailablePtrVals, [&](Value *V) {
         if (V->getType() == IntToPtr->getType())
           return false;
-
         auto *Inst = dyn_cast<Instruction>(V);
-        return Inst && Inst->isTerminator();
+        if (!Inst)
+          return false;
+        if (Inst->isTerminator())
+          return true;
+        auto *BB = Inst->getParent();
+        if (isa<PHINode>(Inst) && BB->getFirstInsertionPt() == BB->end())
+          return true;
+        return false;
       }))
     return nullptr;
 
@@ -264,8 +272,10 @@ Instruction *InstCombiner::FoldIntegerTypedPHI(PHINode &PN) {
       if (auto *IncomingI = dyn_cast<Instruction>(IncomingVal)) {
         BasicBlock::iterator InsertPos(IncomingI);
         InsertPos++;
+        BasicBlock *BB = IncomingI->getParent();
         if (isa<PHINode>(IncomingI))
-          InsertPos = IncomingI->getParent()->getFirstInsertionPt();
+          InsertPos = BB->getFirstInsertionPt();
+        assert(InsertPos != BB->end() && "should have checked above");
         InsertNewInstBefore(CI, *InsertPos);
       } else {
         auto *InsertBB = &IncomingBB->getParent()->getEntryBlock();
diff --git a/llvm/test/Transforms/InstCombine/intptr8.ll b/llvm/test/Transforms/InstCombine/intptr8.ll
new file mode 100644
index 00000000000..dd2cc2053d1
--- /dev/null
+++ b/llvm/test/Transforms/InstCombine/intptr8.ll
@@ -0,0 +1,77 @@
+; RUN: opt < %s  -instcombine -S | FileCheck %s
+
+; PR45033: Don't try to insert a cast into a catchswich block.
+
+target datalayout = "e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
+target triple = "x86_64-pc-windows-msvc"
+
+%struct.intrusive_ptr = type { %struct.C* }
+%struct.C = type { %struct.intrusive_ref_counter }
+%struct.intrusive_ref_counter = type { i32 }
+
+declare dso_local %struct.C* @"?mk@@YAPEAUC@@XZ"() #3
+declare dso_local void @"?intrusive_ptr_release@@YAXPEBUintrusive_ref_counter@@@Z"(%struct.intrusive_ref_counter*) #3
+declare dso_local void @"?terminate@@YAXXZ"()
+declare dso_local i32 @__CxxFrameHandler3(...)
+
+define dso_local void @"?crash@@YAXXZ"() local_unnamed_addr #0 personality i8* bitcast (i32 (...)* @__CxxFrameHandler3 to i8*) {
+entry:
+  %call1 = invoke %struct.C* @"?mk@@YAPEAUC@@XZ"()
+          to label %invoke.cont2 unwind label %catch.dispatch
+
+invoke.cont2:                                     ; preds = %entry
+  %0 = ptrtoint %struct.C* %call1 to i64
+  %call5 = invoke %struct.C* @"?mk@@YAPEAUC@@XZ"()
+          to label %try.cont unwind label %catch.dispatch
+
+catch.dispatch:                                   ; preds = %invoke.cont2, %entry
+  %a.sroa.0.0 = phi i64 [ %0, %invoke.cont2 ], [ 0, %entry ]
+  %1 = catchswitch within none [label %catch] unwind label %ehcleanup
+
+catch:                                            ; preds = %catch.dispatch
+  %2 = catchpad within %1 [i8* null, i32 64, i8* null]
+  catchret from %2 to label %try.cont
+
+try.cont:                                         ; preds = %invoke.cont2, %catch
+  %a.sroa.0.1 = phi i64 [ %0, %invoke.cont2 ], [ %a.sroa.0.0, %catch ]
+  %3 = inttoptr i64 %a.sroa.0.1 to %struct.C*
+  %tobool.i3 = icmp eq %struct.C* %3, null
+  br i1 %tobool.i3, label %"??1?$intrusive_ptr@UC@@@@QEAA@XZ.exit6", label %if.then.i4
+
+if.then.i4:                                       ; preds = %try.cont
+  %4 = getelementptr %struct.C, %struct.C* %3, i64 0, i32 0
+  invoke void @"?intrusive_ptr_release@@YAXPEBUintrusive_ref_counter@@@Z"(%struct.intrusive_ref_counter* %4)
+          to label %"??1?$intrusive_ptr@UC@@@@QEAA@XZ.exit6" unwind label %terminate.i5
+
+terminate.i5:                                     ; preds = %if.then.i4
+  %5 = cleanuppad within none []
+  call void @"?terminate@@YAXXZ"() #4 [ "funclet"(token %5) ]
+  unreachable
+
+"??1?$intrusive_ptr@UC@@@@QEAA@XZ.exit6":         ; preds = %try.cont, %if.then.i4
+  ret void
+
+ehcleanup:                                        ; preds = %catch.dispatch
+  %6 = cleanuppad within none []
+  %7 = inttoptr i64 %a.sroa.0.0 to %struct.C*
+  %tobool.i = icmp eq %struct.C* %7, null
+  br i1 %tobool.i, label %"??1?$intrusive_ptr@UC@@@@QEAA@XZ.exit", label %if.then.i
+
+if.then.i:                                        ; preds = %ehcleanup
+  %8 = getelementptr %struct.C, %struct.C* %7, i64 0, i32 0
+  invoke void @"?intrusive_ptr_release@@YAXPEBUintrusive_ref_counter@@@Z"(%struct.intrusive_ref_counter* %8) [ "funclet"(token %6) ]
+          to label %"??1?$intrusive_ptr@UC@@@@QEAA@XZ.exit" unwind label %terminate.i
+
+terminate.i:                                      ; preds = %if.then.i
+  %9 = cleanuppad within %6 []
+  call void @"?terminate@@YAXXZ"() #4 [ "funclet"(token %9) ]
+  unreachable
+
+"??1?$intrusive_ptr@UC@@@@QEAA@XZ.exit":          ; preds = %ehcleanup, %if.then.i
+  cleanupret from %6 unwind to caller
+}
+
+; CHECK-LABEL: define dso_local void @"?crash@@YAXXZ"
+; CHECK: catch.dispatch:
+; CHECK-NEXT: %a.sroa.0.0 = phi i64
+; CHECK-NEXT: catchswitch within none [label %catch] unwind label %ehcleanup

commit 1939a0f40c991f0cc3fb70d4408dc0959db601d3
Author: Hans Wennborg <hans@chromium.org>
Date:   Mon Mar 2 14:35:05 2020 +0100

    Minor ReleaseNotes fixes

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index 86668d9f77e..116b47860d8 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -511,39 +511,39 @@ Static Analyzer
 Undefined Behavior Sanitizer (UBSan)
 ------------------------------------
 
-- * The ``pointer-overflow`` check was extended added to catch the cases where
-    a non-zero offset is applied to a null pointer, or the result of
-    applying the offset is a null pointer.
-
-    .. code-block:: c++
-
-      #include <cstdint> // for intptr_t
-
-      static char *getelementpointer_inbounds(char *base, unsigned long offset) {
-        // Potentially UB.
-        return base + offset;
-      }
-
-      char *getelementpointer_unsafe(char *base, unsigned long offset) {
-        // Always apply offset. UB if base is ``nullptr`` and ``offset`` is not
-        // zero, or if ``base`` is non-``nullptr`` and ``offset`` is
-        // ``-reinterpret_cast<intptr_t>(base)``.
-        return getelementpointer_inbounds(base, offset);
-      }
-
-      char *getelementpointer_safe(char *base, unsigned long offset) {
-        // Cast pointer to integer, perform usual arithmetic addition,
-        // and cast to pointer. This is legal.
-        char *computed =
-            reinterpret_cast<char *>(reinterpret_cast<intptr_t>(base) + offset);
-        // If either the pointer becomes non-``nullptr``, or becomes
-        // ``nullptr``, we must use ``computed`` result.
-        if (((base == nullptr) && (computed != nullptr)) ||
-            ((base != nullptr) && (computed == nullptr)))
-          return computed;
-        // Else we can use ``getelementpointer_inbounds()``.
-        return getelementpointer_inbounds(base, offset);
-      }
+* The ``pointer-overflow`` check was extended added to catch the cases where
+  a non-zero offset is applied to a null pointer, or the result of
+  applying the offset is a null pointer.
+
+  .. code-block:: c++
+
+    #include <cstdint> // for intptr_t
+
+    static char *getelementpointer_inbounds(char *base, unsigned long offset) {
+      // Potentially UB.
+      return base + offset;
+    }
+
+    char *getelementpointer_unsafe(char *base, unsigned long offset) {
+      // Always apply offset. UB if base is ``nullptr`` and ``offset`` is not
+      // zero, or if ``base`` is non-``nullptr`` and ``offset`` is
+      // ``-reinterpret_cast<intptr_t>(base)``.
+      return getelementpointer_inbounds(base, offset);
+    }
+
+    char *getelementpointer_safe(char *base, unsigned long offset) {
+      // Cast pointer to integer, perform usual arithmetic addition,
+      // and cast to pointer. This is legal.
+      char *computed =
+          reinterpret_cast<char *>(reinterpret_cast<intptr_t>(base) + offset);
+      // If either the pointer becomes non-``nullptr``, or becomes
+      // ``nullptr``, we must use ``computed`` result.
+      if (((base == nullptr) && (computed != nullptr)) ||
+          ((base != nullptr) && (computed == nullptr)))
+        return computed;
+      // Else we can use ``getelementpointer_inbounds()``.
+      return getelementpointer_inbounds(base, offset);
+    }
 
 
 Additional Information
diff --git a/lld/docs/ReleaseNotes.rst b/lld/docs/ReleaseNotes.rst
index 8513a08e90e..724c0097a94 100644
--- a/lld/docs/ReleaseNotes.rst
+++ b/lld/docs/ReleaseNotes.rst
@@ -92,31 +92,31 @@ MinGW Improvements
 
 * Allow using custom .edata sections from input object files (for use
   by Wine)
-  (`dadc6f248868 <https://reviews.llvm.org/rGdadc6f248868>`)
+  (`dadc6f248868 <https://reviews.llvm.org/rGdadc6f248868>`_)
 
 * Don't implicitly create import libraries unless requested
-  (`6540e55067e3 <https://reviews.llvm.org/rG6540e55067e3>`)
+  (`6540e55067e3 <https://reviews.llvm.org/rG6540e55067e3>`_)
 
 * Support merging multiple resource object files
-  (`3d3a9b3b413d <https://reviews.llvm.org/rG3d3a9b3b413d>`)
+  (`3d3a9b3b413d <https://reviews.llvm.org/rG3d3a9b3b413d>`_)
   and properly handle the default manifest object files that GCC can pass
-  (`d581dd501381 <https://reviews.llvm.org/rGd581dd501381>`)
+  (`d581dd501381 <https://reviews.llvm.org/rGd581dd501381>`_)
 
 * Demangle itanium symbol names in warnings/error messages
-  (`a66fc1c99f3e <https://reviews.llvm.org/rGa66fc1c99f3e>`)
+  (`a66fc1c99f3e <https://reviews.llvm.org/rGa66fc1c99f3e>`_)
 
 * Print source locations for undefined references and duplicate symbols,
   if possible
-  (`1d06d48bb346 <https://reviews.llvm.org/rG1d06d48bb346>`)
+  (`1d06d48bb346 <https://reviews.llvm.org/rG1d06d48bb346>`_)
   and
-  (`b38f577c015c <https://reviews.llvm.org/rGb38f577c015c>`)
+  (`b38f577c015c <https://reviews.llvm.org/rGb38f577c015c>`_)
 
 * Look for more filename patterns when resolving ``-l`` options
-  (`0226c35262df <https://reviews.llvm.org/rG0226c35262df>`)
+  (`0226c35262df <https://reviews.llvm.org/rG0226c35262df>`_)
 
 * Don't error out on duplicate absolute symbols with the same value
   (which can happen for the default-null symbol for weak symbols)
-  (`1737cc750c46 <https://reviews.llvm.org/rG1737cc750c46>`)
+  (`1737cc750c46 <https://reviews.llvm.org/rG1737cc750c46>`_)
 
 
 WebAssembly Improvements
diff --git a/llvm/docs/ReleaseNotes.rst b/llvm/docs/ReleaseNotes.rst
index 07b37fb6c19..c55c1403dbc 100644
--- a/llvm/docs/ReleaseNotes.rst
+++ b/llvm/docs/ReleaseNotes.rst
@@ -65,7 +65,7 @@ Non-comprehensive list of changes in this release
   with optimizations enabled.
 
 * ``Callbacks`` have been added to ``CommandLine Options``.  These can
-  be used to validate of selectively enable other options.
+  be used to validate or selectively enable other options.
 
 * The function attributes ``no-frame-pointer-elim`` and
   ``no-frame-pointer-elim-non-leaf`` have been replaced by ``frame-pointer``,
@@ -77,7 +77,7 @@ Non-comprehensive list of changes in this release
   `D59918 <https://reviews.llvm.org/D59918>`_, `LLVM-Dev talk <https://youtu.be/CzWkc_JcfS0>`_).
   In this release, 19 different attributes are inferred, including 12 LLVM IR
   attributes and 7 "abstract" attributes, such as liveness. The Attributor is
-  still under heavy development and disabled by default, to enable an early run
+  still under heavy development and disabled by default; to enable an early run
   pass ``-mllvm -attributor-disable=false`` to an invocation of clang.
 
 * New matrix math intrinsics have been added to LLVM
@@ -154,33 +154,33 @@ Changes to the PowerPC Target
 
 Optimization:
 
-  *  Improved register pressure estimates in the loop vectorizer based on type
+* Improved register pressure estimates in the loop vectorizer based on type
 
-  *  Improved the PowerPC cost model for the vectorizer
+* Improved the PowerPC cost model for the vectorizer
 
-  *  Enabled vectorization of math routines on PowerPC using MASSV (Mathematical Acceleration SubSystem) library
+* Enabled vectorization of math routines on PowerPC using MASSV (Mathematical Acceleration SubSystem) library
 
-compiler-rt:
+copiler-rt:
 
-  *  Added/improved conversion functions from IBM long double to 128-bit integers
+* Added/improved conversion functions from IBM long double to 128-bit integers
 
 Codegen:
 
-   *  Optimized memory access instructions in loops (pertaining to update-form instructions and address computation)
+* Optimized memory access instructions in loops (pertaining to update-form instructions and address computation)
 
-   *  Added options to disable hoisting instructions to hotter blocks based on statically or profile-based block hotness estimates
+* Added options to disable hoisting instructions to hotter blocks based on statically or profile-based block hotness estimates
 
-   *  Code generation improvements (particularly with floating point and vector code as well as handling condition registers)
+* Code generation improvements (particularly with floating point and vector code as well as handling condition registers)
 
-   *  Various infrastructural improvements, code refactoring, and bug fixes
+* Various infrastructural improvements, code refactoring, and bug fixes
 
-   *  Optimized handling of control flow based on multiple comparison of same values
+* Optimized handling of control flow based on multiple comparison of same values
 
 Tools:
 
-  *   llvm-readobj supports displaying file header, section headers, symbol table and relocation entries for XCOFF object files
+* llvm-readobj supports displaying file header, section headers, symbol table and relocation entries for XCOFF object files
 
-  *   llvm-objdump supports disassembling physical sections for XCOFF object files
+* llvm-objdump supports disassembling physical sections for XCOFF object files
 
 
 Changes to the SystemZ Target
@@ -203,9 +203,7 @@ Changes to the SystemZ Target
 Changes to the X86 Target
 -------------------------
 
- During this release ...
-
-* Less than 128 bit vector types, v2i32, v4i16, v2i16, v8i8, v4i8, and v2i8, are
+* Less-than-128-bit vector types, v2i32, v4i16, v2i16, v8i8, v4i8, and v2i8, are
   now stored in the lower bits of an xmm register and the upper bits are
   undefined. Previously the elements were spread apart with undefined bits in
   between them.
@@ -287,6 +285,7 @@ New Features:
   than the ABI register names.
 
 Improvements:
+
 * Trap and Debugtrap now lower to RISC-V-specific trap instructions.
 
 * LLVM IR Inline assembly now supports using ABI register names and using

commit 001c8aac80e3924c33a4cc644cca58401c72fe6b
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Mon Mar 2 10:11:00 2020 -0800

    Add C standard upgrade in clang-11 release note
    
    Summary: As per rsmith (https://reviews.llvm.org/D75383).
    
    Reviewers: hans
    
    Reviewed By: hans
    
    Subscribers: cfe-commits, rsmith
    
    Tags: #clang
    
    Differential Revision: https://reviews.llvm.org/D75469

diff --git a/clang/docs/ReleaseNotes.rst b/clang/docs/ReleaseNotes.rst
index 116b47860d8..a6ff29c630e 100644
--- a/clang/docs/ReleaseNotes.rst
+++ b/clang/docs/ReleaseNotes.rst
@@ -545,6 +545,12 @@ Undefined Behavior Sanitizer (UBSan)
       return getelementpointer_inbounds(base, offset);
     }
 
+Changes deferred to Clang-11 release
+------------------------------------
+
+- The next release of clang (clang-11) will upgrade the default C language
+  standard used if not specified via command line from gnu11 to gnu17.
+
 
 Additional Information
 ======================
