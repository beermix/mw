commit 9f26e5863a75744bbee1479792ecae084a3ceb20
Author: Jakub Jelinek <jakub@redhat.com>
Date:   Thu Mar 12 12:38:50 2020 +0100

    Bump BASE-VER to 9.3.1.
    
    2020-03-12  Jakub Jelinek  <jakub@redhat.com>
    
            * BASE-VER: Set to 9.3.1.

diff --git a/gcc/BASE-VER b/gcc/BASE-VER
index b13d146a7b0..3b74042132a 100644
--- a/gcc/BASE-VER
+++ b/gcc/BASE-VER
@@ -1 +1 @@
-9.3.0
+9.3.1
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index d8e53874e68..3bf79f39d7e 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,7 @@
+2020-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 9.3.1.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.

commit 716cc43745fb11ea883684d55e62fe2c1694902b
Author: Martin Liska <mliska@suse.cz>
Date:   Thu Mar 12 13:36:17 2020 +0100

    Backport 314b91220a07bd63f13c58e37f1b5b9430a3702b
    
            Backport from mainline
            2020-03-09  Martin Liska  <mliska@suse.cz>
    
            PR target/93800
            * config/rs6000/rs6000.c (rs6000_option_override_internal):
            Remove set of str_align_loops and str_align_jumps as these
            should be set in previous 2 conditions in the function.
            Backport from mainline
            2020-03-09  Martin Liska  <mliska@suse.cz>
    
            PR target/93800
            * gcc.target/powerpc/pr93800.c: New test.

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 3bf79f39d7e..c141669d941 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,13 @@
+2020-03-12  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-03-09  Martin Liska  <mliska@suse.cz>
+
+	PR target/93800
+	* config/rs6000/rs6000.c (rs6000_option_override_internal):
+	Remove set of str_align_loops and str_align_jumps as these
+	should be set in previous 2 conditions in the function.
+
 2020-03-12  Jakub Jelinek  <jakub@redhat.com>
 
 	* BASE-VER: Set to 9.3.1.
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index 87d60078bb0..d45294302cb 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -4715,11 +4715,6 @@ rs6000_option_override_internal (bool global_init_p)
 		  str_align_loops = "16";
 		}
 	    }
-
-	  if (flag_align_jumps && !str_align_jumps)
-	    str_align_jumps = "16";
-	  if (flag_align_loops && !str_align_loops)
-	    str_align_loops = "16";
 	}
 
       /* Arrange to save and restore machine status around nested functions.  */
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index e132f2657ef..ce957685132 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,11 @@
+2020-03-12  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2020-03-09  Martin Liska  <mliska@suse.cz>
+
+	PR target/93800
+	* gcc.target/powerpc/pr93800.c: New test.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/gcc/testsuite/gcc.target/powerpc/pr93800.c b/gcc/testsuite/gcc.target/powerpc/pr93800.c
new file mode 100644
index 00000000000..f8dfbe7c082
--- /dev/null
+++ b/gcc/testsuite/gcc.target/powerpc/pr93800.c
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-mcpu=860 -O2" } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-final { scan-assembler-not "\\.p2align 4" } } */
+
+volatile int g;
+int f(int a, int b)
+{
+	int i;
+
+	for (i = 0; i < b; i++)
+		a += g;
+	return a;
+}

commit 08f00a213f8a1b99bbf3ad3c337dea249a288cf1
Author: Richard Earnshaw <rearnsha@arm.com>
Date:   Fri Mar 6 10:04:51 2020 +0000

    arm: correct constraints on movsi_compare0 [PR91913]
    
    The peephole that detects a mov of one register to another followed by
    a comparison of the original register against zero is only used in Arm
    state; but the instruction that matches this is generic to all 32-bit
    compilation states.  That instruction lacks support for SP which is
    permitted in Arm state, but has restrictions in Thumb2 code.
    
    This patch fixes the problem by allowing SP when in ARM state for all
    registers; in Thumb state it allows SP only as a source when the
    register really is copied to another target.
    
    gcc/ChangeLog:
            PR target/91913
            Backport from master
            * config/arm/arm.md (movsi_compare0): Allow SP as a source register
            in Thumb state and also as a destination in Arm state.  Add T16
            variants.
    
    gcc/testsuite/ChangeLog:
            2020-02-10  Jakub Jelinek  <jakub@redhat.com>
    
            PR target/91913
            Backport from master
            * gfortran.dg/pr91913.f90: New test.

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index c141669d941..603294bcd72 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,13 @@
+2020-03-12  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from master
+	2020-02-10  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/91913
+	* config/arm/arm.md (movsi_compare0): Allow SP as a source register
+	in Thumb state and also as a destination in Arm state.  Add T16
+	variants.
+
 2020-03-12  Martin Liska  <mliska@suse.cz>
 
 	Backport from mainline
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
index 53e54874c12..bfb03f1b96d 100644
--- a/gcc/config/arm/arm.md
+++ b/gcc/config/arm/arm.md
@@ -6362,16 +6362,21 @@
 
 (define_insn "*movsi_compare0"
   [(set (reg:CC CC_REGNUM)
-	(compare:CC (match_operand:SI 1 "s_register_operand" "0,r")
+	(compare:CC (match_operand:SI 1 "s_register_operand" "0,0,l,rk,rk")
 		    (const_int 0)))
-   (set (match_operand:SI 0 "s_register_operand" "=r,r")
+   (set (match_operand:SI 0 "s_register_operand" "=l,rk,l,r,rk")
 	(match_dup 1))]
   "TARGET_32BIT"
   "@
    cmp%?\\t%0, #0
+   cmp%?\\t%0, #0
+   subs%?\\t%0, %1, #0
+   subs%?\\t%0, %1, #0
    subs%?\\t%0, %1, #0"
   [(set_attr "conds" "set")
-   (set_attr "type" "alus_imm,alus_imm")]
+   (set_attr "arch" "t2,*,t2,t2,a")
+   (set_attr "type" "alus_imm")
+   (set_attr "length" "2,4,2,4,4")]
 )
 
 ;; Subroutine to store a half word from a register into memory.
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index ce957685132..b96c9b9ab1c 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,11 @@
+2020-03-12  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from master
+	2020-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/91913
+	* gfortran.dg/pr91913.f90: New test.
+
 2020-03-12  Martin Liska  <mliska@suse.cz>
 
 	Backport from mainline
diff --git a/gcc/testsuite/gfortran.dg/pr91913.f90 b/gcc/testsuite/gfortran.dg/pr91913.f90
new file mode 100644
index 00000000000..7d5477ac0c3
--- /dev/null
+++ b/gcc/testsuite/gfortran.dg/pr91913.f90
@@ -0,0 +1,5 @@
+! PR target/91913
+! { dg-do compile }
+! { dg-options "-std=legacy -Ofast --param max-cse-insns=0 -fno-schedule-insns -fsanitize=null" }
+
+include 'string_ctor_1.f90'

commit 362c8772e7779d9e4730e2e51628ccaadce98bd0
Author: Jonathan Wakely <jwakely@redhat.com>
Date:   Thu Mar 12 17:39:04 2020 +0000

    libstdc++: Ensure root-dir converted to forward slash (PR93244)
    
    Backport from mainline
    2020-01-13  Jonathan Wakely  <jwakely@redhat.com>
    
            PR libstdc++/93244
            * include/bits/fs_path.h (path::generic_string<C,A>)
            [_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Convert root-dir to forward-slash.
            * testsuite/27_io/filesystem/path/generic/generic_string.cc: Check
            root-dir is converted to forward slash in generic pathname.
            * testsuite/27_io/filesystem/path/generic/utf.cc: New test.
            * testsuite/27_io/filesystem/path/generic/wchar_t.cc: New test.

diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 45847172291..000ecbfbad1 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,3 +1,16 @@
+2020-03-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2020-01-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/93244
+	* include/bits/fs_path.h (path::generic_string<C,A>)
+	[_GLIBCXX_FILESYSTEM_IS_WINDOWS]: Convert root-dir to forward-slash.
+	* testsuite/27_io/filesystem/path/generic/generic_string.cc: Check
+	root-dir is converted to forward slash in generic pathname.
+	* testsuite/27_io/filesystem/path/generic/utf.cc: New test.
+	* testsuite/27_io/filesystem/path/generic/wchar_t.cc: New test.
+
 2020-03-12  Release Manager
 
 	* GCC 9.3.0 released.
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
index 5dc624dbb1e..6b39c46ac6e 100644
--- a/libstdc++-v3/include/bits/fs_path.h
+++ b/libstdc++-v3/include/bits/fs_path.h
@@ -1073,6 +1073,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11
 	  bool __add_slash = false;
 	  for (auto& __elem : *this)
 	    {
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+	      if (__elem._M_type() == _Type::_Root_dir)
+		{
+		  __str += __slash;
+		  continue;
+		}
+#endif
 	      if (__add_slash)
 		__str += __slash;
 	      __str += __elem._M_pathname;
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/generic/generic_string.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/generic_string.cc
index 5a0c24c25c3..5caf079ed9b 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/generic/generic_string.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/generic_string.cc
@@ -1,7 +1,7 @@
 // { dg-options "-std=gnu++17" }
 // { dg-do run { target c++17 } }
 
-// Copyright (C) 2017-2019 Free Software Foundation, Inc.
+// Copyright (C) 2017-2020 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -46,8 +46,20 @@ test01()
   VERIFY( path("/a//b//.").generic_string() == "/a/b/." );
 }
 
+void
+test02()
+{
+  if constexpr (path::preferred_separator == L'\\')
+  {
+    // PR libstdc++/93244
+    VERIFY( path("C:\\foo\\bar").generic_string() == "C:/foo/bar" );
+    VERIFY( path("C://foo//bar").generic_string() == "C:/foo/bar" );
+  }
+}
+
 int
 main()
 {
   test01();
+  test02();
 }
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/generic/utf.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/utf.cc
new file mode 100644
index 00000000000..52afdb4497b
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/utf.cc
@@ -0,0 +1,65 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2017-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 30.10.7.4.7 path generic format observers [fs.path.generic.obs]
+
+#include <filesystem>
+#include <testsuite_hooks.h>
+
+using std::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path().generic_u32string() == U"" );
+  VERIFY( path("/").generic_u32string() == U"/" );
+  VERIFY( path("////").generic_u32string() == U"/" );
+#ifdef __CYGWIN__
+  VERIFY( path("//a").generic_u32string() == U"//a" );
+  VERIFY( path("//a/").generic_u32string() == U"//a/" );
+  VERIFY( path("//a/b").generic_u32string() == U"//a/b" );
+#else
+  VERIFY( path("//a").generic_u32string() == U"/a" );
+  VERIFY( path("//a/").generic_u32string() == U"/a/" );
+  VERIFY( path("//a/b").generic_u32string() == U"/a/b" );
+#endif
+  VERIFY( path("/a//b").generic_u32string() == U"/a/b" );
+  VERIFY( path("/a//b/").generic_u32string() == U"/a/b/" );
+  VERIFY( path("/a//b//").generic_u32string() == U"/a/b/" );
+  VERIFY( path("/a//b//.").generic_u32string() == U"/a/b/." );
+}
+
+void
+test02()
+{
+  if constexpr (path::preferred_separator == L'\\')
+  {
+    // PR libstdc++/93244
+    VERIFY( path("C:\\foo\\bar").generic_u32string() == U"C:/foo/bar" );
+    VERIFY( path("C://foo//bar").generic_u32string() == U"C:/foo/bar" );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/generic/wchar_t.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/wchar_t.cc
new file mode 100644
index 00000000000..7bb2f643043
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/generic/wchar_t.cc
@@ -0,0 +1,65 @@
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++17 } }
+
+// Copyright (C) 2017-2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// C++17 30.10.7.4.7 path generic format observers [fs.path.generic.obs]
+
+#include <filesystem>
+#include <testsuite_hooks.h>
+
+using std::filesystem::path;
+
+void
+test01()
+{
+  VERIFY( path().generic_wstring() == L"" );
+  VERIFY( path("/").generic_wstring() == L"/" );
+  VERIFY( path("////").generic_wstring() == L"/" );
+#ifdef __CYGWIN__
+  VERIFY( path("//a").generic_wstring() == L"//a" );
+  VERIFY( path("//a/").generic_wstring() == L"//a/" );
+  VERIFY( path("//a/b").generic_wstring() == L"//a/b" );
+#else
+  VERIFY( path("//a").generic_wstring() == L"/a" );
+  VERIFY( path("//a/").generic_wstring() == L"/a/" );
+  VERIFY( path("//a/b").generic_wstring() == L"/a/b" );
+#endif
+  VERIFY( path("/a//b").generic_wstring() == L"/a/b" );
+  VERIFY( path("/a//b/").generic_wstring() == L"/a/b/" );
+  VERIFY( path("/a//b//").generic_wstring() == L"/a/b/" );
+  VERIFY( path("/a//b//.").generic_wstring() == L"/a/b/." );
+}
+
+void
+test02()
+{
+  if constexpr (path::preferred_separator == L'\\')
+  {
+    // PR libstdc++/93244
+    VERIFY( path("C:\\foo\\bar").generic_wstring() == L"C:/foo/bar" );
+    VERIFY( path("C://foo//bar").generic_wstring() == L"C:/foo/bar" );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}

commit 2fa3247fef79ede9ec3638605ea137b0e4d76075
Author: Jonathan Wakely <jwakely@redhat.com>
Date:   Thu Mar 12 17:39:04 2020 +0000

    libstdc++: Fix FS-dependent filesystem tests
    
    These tests were failing on XFS because it doesn't support setting file
    timestamps past 2038, so the expected overflow when reading back a huge
    timestamp into a file_time_type didn't happen.
    
    Additionally, the std::filesystem::file_time_type::clock has an
    epoch that is out of range of 32-bit time_t so testing times around that
    epoch may also fail.
    
    This fixes the tests to give up gracefully if the filesystem doesn't
    support times that can't be represented in 32-bit time_t.
    
    Backport from mainline
    2020-02-28  Jonathan Wakely  <jwakely@redhat.com>
    
            * testsuite/27_io/filesystem/operations/last_write_time.cc: Fixes for
            filesystems that silently truncate timestamps.
            * testsuite/experimental/filesystem/operations/last_write_time.cc:
            Likewise.

diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 000ecbfbad1..7608f7028f6 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,5 +1,13 @@
 2020-03-12  Jonathan Wakely  <jwakely@redhat.com>
 
+	Backport from mainline
+	2020-02-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/operations/last_write_time.cc: Fixes for
+	filesystems that silently truncate timestamps.
+	* testsuite/experimental/filesystem/operations/last_write_time.cc:
+	Likewise.
+
 	Backport from mainline
 	2020-01-13  Jonathan Wakely  <jwakely@redhat.com>
 
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/last_write_time.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/last_write_time.cc
index 3f31375f51b..5d6e62c421a 100644
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/last_write_time.cc
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/last_write_time.cc
@@ -32,9 +32,12 @@
 #if _GLIBCXX_HAVE_UTIME_H
 # include <utime.h>
 #endif
+#include <stdio.h>
 
 using time_type = std::filesystem::file_time_type;
 
+namespace chrono = std::chrono;
+
 void
 test01()
 {
@@ -67,10 +70,15 @@ test01()
 
   auto end_of_time = time_type::duration::max();
   auto last_second
-    = std::chrono::duration_cast<std::chrono::seconds>(end_of_time).count();
+    = chrono::duration_cast<chrono::seconds>(end_of_time).count();
   if (last_second > std::numeric_limits<std::time_t>::max())
-    return; // can't test overflow
+  {
+    puts("Range of time_t is smaller than range of chrono::file_clock, "
+	 "can't test for overflow on this target.");
+    return;
+  }
 
+  // Set mtime to a date past the maximum possible file_time_type:
 #if _GLIBCXX_USE_UTIMENSAT
   struct ::timespec ts[2];
   ts[0].tv_sec = 0;
@@ -84,25 +92,34 @@ test01()
   times.actime = std::numeric_limits<std::time_t>::max() - 1;
   VERIFY( !::utime(p.string().c_str(), &times) );
 #else
+  puts("No utimensat or utime, giving up.");
   return;
 #endif
 
+  // Try to read back the impossibly-large mtime:
   mtime = last_write_time(p, ec);
-  VERIFY( ec );
-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
-  VERIFY( mtime == time_type::min() );
+  // Some filesystems (e.g. XFS) silently truncate distant times to
+  // the time_t epochalypse, Jan 19 2038, so we won't get an error when
+  // reading it back:
+  if (ec)
+  {
+    VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
+    VERIFY( mtime == time_type::min() );
+  }
+  else
+    puts("No overflow error, filesystem may not support 64-bit time_t.");
 
 #if __cpp_exceptions
-  caught = false;
+  // Once more, with exceptions:
   try {
-    mtime = last_write_time(p);
-  } catch (std::system_error const& e) {
-    caught = true;
-    ec = e.code();
+    auto mtime2 = last_write_time(p);
+    // If it didn't throw, expect to have read back the same value:
+    VERIFY( mtime2 == mtime );
+  } catch (std::filesystem::filesystem_error const& e) {
+    // If it did throw, expect the error_code to be the same:
+    VERIFY( e.code() == ec );
+    VERIFY( e.path1() == p );
   }
-  VERIFY( caught );
-  VERIFY( ec );
-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
 #endif
 }
 
@@ -111,7 +128,7 @@ bool approx_equal(time_type file_time, time_type expected)
   auto delta = expected - file_time;
   if (delta < delta.zero())
     delta = -delta;
-  return delta < std::chrono::seconds(1);
+  return delta < chrono::seconds(1);
 }
 
 void
@@ -124,20 +141,20 @@ test02()
   std::error_code ec;
   time_type time;
 
-  time = last_write_time(f.path);
   ec = bad_ec;
+  time = last_write_time(f.path);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
   ec = bad_ec;
-  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);
+  time -= chrono::milliseconds(1000 * 60 * 10 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
   ec = bad_ec;
-  time += std::chrono::milliseconds(1000 * 60 * 20 + 15);
+  time += chrono::milliseconds(1000 * 60 * 20 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
@@ -146,6 +163,28 @@ test02()
       < std::numeric_limits<std::int64_t>::max())
     return; // file clock's epoch is out of range for 32-bit time_t
 
+  using sys_time_32b
+    = chrono::time_point<chrono::system_clock, chrono::duration<std::int32_t>>;
+  auto duration_until_2038 = sys_time_32b::max() - sys_time_32b::clock::now();
+  auto file_time_2038 = time_type::clock::now() + duration_until_2038;
+
+  ec = bad_ec;
+  time = file_time_2038 - chrono::seconds(1);
+  // Assume all filesystems can store times that fit in 32-bit time_t
+  // (i.e. up to Jan 19 2038)
+  last_write_time(f.path, time, ec);
+  VERIFY( !ec );
+  VERIFY( approx_equal(last_write_time(f.path), time) );
+
+  // Check whether the filesystem supports times larger than 32-bit time_t:
+  time += chrono::seconds(60);
+  last_write_time(f.path, time, ec);
+  if (ec || !approx_equal(last_write_time(f.path), time))
+  {
+    puts("Filesystem seems to truncate times past Jan 19 2038, giving up.");
+    return; // Tests below will fail on this filesystem
+  }
+
   ec = bad_ec;
   // The file clock's epoch:
   time = time_type();
@@ -155,14 +194,14 @@ test02()
 
   ec = bad_ec;
   // A time after the epoch
-  time += std::chrono::milliseconds(1000 * 60 * 10 + 15);
+  time += chrono::milliseconds(1000 * 60 * 10 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
   ec = bad_ec;
   // A time before than the epoch
-  time -= std::chrono::milliseconds(1000 * 60 * 20 + 15);
+  time -= chrono::milliseconds(1000 * 60 * 20 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/last_write_time.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/last_write_time.cc
index 1bbc37408c3..82061f9e7e9 100644
--- a/libstdc++-v3/testsuite/experimental/filesystem/operations/last_write_time.cc
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/last_write_time.cc
@@ -22,6 +22,7 @@
 // 15.25 Permissions [fs.op.last_write_time]
 
 #include <experimental/filesystem>
+#include <limits>
 #include <testsuite_fs.h>
 #include <testsuite_hooks.h>
 
@@ -31,9 +32,12 @@
 #if _GLIBCXX_HAVE_UTIME_H
 # include <utime.h>
 #endif
+#include <stdio.h>
 
 using time_type = std::experimental::filesystem::file_time_type;
 
+namespace chrono = std::chrono;
+
 void
 test01()
 {
@@ -66,10 +70,15 @@ test01()
 
   auto end_of_time = time_type::duration::max();
   auto last_second
-    = std::chrono::duration_cast<std::chrono::seconds>(end_of_time).count();
+    = chrono::duration_cast<chrono::seconds>(end_of_time).count();
   if (last_second > std::numeric_limits<std::time_t>::max())
-    return; // can't test overflow
+  {
+    puts("Range of time_t is smaller than range of chrono::file_clock, "
+	 "can't test for overflow on this target.");
+    return;
+  }
 
+  // Set mtime to a date past the maximum possible file_time_type:
 #if _GLIBCXX_USE_UTIMENSAT
   struct ::timespec ts[2];
   ts[0].tv_sec = 0;
@@ -83,25 +92,34 @@ test01()
   times.actime = std::numeric_limits<std::time_t>::max() - 1;
   VERIFY( !::utime(p.string().c_str(), &times) );
 #else
+  puts("No utimensat or utime, giving up.");
   return;
 #endif
 
+  // Try to read back the impossibly-large mtime:
   mtime = last_write_time(p, ec);
-  VERIFY( ec );
-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
-  VERIFY( mtime == time_type::min() );
+  // Some filesystems (e.g. XFS) silently truncate distant times to
+  // the time_t epochalypse, Jan 19 2038, so we won't get an error when
+  // reading it back:
+  if (ec)
+  {
+    VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
+    VERIFY( mtime == time_type::min() );
+  }
+  else
+    puts("No overflow error, filesystem may not support 64-bit time_t.");
 
 #if __cpp_exceptions
-  caught = false;
+  // Once more, with exceptions:
   try {
-    mtime = last_write_time(p);
-  } catch (std::system_error const& e) {
-    caught = true;
-    ec = e.code();
+    auto mtime2 = last_write_time(p);
+    // If it didn't throw, expect to have read back the same value:
+    VERIFY( mtime2 == mtime );
+  } catch (std::experimental::filesystem::filesystem_error const& e) {
+    // If it did throw, expect the error_code to be the same:
+    VERIFY( e.code() == ec );
+    VERIFY( e.path1() == p );
   }
-  VERIFY( caught );
-  VERIFY( ec );
-  VERIFY( ec == std::make_error_code(std::errc::value_too_large) );
 #endif
 }
 
@@ -110,7 +128,7 @@ bool approx_equal(time_type file_time, time_type expected)
   auto delta = expected - file_time;
   if (delta < delta.zero())
     delta = -delta;
-  return delta < std::chrono::seconds(1);
+  return delta < chrono::seconds(1);
 }
 
 void
@@ -118,31 +136,37 @@ test02()
 {
   // write times
 
+  const std::error_code bad_ec = make_error_code(std::errc::invalid_argument);
   __gnu_test::scoped_file f;
   std::error_code ec;
   time_type time;
 
+  ec = bad_ec;
   time = last_write_time(f.path);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
-  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);
+  ec = bad_ec;
+  time -= chrono::milliseconds(1000 * 60 * 10 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
-  time += std::chrono::milliseconds(1000 * 60 * 20 + 15);
+  ec = bad_ec;
+  time += chrono::milliseconds(1000 * 60 * 20 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
+  ec = bad_ec;
   time = time_type();
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );
 
-  time -= std::chrono::milliseconds(1000 * 60 * 10 + 15);
+  ec = bad_ec;
+  time -= chrono::milliseconds(1000 * 60 * 10 + 15);
   last_write_time(f.path, time, ec);
   VERIFY( !ec );
   VERIFY( approx_equal(last_write_time(f.path), time) );

commit 55925fe3a97c38eb770a9839916d61b219b90d00
Author: Jonathan Wakely <jwakely@redhat.com>
Date:   Thu Mar 12 17:39:05 2020 +0000

    libstdc++: Fix test failure due to -Wnonnull warnings
    
    This test fails in the Fedora RPM build (but not elsewhere, for unknown
    reasons). The warning is correct, we're passing a null pointer.
    
    Backport from mainline
    2020-03-12  Jonathan Wakely  <jwakely@redhat.com>
    
            * testsuite/tr1/8_c_compatibility/cstdlib/functions.cc: Do not pass
            a null pointer to functions with nonnull(1) attribute.

diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index 7608f7028f6..fd80d5d091f 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,5 +1,11 @@
 2020-03-12  Jonathan Wakely  <jwakely@redhat.com>
 
+	Backport from mainline
+	2020-03-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/tr1/8_c_compatibility/cstdlib/functions.cc: Do not pass
+	a null pointer to functions with nonnull(1) attribute.
+
 	Backport from mainline
 	2020-02-28  Jonathan Wakely  <jwakely@redhat.com>
 
diff --git a/libstdc++-v3/testsuite/tr1/8_c_compatibility/cstdlib/functions.cc b/libstdc++-v3/testsuite/tr1/8_c_compatibility/cstdlib/functions.cc
index e1feef99582..0f00a94da42 100644
--- a/libstdc++-v3/testsuite/tr1/8_c_compatibility/cstdlib/functions.cc
+++ b/libstdc++-v3/testsuite/tr1/8_c_compatibility/cstdlib/functions.cc
@@ -30,7 +30,7 @@ void test01()
 #if _GLIBCXX_USE_C99_STDLIB
 
   long long i = 0;
-  const char* s = 0;
+  const char* s = "";
   char** endptr = 0;
   int base = 0;
 

commit 95a82afc8a7aa8920b55c8db4e7f5fd8b28bf84f
Author: Jonathan Wakely <jwakely@redhat.com>
Date:   Thu Mar 12 17:39:05 2020 +0000

    libstdc++: Fix name of macro in #undef directive
    
    The macro that is defined is _GLIBCXX_NOT_FN_CALL_OP but the macro that
    was named in the #undef directive was _GLIBCXX_NOT_FN_CALL. This fixes
    the #undef.
    
    Backport from mainline
    2020-02-04  Jonathan Wakely  <jwakely@redhat.com>
    
            * include/std/functional (_GLIBCXX_NOT_FN_CALL_OP): Un-define after
            use.

diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index fd80d5d091f..c9aba46038a 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,5 +1,11 @@
 2020-03-12  Jonathan Wakely  <jwakely@redhat.com>
 
+	Backport from mainline
+	2020-02-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/functional (_GLIBCXX_NOT_FN_CALL_OP): Un-define after
+	use.
+
 	Backport from mainline
 	2020-03-12  Jonathan Wakely  <jwakely@redhat.com>
 
diff --git a/libstdc++-v3/include/std/functional b/libstdc++-v3/include/std/functional
index 528452fed40..4b9c3449383 100644
--- a/libstdc++-v3/include/std/functional
+++ b/libstdc++-v3/include/std/functional
@@ -974,7 +974,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION
       _GLIBCXX_NOT_FN_CALL_OP( const & )
       _GLIBCXX_NOT_FN_CALL_OP( && )
       _GLIBCXX_NOT_FN_CALL_OP( const && )
-#undef _GLIBCXX_NOT_FN_CALL
+#undef _GLIBCXX_NOT_FN_CALL_OP
 
     private:
       _Fn _M_fn;

commit 7ef07b622d8c2fca35813bf50669dcd663fe5cf2
Author: Jonathan Wakely <jwakely@redhat.com>
Date:   Thu Mar 12 17:39:05 2020 +0000

    libstdc++: Handle type-changing path concatenations (PR 94063)
    
    The filesystem::path::operator+= and filesystem::path::concat functions
    operate directly on the native format of the path and so can cause a
    path to mutate to a completely different type.
    
    For Windows combining a filename "x" with a filename ":" produces a
    root-name "x:". Similarly, a Cygwin root-directory "/" combined with a
    root-directory and filename "/x" produces a root-name "//x".
    
    Before this patch the implemenation didn't support those kind of
    mutations, assuming that concatenating two filenames would always
    produce a filename and concatenating with a root-dir would still have a
    root-dir.
    
    This patch fixes it simply by checking for the problem cases and
    creating a new path by re-parsing the result of the string
    concatenation. This is slightly suboptimal because the argument has
    already been parsed if it's a path, but more importantly it doesn't
    reuse any excess capacity that the path object being modified might
    already have allocated.
    
    Backport from mainline
    2020-03-09  Jonathan Wakely  <jwakely@redhat.com>
    
            PR libstdc++/94063
            * src/c++17/fs_path.cc (path::operator+=(const path&)): Add kluge to
            handle concatenations that change the type of the first component.
            (path::operator+=(basic_string_view<value_type>)): Likewise.
            * testsuite/27_io/filesystem/path/concat/94063.cc: New test.

diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
index c9aba46038a..0c39c30a484 100644
--- a/libstdc++-v3/ChangeLog
+++ b/libstdc++-v3/ChangeLog
@@ -1,5 +1,14 @@
 2020-03-12  Jonathan Wakely  <jwakely@redhat.com>
 
+	Backport from mainline
+	2020-03-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/94063
+	* src/c++17/fs_path.cc (path::operator+=(const path&)): Add kluge to
+	handle concatenations that change the type of the first component.
+	(path::operator+=(basic_string_view<value_type>)): Likewise.
+	* testsuite/27_io/filesystem/path/concat/94063.cc: New test.
+
 	Backport from mainline
 	2020-02-04  Jonathan Wakely  <jwakely@redhat.com>
 
diff --git a/libstdc++-v3/src/c++17/fs_path.cc b/libstdc++-v3/src/c++17/fs_path.cc
index 54bef75efd8..a6be0e03a78 100644
--- a/libstdc++-v3/src/c++17/fs_path.cc
+++ b/libstdc++-v3/src/c++17/fs_path.cc
@@ -845,6 +845,26 @@ path::operator+=(const path& p)
       return *this;
     }
 
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  if (_M_type() == _Type::_Root_name
+      || (_M_type() == _Type::_Filename && _M_pathname.size() == 1))
+    {
+      // Handle path("C") += path(":") and path("C:") += path("/x")
+      // FIXME: do this more efficiently
+      *this = path(_M_pathname + p._M_pathname);
+      return *this;
+    }
+#endif
+#if SLASHSLASH_IS_ROOTNAME
+  if (_M_type() == _Type::_Root_dir)
+    {
+      // Handle path("/") += path("/x") and path("//") += path("x")
+      // FIXME: do this more efficiently
+      *this = path(_M_pathname + p._M_pathname);
+      return *this;
+    }
+#endif
+
   const auto orig_pathlen = _M_pathname.length();
   const auto orig_type = _M_type();
   const auto orig_size = _M_cmpts.size();
@@ -1031,6 +1051,26 @@ path::_M_concat(basic_string_view<value_type> s)
       return;
     }
 
+#if _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  if (_M_type() == _Type::_Root_name
+      || (_M_type() == _Type::_Filename && _M_pathname.size() == 1))
+    {
+      // Handle path("C") += ":" and path("C:") += "/x"
+      // FIXME: do this more efficiently
+      *this = path(_M_pathname + string_type(s));
+      return;
+    }
+#endif
+#if SLASHSLASH_IS_ROOTNAME
+  if (_M_type() == _Type::_Root_dir)
+    {
+      // Handle path("/") += "/x" and path("//") += "x"
+      // FIXME: do this more efficiently
+      *this = path(_M_pathname + string_type(s));
+      return;
+    }
+#endif
+
   const auto orig_pathlen = _M_pathname.length();
   const auto orig_type = _M_type();
   const auto orig_size = _M_cmpts.size();
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/concat/94063.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/concat/94063.cc
new file mode 100644
index 00000000000..9f4c9c0aa08
--- /dev/null
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/concat/94063.cc
@@ -0,0 +1,111 @@
+// Copyright (C) 2020 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target { *-*-*mingw* || *-*-cygwin } } }
+// { dg-require-effective-target c++17 }
+
+#include <filesystem>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  using std::filesystem::path;
+  path p;
+
+  // PR libstdc++/94063
+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
+  p = L"C";
+  p += path(L":");
+  VERIFY( p.has_root_name() );
+  VERIFY( p.root_name() == p );
+  p += path(L"\\");
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"\\" );
+
+  p = L"C";
+  p += L':';
+  VERIFY( p.has_root_name() );
+  VERIFY( p.root_name() == p );
+  p += L'\\';
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"\\" );
+
+  p = L"C:";
+  p += path(L"/foo");
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"/" );
+  VERIFY( p.filename() == L"foo" );
+
+  p = L"C:";
+  p += L"/foo";
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"/" );
+  VERIFY( p.filename() == L"foo" );
+
+  p = L"C";
+  p += path(L":/foo");
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"/" );
+  VERIFY( p.filename() == L"foo" );
+
+  p = L"C";
+  p += L":/foo";
+  VERIFY( p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+  VERIFY( p.root_name() == L"C:" );
+  VERIFY( p.root_directory() == L"/" );
+  VERIFY( p.filename() == L"foo" );
+#elif defined __CYGWIN__
+  p = "/";
+  p += path("/x");
+  VERIFY( p.has_root_name() );
+  VERIFY( p.root_name() == p );
+
+  p = "/";
+  p += "/x";
+  VERIFY( p.has_root_name() );
+  VERIFY( p.root_name() == p );
+
+  p = "/";
+  p += path("/");
+  VERIFY( !p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+
+  p = "/";
+  p += "/";
+  VERIFY( !p.has_root_name() );
+  VERIFY( p.has_root_directory() );
+#endif
+}
+
+int
+main()
+{
+  test01();
+}

commit de8e3b71c8bec6dde60e6ee70c73d6895c67d782
Author: Bill Schmidt <wschmidt@linux.ibm.com>
Date:   Thu Mar 12 15:28:50 2020 -0500

    rs6000: Fix -mpower9-vector -mno-altivec ICE (PR87560)
    
    PR87560 reports an ICE when a test case is compiled with -mpower9-vector
    and -mno-altivec.  This patch terminates compilation with an error when
    this combination (and other unreasonable ones) are requested.
    
    Bootstrapped and tested on powerpc64le-unknown-linux-gnu with no
    regressions.  Reported error is now:
    
    f951: Error: '-mno-altivec' turns off '-mpower9-vector'
    
    2020-03-12  Bill Schmidt  <wschmidt@linux.ibm.com>
    
            Backport from master
            2020-03-02  Bill Schmidt  <wschmidt@linux.ibm.com>
    
            PR target/87560
            * rs6000-cpus.def (OTHER_ALTIVEC_MASKS): New #define.
            * rs6000.c (rs6000_disable_incompatible_switches): Add table entry
            for OPTION_MASK_ALTIVEC.

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 603294bcd72..92d5b0afb2e 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,13 @@
+2020-03-12  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from master
+	2020-03-02  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/87560
+	* rs6000-cpus.def (OTHER_ALTIVEC_MASKS): New #define.
+	* rs6000.c (rs6000_disable_incompatible_switches): Add table entry
+	for OPTION_MASK_ALTIVEC.
+
 2020-03-12  Richard Earnshaw  <rearnsha@arm.com>
 
 	Backport from master
diff --git a/gcc/config/rs6000/rs6000-cpus.def b/gcc/config/rs6000/rs6000-cpus.def
index d0d69beafd4..47a5d0576d0 100644
--- a/gcc/config/rs6000/rs6000-cpus.def
+++ b/gcc/config/rs6000/rs6000-cpus.def
@@ -88,6 +88,10 @@
 				 | OPTION_MASK_FLOAT128_KEYWORD		\
 				 | OPTION_MASK_P8_VECTOR)
 
+/* Flags that need to be turned off if -mno-altivec.  */
+#define OTHER_ALTIVEC_MASKS	(OTHER_VSX_VECTOR_MASKS			\
+				 | OPTION_MASK_VSX)
+
 #define POWERPC_7400_MASK	(OPTION_MASK_PPC_GFXOPT | OPTION_MASK_ALTIVEC)
 
 /* Deal with ports that do not have -mstrict-align.  */
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
index d45294302cb..04324ab981a 100644
--- a/gcc/config/rs6000/rs6000.c
+++ b/gcc/config/rs6000/rs6000.c
@@ -37394,6 +37394,7 @@ rs6000_disable_incompatible_switches (void)
     { OPTION_MASK_P9_VECTOR,	OTHER_P9_VECTOR_MASKS,	"power9-vector"	},
     { OPTION_MASK_P8_VECTOR,	OTHER_P8_VECTOR_MASKS,	"power8-vector"	},
     { OPTION_MASK_VSX,		OTHER_VSX_VECTOR_MASKS,	"vsx"		},
+    { OPTION_MASK_ALTIVEC,	OTHER_ALTIVEC_MASKS,	"altivec"	},
   };
 
   for (i = 0; i < ARRAY_SIZE (flags); i++)

commit 0816fafce9b6e603cb4520f677064ae74ba15430
Author: GCC Administrator <gccadmin@gcc.gnu.org>
Date:   Fri Mar 13 00:17:19 2020 +0000

    Daily bump.

diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
index e2b9f19d525..a30f6fc9796 100644
--- a/gcc/DATESTAMP
+++ b/gcc/DATESTAMP
@@ -1 +1 @@
-20200312
+20200313

commit 593e47a6134085e9b856c62f98f72acd4446ba7c
Author: Eric Botcazou <ebotcazou@gcc.gnu.org>
Date:   Fri Mar 13 09:58:44 2020 +0100

    Fix incorrect filling of delay slots in branchy code at -O2
    
    The issue is that relax_delay_slots can streamline the CFG in some cases,
    in particular remove BARRIERs, but removing BARRIERs changes the way the
    instructions are associated with (basic) blocks by the liveness analysis
    code in resource.c (find_basic_block) and thus can cause entries in the
    cache maintained by resource.c to become outdated, thus producing wrong
    answers downstream.
    
    The fix is to invalidate the cache entries affected by the removal of
    BARRIERs in relax_delay_slots, i.e. for the instructions down to the
    next BARRIER.
    
            PR rtl-optimization/94119
            * resource.h (clear_hashed_info_until_next_barrier): Declare.
            * resource.c (clear_hashed_info_until_next_barrier): New function.
            * reorg.c (add_to_delay_list): Fix formatting.
            (relax_delay_slots): Call clear_hashed_info_until_next_barrier on
            the next instruction after removing a BARRIER.

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 92d5b0afb2e..bccc2a1a68d 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,12 @@
+2019-03-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/94119
+	* resource.h (clear_hashed_info_until_next_barrier): Declare.
+	* resource.c (clear_hashed_info_until_next_barrier): New function.
+	* reorg.c (add_to_delay_list): Fix formatting.
+	(relax_delay_slots): Call clear_hashed_info_until_next_barrier on
+	the next instruction after removing a BARRIER.
+
 2020-03-12  Bill Schmidt  <wschmidt@linux.ibm.com>
 
 	Backport from master
diff --git a/gcc/reorg.c b/gcc/reorg.c
index 81349382b81..a93cf90e0ab 100644
--- a/gcc/reorg.c
+++ b/gcc/reorg.c
@@ -577,8 +577,9 @@ add_to_delay_list (rtx_insn *insn, vec<rtx_insn *> *delay_list)
 {
   /* If INSN has its block number recorded, clear it since we may
      be moving the insn to a new block.  */
-      clear_hashed_info_for_insn (insn);
-      delay_list->safe_push (insn);
+  clear_hashed_info_for_insn (insn);
+
+  delay_list->safe_push (insn);
 }
 
 /* Delete INSN from the delay slot of the insn that it is in, which may
@@ -3221,7 +3222,14 @@ relax_delay_slots (rtx_insn *first)
 
 	      if (invert_jump (jump_insn, label, 1))
 		{
-		  delete_related_insns (next);
+		  rtx_insn *from = delete_related_insns (next);
+
+		  /* We have just removed a BARRIER, which means that the block
+		     number of the next insns has effectively been changed (see
+		     find_basic_block in resource.c), so clear it.  */
+		  if (from)
+		    clear_hashed_info_until_next_barrier (from);
+
 		  next = jump_insn;
 		}
 
@@ -3494,18 +3502,22 @@ relax_delay_slots (rtx_insn *first)
 
 	      if (invert_jump (delay_jump_insn, label, 1))
 		{
-		  int i;
-
 		  /* Must update the INSN_FROM_TARGET_P bits now that
 		     the branch is reversed, so that mark_target_live_regs
 		     will handle the delay slot insn correctly.  */
-		  for (i = 1; i < XVECLEN (PATTERN (insn), 0); i++)
+		  for (int i = 1; i < XVECLEN (PATTERN (insn), 0); i++)
 		    {
 		      rtx slot = XVECEXP (PATTERN (insn), 0, i);
 		      INSN_FROM_TARGET_P (slot) = ! INSN_FROM_TARGET_P (slot);
 		    }
 
-		  delete_related_insns (next);
+		  /* We have just removed a BARRIER, which means that the block
+		     number of the next insns has effectively been changed (see
+		     find_basic_block in resource.c), so clear it.  */
+		  rtx_insn *from = delete_related_insns (next);
+		  if (from)
+		    clear_hashed_info_until_next_barrier (from);
+
 		  next = insn;
 		}
 
diff --git a/gcc/resource.c b/gcc/resource.c
index c4bcfd7dc71..164b55e561b 100644
--- a/gcc/resource.c
+++ b/gcc/resource.c
@@ -1311,7 +1311,26 @@ clear_hashed_info_for_insn (rtx_insn *insn)
 	tinfo->block = -1;
     }
 }
-
+
+/* Clear any hashed information that we have stored for instructions
+   between INSN and the next BARRIER that follow a JUMP or a LABEL.  */
+
+void
+clear_hashed_info_until_next_barrier (rtx_insn *insn)
+{
+  while (insn && !BARRIER_P (insn))
+    {
+      if (JUMP_P (insn) || LABEL_P (insn))
+	{
+	  rtx_insn *next = next_active_insn (insn);
+	  if (next)
+	    clear_hashed_info_for_insn (next);
+	}
+
+      insn = next_nonnote_insn (insn);
+    }
+}
+
 /* Increment the tick count for the basic block that contains INSN.  */
 
 void
diff --git a/gcc/resource.h b/gcc/resource.h
index 7916344c584..3e969e52176 100644
--- a/gcc/resource.h
+++ b/gcc/resource.h
@@ -46,6 +46,7 @@ extern void mark_set_resources (rtx, struct resources *, int,
 				enum mark_resource_type);
 extern void mark_referenced_resources (rtx, struct resources *, bool);
 extern void clear_hashed_info_for_insn (rtx_insn *);
+extern void clear_hashed_info_until_next_barrier (rtx_insn *);
 extern void incr_ticks_for_insn (rtx_insn *);
 extern void mark_end_of_function_resources (rtx, bool);
 extern void init_resource_info (rtx_insn *);

commit db3584552871c8caccdc22e97ea1573da9458253
Author: Richard Biener <rguenther@suse.de>
Date:   Fri Mar 13 13:56:26 2020 +0100

    tree-optimization/94163 constrain alignment set by PRE
    
    This avoids HWI -> unsigned truncation to end up with zero alignment
    which set_ptr_info_alignment ICEs on.
    
    2020-03-13  Richard Biener  <rguenther@suse.de>
    
            PR tree-optimization/94163
            * tree-ssa-pre.c (create_expression_by_pieces): Check
            whether alignment would be zero.

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index bccc2a1a68d..db18605fbe4 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,9 @@
+2020-03-13  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/94163
+	* tree-ssa-pre.c (create_expression_by_pieces): Check
+	whether alignment would be zero.
+
 2019-03-13  Eric Botcazou  <ebotcazou@adacore.com>
 
 	PR rtl-optimization/94119
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
index 8bd17b82368..7b171bc4e8f 100644
--- a/gcc/tree-ssa-pre.c
+++ b/gcc/tree-ssa-pre.c
@@ -2810,7 +2810,8 @@ create_expression_by_pieces (basic_block block, pre_expr expr,
 	      unsigned HOST_WIDE_INT hmisalign
 		= args.length () == 3 ? tree_to_uhwi (args[2]) : 0;
 	      if ((halign & (halign - 1)) == 0
-		  && (hmisalign & ~(halign - 1)) == 0)
+		  && (hmisalign & ~(halign - 1)) == 0
+		  && (unsigned int)halign != 0)
 		set_ptr_info_alignment (get_ptr_info (forcedname),
 					halign, hmisalign);
 	    }

commit ab768006bc54baa668205c1b2e65e64fb044d155
Author: Eric Botcazou <ebotcazou@gcc.gnu.org>
Date:   Fri Mar 13 18:03:41 2020 +0100

    Fix wrong year in ChangeLog.

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index db18605fbe4..ec0284ad8be 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -4,7 +4,7 @@
 	* tree-ssa-pre.c (create_expression_by_pieces): Check
 	whether alignment would be zero.
 
-2019-03-13  Eric Botcazou  <ebotcazou@adacore.com>
+2020-03-13  Eric Botcazou  <ebotcazou@adacore.com>
 
 	PR rtl-optimization/94119
 	* resource.h (clear_hashed_info_until_next_barrier): Declare.

commit 0f66f1d80396e2592f9efb802d311c714233369f
Author: GCC Administrator <gccadmin@gcc.gnu.org>
Date:   Sat Mar 14 00:17:41 2020 +0000

    Daily bump.

diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
index a30f6fc9796..3f10b5f6c1b 100644
--- a/gcc/DATESTAMP
+++ b/gcc/DATESTAMP
@@ -1 +1 @@
-20200313
+20200314
